// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ModelicaGrammarTrait {
    /// Semantic action for non-terminal 'algorithm'
    fn algorithm(&mut self, _arg: &Algorithm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'and'
    fn and(&mut self, _arg: &And) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'annotation'
    fn annotation(&mut self, _arg: &Annotation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'block'
    fn block(&mut self, _arg: &Block) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class'
    fn class(&mut self, _arg: &Class) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'connector'
    fn connector(&mut self, _arg: &Connector) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'constant'
    fn constant(&mut self, _arg: &Constant) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'discrete'
    fn discrete(&mut self, _arg: &Discrete) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'encapsulated'
    fn encapsulated(&mut self, _arg: &Encapsulated) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'end'
    fn end(&mut self, _arg: &End) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'equation'
    fn equation(&mut self, _arg: &Equation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'expandable'
    fn expandable(&mut self, _arg: &Expandable) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'false'
    fn r#false(&mut self, _arg: &False) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'final'
    fn r#final(&mut self, _arg: &Final) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'flow'
    fn flow(&mut self, _arg: &Flow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function'
    fn function(&mut self, _arg: &Function) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import'
    fn import(&mut self, _arg: &Import) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'impure'
    fn impure(&mut self, _arg: &Impure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'initial'
    fn initial(&mut self, _arg: &Initial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'inner'
    fn inner(&mut self, _arg: &Inner) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'model'
    fn model(&mut self, _arg: &Model) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'not'
    fn not(&mut self, _arg: &Not) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'operator'
    fn operator(&mut self, _arg: &Operator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'or'
    fn or(&mut self, _arg: &Or) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'outer'
    fn outer(&mut self, _arg: &Outer) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'package'
    fn package(&mut self, _arg: &Package) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'partial'
    fn partial(&mut self, _arg: &Partial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'protected'
    fn protected(&mut self, _arg: &Protected) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'public'
    fn public(&mut self, _arg: &Public) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'pure'
    fn pure(&mut self, _arg: &Pure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'record'
    fn record(&mut self, _arg: &Record) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'redeclare'
    fn redeclare(&mut self, _arg: &Redeclare) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'stream'
    fn stream(&mut self, _arg: &Stream) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'true'
    fn r#true(&mut self, _arg: &True) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'within'
    fn within(&mut self, _arg: &Within) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ident'
    fn ident(&mut self, _arg: &Ident) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'string'
    fn string(&mut self, _arg: &String) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_integer'
    fn unsigned_integer(&mut self, _arg: &UnsignedInteger) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_real'
    fn unsigned_real(&mut self, _arg: &UnsignedReal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'stored_definition'
    fn stored_definition(&mut self, _arg: &StoredDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_definition'
    fn class_definition(&mut self, _arg: &ClassDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_prefixes'
    fn class_prefixes(&mut self, _arg: &ClassPrefixes) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_specifier'
    fn class_specifier(&mut self, _arg: &ClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'long_class_specifier'
    fn long_class_specifier(&mut self, _arg: &LongClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'composition'
    fn composition(&mut self, _arg: &Composition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_list'
    fn element_list(&mut self, _arg: &ElementList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element'
    fn element(&mut self, _arg: &Element) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import_clause'
    fn import_clause(&mut self, _arg: &ImportClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import_list'
    fn import_list(&mut self, _arg: &ImportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_clause'
    fn component_clause(&mut self, _arg: &ComponentClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type_prefix'
    fn type_prefix(&mut self, _arg: &TypePrefix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_list'
    fn component_list(&mut self, _arg: &ComponentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_declaration'
    fn component_declaration(&mut self, _arg: &ComponentDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'declaration'
    fn declaration(&mut self, _arg: &Declaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'equation_section'
    fn equation_section(&mut self, _arg: &EquationSection) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'algorithm_section'
    fn algorithm_section(&mut self, _arg: &AlgorithmSection) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'some_equation'
    fn some_equation(&mut self, _arg: &SomeEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'simple_expression'
    fn simple_expression(&mut self, _arg: &SimpleExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_expression'
    fn logical_expression(&mut self, _arg: &LogicalExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_term'
    fn logical_term(&mut self, _arg: &LogicalTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_factor'
    fn logical_factor(&mut self, _arg: &LogicalFactor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'relation'
    fn relation(&mut self, _arg: &Relation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'relational_operator'
    fn relational_operator(&mut self, _arg: &RelationalOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'arithmetic_expression'
    fn arithmetic_expression(&mut self, _arg: &ArithmeticExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'add_operator'
    fn add_operator(&mut self, _arg: &AddOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'term'
    fn term(&mut self, _arg: &Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'mul_operator'
    fn mul_operator(&mut self, _arg: &MulOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'primary'
    fn primary(&mut self, _arg: &Primary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_number'
    fn unsigned_number(&mut self, _arg: &UnsignedNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type_specifier'
    fn type_specifier(&mut self, _arg: &TypeSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'name'
    fn name(&mut self, _arg: &Name) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_reference'
    fn component_reference(&mut self, _arg: &ComponentReference) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'array_subscripts'
    fn array_subscripts(&mut self, _arg: &ArraySubscripts) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'subscript'
    fn subscript(&mut self, _arg: &Subscript) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'description'
    fn description(&mut self, _arg: &Description) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'description_string'
    fn description_string(&mut self, _arg: &DescriptionString) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'annotation_clause'
    fn annotation_clause(&mut self, _arg: &AnnotationClause) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'_>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 42
///
/// `unsigned_real: /[0-9]+\.[0-9]+/@decimal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealDecimal {
    pub decimal: crate::ir::Token, /* [0-9]+\.[0-9]+ */
}

///
/// Type derived for production 43
///
/// `unsigned_real: /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealScientific {
    pub scientific: crate::ir::Token, /* [0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)? */
}

///
/// Type derived for production 44
///
/// `unsigned_real: /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealScientific2 {
    pub scientific2: crate::ir::Token, /* \.[0-9]+([eE][+-]?[0-9]+)? */
}

///
/// Type derived for production 58
///
/// `class_prefixesGroup: class;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupClass {
    pub class: Class,
}

///
/// Type derived for production 59
///
/// `class_prefixesGroup: model;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupModel {
    pub model: Model,
}

///
/// Type derived for production 60
///
/// `class_prefixesGroup: class_prefixesOpt0 /* Option */ record;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupClassPrefixesOpt0Record {
    pub class_prefixes_opt0: Option<ClassPrefixesOpt0>,
    pub record: Record,
}

///
/// Type derived for production 61
///
/// `class_prefixesGroup: block;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupBlock {
    pub block: Block,
}

///
/// Type derived for production 62
///
/// `class_prefixesGroup: class_prefixesOpt1 /* Option */ connector;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupClassPrefixesOpt1Connector {
    pub class_prefixes_opt1: Option<ClassPrefixesOpt1>,
    pub connector: Connector,
}

///
/// Type derived for production 63
///
/// `class_prefixesGroup: type;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupType {
    pub r#type: Type,
}

///
/// Type derived for production 64
///
/// `class_prefixesGroup: package;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupPackage {
    pub package: Package,
}

///
/// Type derived for production 65
///
/// `class_prefixesGroup: class_prefixesOpt2 /* Option */ class_prefixesOpt3 /* Option */ function;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupClassPrefixesOpt2ClassPrefixesOpt3Function {
    pub class_prefixes_opt2: Option<ClassPrefixesOpt2>,
    pub class_prefixes_opt3: Option<ClassPrefixesOpt3>,
    pub function: Function,
}

///
/// Type derived for production 66
///
/// `class_prefixesGroup: operator;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesGroupOperator {
    pub operator: Operator,
}

///
/// Type derived for production 70
///
/// `class_prefixesOpt2Group: pure;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt2GroupPure {
    pub pure: Pure,
}

///
/// Type derived for production 71
///
/// `class_prefixesOpt2Group: impure;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt2GroupImpure {
    pub impure: Impure,
}

///
/// Type derived for production 83
///
/// `compositionListGroup: public element_list;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupPublicElementList {
    pub public: Public,
    pub element_list: crate::modelica_grammar::ElementList,
}

///
/// Type derived for production 84
///
/// `compositionListGroup: protected element_list;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupProtectedElementList {
    pub protected: Protected,
    pub element_list: crate::modelica_grammar::ElementList,
}

///
/// Type derived for production 85
///
/// `compositionListGroup: equation_section;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupEquationSection {
    pub equation_section: crate::modelica_grammar::EquationSection,
}

///
/// Type derived for production 86
///
/// `compositionListGroup: algorithm_section;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupAlgorithmSection {
    pub algorithm_section: crate::modelica_grammar::AlgorithmSection,
}

///
/// Type derived for production 91
///
/// `element: import_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementImportClause {
    pub import_clause: ImportClause,
}

///
/// Type derived for production 92
///
/// `element: elementOpt /* Option */ elementOpt0 /* Option */ elementOpt1 /* Option */ elementOpt2 /* Option */ elementGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementElementOptElementOpt0ElementOpt1ElementOpt2ElementGroup {
    pub element_opt: Option<ElementOpt>,
    pub element_opt0: Option<ElementOpt0>,
    pub element_opt1: Option<ElementOpt1>,
    pub element_opt2: Option<ElementOpt2>,
    pub element_group: ElementGroup,
}

///
/// Type derived for production 93
///
/// `elementGroup: class_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementGroupClassDefinition {
    pub class_definition: ClassDefinition,
}

///
/// Type derived for production 94
///
/// `elementGroup: component_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementGroupComponentClause {
    pub component_clause: ComponentClause,
}

///
/// Type derived for production 104
///
/// `import_clauseGroup: ident : %t_type '='^ /* Clipped */ name;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseGroupIdentEquName {
    pub ident: crate::ir::Token,
    pub name: crate::ir::Name,
}

///
/// Type derived for production 105
///
/// `import_clauseGroup: name import_clauseOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseGroupNameImportClauseOpt {
    pub name: crate::ir::Name,
    pub import_clause_opt: Option<ImportClauseOpt>,
}

///
/// Type derived for production 107
///
/// `import_clauseOptGroup: '.*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupDotStar {
    pub dot_star: crate::ir::Token, /* .* */
}

///
/// Type derived for production 108
///
/// `import_clauseOptGroup: '.'^ /* Clipped */ import_clauseOptGroupGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupDotImportClauseOptGroupGroup {
    pub import_clause_opt_group_group: ImportClauseOptGroupGroup,
}

///
/// Type derived for production 109
///
/// `import_clauseOptGroupGroup: '*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupGroupStar {
    pub star: crate::ir::Token, /* * */
}

///
/// Type derived for production 110
///
/// `import_clauseOptGroupGroup: '{' import_list '}';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupGroupLBraceImportListRBrace {
    pub l_brace: crate::ir::Token, /* { */
    pub import_list: ImportList,
    pub r_brace: crate::ir::Token, /* } */
}

///
/// Type derived for production 120
///
/// `type_prefixOpt1Group: input;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1GroupInput {
    pub input: Input,
}

///
/// Type derived for production 121
///
/// `type_prefixOpt1Group: output;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1GroupOutput {
    pub output: Output,
}

///
/// Type derived for production 124
///
/// `type_prefixOpt0Group: discrete;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupDiscrete {
    pub discrete: Discrete,
}

///
/// Type derived for production 125
///
/// `type_prefixOpt0Group: parameter;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupParameter {
    pub parameter: Parameter,
}

///
/// Type derived for production 126
///
/// `type_prefixOpt0Group: constant;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupConstant {
    pub constant: Constant,
}

///
/// Type derived for production 129
///
/// `type_prefixOptGroup: flow;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOptGroupFlow {
    pub flow: Flow,
}

///
/// Type derived for production 130
///
/// `type_prefixOptGroup: stream;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOptGroupStream {
    pub stream: Stream,
}

///
/// Type derived for production 169
///
/// `relational_operator: '<';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLT {
    pub l_t: crate::ir::Token, /* < */
}

///
/// Type derived for production 170
///
/// `relational_operator: '<=';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLTEqu {
    pub l_t_equ: crate::ir::Token, /* <= */
}

///
/// Type derived for production 171
///
/// `relational_operator: '>';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorGT {
    pub g_t: crate::ir::Token, /* > */
}

///
/// Type derived for production 172
///
/// `relational_operator: '>=';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorGTEqu {
    pub g_t_equ: crate::ir::Token, /* >= */
}

///
/// Type derived for production 173
///
/// `relational_operator: '==';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorEquEqu {
    pub equ_equ: crate::ir::Token, /* == */
}

///
/// Type derived for production 174
///
/// `relational_operator: '<>';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLTGT {
    pub l_t_g_t: crate::ir::Token, /* <> */
}

///
/// Type derived for production 180
///
/// `add_operator: '+';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorPlus {
    pub plus: crate::ir::Token, /* + */
}

///
/// Type derived for production 181
///
/// `add_operator: '-';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorMinus {
    pub minus: crate::ir::Token, /* - */
}

///
/// Type derived for production 182
///
/// `add_operator: '.+';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorDotPlus {
    pub dot_plus: crate::ir::Token, /* .+ */
}

///
/// Type derived for production 183
///
/// `add_operator: '.-';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorDotMinus {
    pub dot_minus: crate::ir::Token, /* .- */
}

///
/// Type derived for production 187
///
/// `mul_operator: '*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorStar {
    pub star: crate::ir::Token, /* * */
}

///
/// Type derived for production 188
///
/// `mul_operator: '/';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorSlash {
    pub slash: crate::ir::Token, /* / */
}

///
/// Type derived for production 189
///
/// `mul_operator: '.*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorDotStar {
    pub dot_star: crate::ir::Token, /* .* */
}

///
/// Type derived for production 190
///
/// `mul_operator: './';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorDotSlash {
    pub dot_slash: crate::ir::Token, /* ./ */
}

///
/// Type derived for production 193
///
/// `factorListGroup: '^';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorListGroupCircumflex {
    pub circumflex: crate::ir::Token, /* ^ */
}

///
/// Type derived for production 194
///
/// `factorListGroup: '.^';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorListGroupDotCircumflex {
    pub dot_circumflex: crate::ir::Token, /* .^ */
}

///
/// Type derived for production 196
///
/// `primary: unsigned_number;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryUnsignedNumber {
    pub unsigned_number: UnsignedNumber,
}

///
/// Type derived for production 197
///
/// `primary: string;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryString {
    pub string: String,
}

///
/// Type derived for production 198
///
/// `primary: false;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryFalse {
    pub r#false: False,
}

///
/// Type derived for production 199
///
/// `primary: true;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryTrue {
    pub r#true: True,
}

///
/// Type derived for production 200
///
/// `primary: component_reference;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryComponentReference {
    pub component_reference: crate::ir::ComponentReference,
}

///
/// Type derived for production 201
///
/// `primary: end;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryEnd {
    pub end: End,
}

///
/// Type derived for production 202
///
/// `unsigned_number: unsigned_integer : %t_type;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedNumberUnsignedInteger {
    pub unsigned_integer: crate::ir::Token,
}

///
/// Type derived for production 203
///
/// `unsigned_number: unsigned_real : %t_type;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedNumberUnsignedReal {
    pub unsigned_real: crate::ir::Token,
}

///
/// Type derived for production 220
///
/// `subscript: ':';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubscriptColon {
    pub colon: crate::ir::Token, /* : */
}

///
/// Type derived for production 221
///
/// `subscript: expression : term;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubscriptExpression {
    pub expression: crate::ir::Expression,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal add_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOperator {
    Plus(AddOperatorPlus),
    Minus(AddOperatorMinus),
    DotPlus(AddOperatorDotPlus),
    DotMinus(AddOperatorDotMinus),
}

///
/// Type derived for non-terminal algorithm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Algorithm {
    pub algorithm: crate::ir::Token, /* algorithm */
}

///
/// Type derived for non-terminal algorithm_section
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSection {
    pub algorithm_section_opt: Option<AlgorithmSectionOpt>,
    pub algorithm_section_list: Vec<AlgorithmSectionList>,
}

///
/// Type derived for non-terminal algorithm_sectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSectionList {
    pub statement: crate::ir::Statement,
}

///
/// Type derived for non-terminal algorithm_sectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSectionOpt {}

///
/// Type derived for non-terminal and
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct And {
    pub and: crate::ir::Token, /* and */
}

///
/// Type derived for non-terminal annotation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Annotation {
    pub annotation: crate::ir::Token, /* annotation */
}

///
/// Type derived for non-terminal annotation_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AnnotationClause {
    pub annotation: Annotation,
}

///
/// Type derived for non-terminal arithmetic_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpression {
    pub arithmetic_expression_opt: Option<ArithmeticExpressionOpt>,
    pub term: crate::ir::Expression,
    pub arithmetic_expression_list: Vec<ArithmeticExpressionList>,
}

///
/// Type derived for non-terminal arithmetic_expressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpressionList {
    pub add_operator: AddOperator,
    pub term: crate::ir::Expression,
}

///
/// Type derived for non-terminal arithmetic_expressionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpressionOpt {
    pub add_operator: AddOperator,
}

///
/// Type derived for non-terminal array_subscripts
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySubscripts {
    pub subscript: Subscript,
    pub array_subscripts_list: Vec<ArraySubscriptsList>,
}

///
/// Type derived for non-terminal array_subscriptsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySubscriptsList {
    pub subscript: Subscript,
}

///
/// Type derived for non-terminal block
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Block {
    pub block: crate::ir::Token, /* block */
}

///
/// Type derived for non-terminal class
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Class {
    pub class: crate::ir::Token, /* class */
}

///
/// Type derived for non-terminal class_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassDefinition {
    pub class_definition_opt: Option<ClassDefinitionOpt>,
    pub class_prefixes: ClassPrefixes,
    pub class_specifier: ClassSpecifier,
}

///
/// Type derived for non-terminal class_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassDefinitionOpt {
    pub encapsulated: Encapsulated,
}

///
/// Type derived for non-terminal class_prefixes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixes {
    pub class_prefixes_opt: Option<ClassPrefixesOpt>,
    pub class_prefixes_group: ClassPrefixesGroup,
}

///
/// Type derived for non-terminal class_prefixesGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ClassPrefixesGroup {
    Class(ClassPrefixesGroupClass),
    Model(ClassPrefixesGroupModel),
    ClassPrefixesOpt0Record(ClassPrefixesGroupClassPrefixesOpt0Record),
    Block(ClassPrefixesGroupBlock),
    ClassPrefixesOpt1Connector(ClassPrefixesGroupClassPrefixesOpt1Connector),
    Type(ClassPrefixesGroupType),
    Package(ClassPrefixesGroupPackage),
    ClassPrefixesOpt2ClassPrefixesOpt3Function(
        ClassPrefixesGroupClassPrefixesOpt2ClassPrefixesOpt3Function,
    ),
    Operator(ClassPrefixesGroupOperator),
}

///
/// Type derived for non-terminal class_prefixesOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt {
    pub partial: Partial,
}

///
/// Type derived for non-terminal class_prefixesOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt0 {
    pub operator: Operator,
}

///
/// Type derived for non-terminal class_prefixesOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt1 {
    pub expandable: Expandable,
}

///
/// Type derived for non-terminal class_prefixesOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt2 {
    pub class_prefixes_opt2_group: ClassPrefixesOpt2Group,
}

///
/// Type derived for non-terminal class_prefixesOpt2Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ClassPrefixesOpt2Group {
    Pure(ClassPrefixesOpt2GroupPure),
    Impure(ClassPrefixesOpt2GroupImpure),
}

///
/// Type derived for non-terminal class_prefixesOpt3
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt3 {
    pub operator: Operator,
}

///
/// Type derived for non-terminal class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassSpecifier {
    pub long_class_specifier: LongClassSpecifier,
}

///
/// Type derived for non-terminal component_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentClause {
    pub type_prefix: TypePrefix,
    pub type_specifier: TypeSpecifier,
    pub component_clause_opt: Option<ComponentClauseOpt>,
    pub component_list: crate::modelica_grammar::ComponentList,
}

///
/// Type derived for non-terminal component_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentClauseOpt {
    pub array_subscripts: ArraySubscripts,
}

///
/// Type derived for non-terminal component_declaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentDeclaration {
    pub declaration: Declaration,
    pub description: Description,
}

///
/// Type derived for non-terminal component_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentList {
    pub component_declaration: ComponentDeclaration,
    pub component_list_list: Vec<ComponentListList>,
}

///
/// Type derived for non-terminal component_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentListList {
    pub component_declaration: ComponentDeclaration,
}

///
/// Type derived for non-terminal component_reference
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReference {
    pub component_reference_opt: Option<ComponentReferenceOpt>,
    pub ident: crate::ir::Token,
    pub component_reference_list: Vec<ComponentReferenceList>,
}

///
/// Type derived for non-terminal component_referenceList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceList {
    pub ident: crate::ir::Token,
    pub component_reference_opt0: Option<ComponentReferenceOpt0>,
}

///
/// Type derived for non-terminal component_referenceOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceOpt {}

///
/// Type derived for non-terminal component_referenceOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceOpt0 {
    pub array_subscripts: ArraySubscripts,
}

///
/// Type derived for non-terminal composition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Composition {
    pub element_list: crate::modelica_grammar::ElementList,
    pub composition_list: Vec<CompositionList>,
}

///
/// Type derived for non-terminal compositionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionList {
    pub composition_list_group: CompositionListGroup,
}

///
/// Type derived for non-terminal compositionListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CompositionListGroup {
    PublicElementList(CompositionListGroupPublicElementList),
    ProtectedElementList(CompositionListGroupProtectedElementList),
    EquationSection(CompositionListGroupEquationSection),
    AlgorithmSection(CompositionListGroupAlgorithmSection),
}

///
/// Type derived for non-terminal connector
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Connector {
    pub connector: crate::ir::Token, /* connector */
}

///
/// Type derived for non-terminal constant
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Constant {
    pub constant: crate::ir::Token, /* constant */
}

///
/// Type derived for non-terminal declaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Declaration {
    pub ident: crate::ir::Token,
    pub declaration_opt: Option<DeclarationOpt>,
}

///
/// Type derived for non-terminal declarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationOpt {
    pub array_subscripts: ArraySubscripts,
}

///
/// Type derived for non-terminal description
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Description {
    pub description_string: DescriptionString,
    pub description_opt: Option<DescriptionOpt>,
}

///
/// Type derived for non-terminal descriptionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionOpt {
    pub annotation_clause: AnnotationClause,
}

///
/// Type derived for non-terminal description_string
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionString {
    pub description_string_opt: Option<DescriptionStringOpt>,
}

///
/// Type derived for non-terminal description_stringOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionStringOpt {
    pub string: String,
    pub description_string_opt_list: Vec<DescriptionStringOptList>,
}

///
/// Type derived for non-terminal description_stringOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionStringOptList {
    pub string: String,
}

///
/// Type derived for non-terminal discrete
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Discrete {
    pub discrete: crate::ir::Token, /* discrete */
}

///
/// Type derived for non-terminal element
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Element {
    ImportClause(ElementImportClause),
    ElementOptElementOpt0ElementOpt1ElementOpt2ElementGroup(
        ElementElementOptElementOpt0ElementOpt1ElementOpt2ElementGroup,
    ),
}

///
/// Type derived for non-terminal elementGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementGroup {
    ClassDefinition(ElementGroupClassDefinition),
    ComponentClause(ElementGroupComponentClause),
}

///
/// Type derived for non-terminal elementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementOpt {
    pub redeclare: Redeclare,
}

///
/// Type derived for non-terminal elementOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal elementOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementOpt1 {
    pub inner: Inner,
}

///
/// Type derived for non-terminal elementOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementOpt2 {
    pub outer: Outer,
}

///
/// Type derived for non-terminal element_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementList {
    pub element_list_list: Vec<ElementListList>,
}

///
/// Type derived for non-terminal element_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementListList {
    pub element: Element,
    pub semicolon: crate::ir::Token, /* ; */
}

///
/// Type derived for non-terminal encapsulated
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Encapsulated {
    pub encapsulated: crate::ir::Token, /* encapsulated */
}

///
/// Type derived for non-terminal end
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct End {
    pub end: crate::ir::Token, /* end */
}

///
/// Type derived for non-terminal equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equation {
    pub equation: crate::ir::Token, /* equation */
}

///
/// Type derived for non-terminal equation_section
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSection {
    pub equation_section_opt: Option<EquationSectionOpt>,
    pub equation_section_list: Vec<EquationSectionList>,
}

///
/// Type derived for non-terminal equation_sectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSectionList {
    pub some_equation: crate::ir::Equation,
}

///
/// Type derived for non-terminal equation_sectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSectionOpt {}

///
/// Type derived for non-terminal expandable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expandable {
    pub expandable: crate::ir::Token, /* expandable */
}

///
/// Type derived for non-terminal expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression {
    pub simple_expression: crate::ir::Expression,
}

///
/// Type derived for non-terminal factor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Factor {
    pub primary: crate::ir::Expression,
    pub factor_list: Vec<FactorList>,
}

///
/// Type derived for non-terminal factorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorList {
    pub factor_list_group: FactorListGroup,
    pub primary: crate::ir::Expression,
}

///
/// Type derived for non-terminal factorListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FactorListGroup {
    Circumflex(FactorListGroupCircumflex),
    DotCircumflex(FactorListGroupDotCircumflex),
}

///
/// Type derived for non-terminal false
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct False {
    pub r#false: crate::ir::Token, /* false */
}

///
/// Type derived for non-terminal final
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Final {
    pub r#final: crate::ir::Token, /* final */
}

///
/// Type derived for non-terminal flow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Flow {
    pub flow: crate::ir::Token, /* flow */
}

///
/// Type derived for non-terminal function
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Function {
    pub function: crate::ir::Token, /* function */
}

///
/// Type derived for non-terminal ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ident {
    pub ident: crate::ir::Token, /* [_a-zA-Z][_a-zA-Z0-9]* */
}

///
/// Type derived for non-terminal import
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Import {
    pub import: crate::ir::Token, /* import */
}

///
/// Type derived for non-terminal import_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClause {
    pub import: Import,
    pub import_clause_group: ImportClauseGroup,
    pub description: Description,
}

///
/// Type derived for non-terminal import_clauseGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseGroup {
    IdentEquName(ImportClauseGroupIdentEquName),
    NameImportClauseOpt(ImportClauseGroupNameImportClauseOpt),
}

///
/// Type derived for non-terminal import_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOpt {
    pub import_clause_opt_group: ImportClauseOptGroup,
}

///
/// Type derived for non-terminal import_clauseOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseOptGroup {
    DotStar(ImportClauseOptGroupDotStar),
    DotImportClauseOptGroupGroup(ImportClauseOptGroupDotImportClauseOptGroupGroup),
}

///
/// Type derived for non-terminal import_clauseOptGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseOptGroupGroup {
    Star(ImportClauseOptGroupGroupStar),
    LBraceImportListRBrace(ImportClauseOptGroupGroupLBraceImportListRBrace),
}

///
/// Type derived for non-terminal import_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportList {
    pub ident: crate::ir::Token,
    pub import_list_list: Vec<ImportListList>,
}

///
/// Type derived for non-terminal import_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportListList {
    pub ident: crate::ir::Token,
}

///
/// Type derived for non-terminal impure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Impure {
    pub impure: crate::ir::Token, /* impure */
}

///
/// Type derived for non-terminal initial
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Initial {
    pub initial: crate::ir::Token, /* initial */
}

///
/// Type derived for non-terminal inner
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inner {
    pub inner: crate::ir::Token, /* inner */
}

///
/// Type derived for non-terminal input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Input {
    pub input: crate::ir::Token, /* input */
}

///
/// Type derived for non-terminal logical_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalExpression {
    pub logical_term: crate::ir::Expression,
    pub logical_expression_list: Vec<LogicalExpressionList>,
}

///
/// Type derived for non-terminal logical_expressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalExpressionList {
    pub logical_term: crate::ir::Expression,
}

///
/// Type derived for non-terminal logical_factor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalFactor {
    pub logical_factor_opt: Option<LogicalFactorOpt>,
    pub relation: crate::ir::Expression,
}

///
/// Type derived for non-terminal logical_factorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalFactorOpt {
    pub not: Not,
}

///
/// Type derived for non-terminal logical_term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalTerm {
    pub logical_factor: crate::ir::Expression,
    pub logical_term_list: Vec<LogicalTermList>,
}

///
/// Type derived for non-terminal logical_termList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalTermList {
    pub logical_factor: crate::ir::Expression,
}

///
/// Type derived for non-terminal long_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LongClassSpecifier {
    pub name: crate::ir::Token,
    pub composition: crate::modelica_grammar::Composition,
    pub ident: crate::ir::Token,
}

///
/// Type derived for non-terminal model
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Model {
    pub model: crate::ir::Token, /* model */
}

///
/// Type derived for non-terminal mul_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MulOperator {
    Star(MulOperatorStar),
    Slash(MulOperatorSlash),
    DotStar(MulOperatorDotStar),
    DotSlash(MulOperatorDotSlash),
}

///
/// Type derived for non-terminal name
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Name {
    pub ident: crate::ir::Token,
    pub name_list: Vec<NameList>,
}

///
/// Type derived for non-terminal nameList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NameList {
    pub ident: crate::ir::Token,
}

///
/// Type derived for non-terminal not
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Not {
    pub not: crate::ir::Token, /* not */
}

///
/// Type derived for non-terminal operator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator {
    pub operator: crate::ir::Token, /* operator */
}

///
/// Type derived for non-terminal or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Or {
    pub or: crate::ir::Token, /* or */
}

///
/// Type derived for non-terminal outer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Outer {
    pub outer: crate::ir::Token, /* outer */
}

///
/// Type derived for non-terminal output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Output {
    pub output: crate::ir::Token, /* output */
}

///
/// Type derived for non-terminal package
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Package {
    pub package: crate::ir::Token, /* package */
}

///
/// Type derived for non-terminal parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parameter {
    pub parameter: crate::ir::Token, /* parameter */
}

///
/// Type derived for non-terminal partial
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Partial {
    pub partial: crate::ir::Token, /* partial */
}

///
/// Type derived for non-terminal primary
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Primary {
    UnsignedNumber(PrimaryUnsignedNumber),
    String(PrimaryString),
    False(PrimaryFalse),
    True(PrimaryTrue),
    ComponentReference(PrimaryComponentReference),
    End(PrimaryEnd),
}

///
/// Type derived for non-terminal protected
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Protected {
    pub protected: crate::ir::Token, /* protected */
}

///
/// Type derived for non-terminal public
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Public {
    pub public: crate::ir::Token, /* public */
}

///
/// Type derived for non-terminal pure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Pure {
    pub pure: crate::ir::Token, /* pure */
}

///
/// Type derived for non-terminal record
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Record {
    pub record: crate::ir::Token, /* record */
}

///
/// Type derived for non-terminal redeclare
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Redeclare {
    pub redeclare: crate::ir::Token, /* redeclare */
}

///
/// Type derived for non-terminal relation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Relation {
    pub arithmetic_expression: crate::ir::Expression,
    pub relation_opt: Option<RelationOpt>,
}

///
/// Type derived for non-terminal relationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOpt {
    pub relational_operator: RelationalOperator,
    pub arithmetic_expression: crate::ir::Expression,
}

///
/// Type derived for non-terminal relational_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RelationalOperator {
    LT(RelationalOperatorLT),
    LTEqu(RelationalOperatorLTEqu),
    GT(RelationalOperatorGT),
    GTEqu(RelationalOperatorGTEqu),
    EquEqu(RelationalOperatorEquEqu),
    LTGT(RelationalOperatorLTGT),
}

///
/// Type derived for non-terminal simple_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpression {
    pub logical_expression: crate::ir::Expression,
    pub simple_expression_opt: Option<SimpleExpressionOpt>,
}

///
/// Type derived for non-terminal simple_expressionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpressionOpt {
    pub logical_expression: crate::ir::Expression,
    pub simple_expression_opt0: Option<SimpleExpressionOpt0>,
}

///
/// Type derived for non-terminal simple_expressionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpressionOpt0 {
    pub logical_expression: crate::ir::Expression,
}

///
/// Type derived for non-terminal some_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquation {
    pub simple_expression: crate::ir::Expression,
    pub expression: crate::ir::Expression,
    pub description: Description,
}

///
/// Type derived for non-terminal statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Statement {
    pub component_reference: crate::ir::ComponentReference,
    pub expression: crate::ir::Expression,
    pub description: Description,
}

///
/// Type derived for non-terminal stored_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinition {
    pub stored_definition_opt: Option<StoredDefinitionOpt>,
    pub stored_definition_list: Vec<StoredDefinitionList>,
}

///
/// Type derived for non-terminal stored_definitionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionList {
    pub stored_definition_opt0: Option<StoredDefinitionOpt0>,
    pub class_definition: ClassDefinition,
}

///
/// Type derived for non-terminal stored_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt {
    pub stored_definition_opt1: Option<StoredDefinitionOpt1>,
}

///
/// Type derived for non-terminal stored_definitionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal stored_definitionOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt1 {
    pub name: crate::ir::Name,
}

///
/// Type derived for non-terminal stream
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Stream {
    pub stream: crate::ir::Token, /* stream */
}

///
/// Type derived for non-terminal string
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String {
    pub string: crate::ir::Token, /* "[\w]*" */
}

///
/// Type derived for non-terminal subscript
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Subscript {
    Colon(SubscriptColon),
    Expression(SubscriptExpression),
}

///
/// Type derived for non-terminal term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Term {
    pub factor: crate::ir::Expression,
    pub term_list: Vec<TermList>,
}

///
/// Type derived for non-terminal termList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermList {
    pub mul_operator: MulOperator,
    pub factor: crate::ir::Expression,
}

///
/// Type derived for non-terminal true
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct True {
    pub r#true: crate::ir::Token, /* true */
}

///
/// Type derived for non-terminal type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Type {
    pub r#type: crate::ir::Token, /* type */
}

///
/// Type derived for non-terminal type_prefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefix {
    pub type_prefix_opt: Option<TypePrefixOpt>,
    pub type_prefix_opt0: Option<TypePrefixOpt0>,
    pub type_prefix_opt1: Option<TypePrefixOpt1>,
}

///
/// Type derived for non-terminal type_prefixOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt {
    pub type_prefix_opt_group: TypePrefixOptGroup,
}

///
/// Type derived for non-terminal type_prefixOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0 {
    pub type_prefix_opt0_group: TypePrefixOpt0Group,
}

///
/// Type derived for non-terminal type_prefixOpt0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOpt0Group {
    Discrete(TypePrefixOpt0GroupDiscrete),
    Parameter(TypePrefixOpt0GroupParameter),
    Constant(TypePrefixOpt0GroupConstant),
}

///
/// Type derived for non-terminal type_prefixOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1 {
    pub type_prefix_opt1_group: TypePrefixOpt1Group,
}

///
/// Type derived for non-terminal type_prefixOpt1Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOpt1Group {
    Input(TypePrefixOpt1GroupInput),
    Output(TypePrefixOpt1GroupOutput),
}

///
/// Type derived for non-terminal type_prefixOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOptGroup {
    Flow(TypePrefixOptGroupFlow),
    Stream(TypePrefixOptGroupStream),
}

///
/// Type derived for non-terminal type_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecifier {
    pub type_specifier_opt: Option<TypeSpecifierOpt>,
    pub name: crate::ir::Name,
}

///
/// Type derived for non-terminal type_specifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecifierOpt {}

///
/// Type derived for non-terminal unsigned_integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedInteger {
    pub unsigned_integer: crate::ir::Token, /* [0-9]+ */
}

///
/// Type derived for non-terminal unsigned_number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum UnsignedNumber {
    UnsignedInteger(UnsignedNumberUnsignedInteger),
    UnsignedReal(UnsignedNumberUnsignedReal),
}

///
/// Type derived for non-terminal unsigned_real
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum UnsignedReal {
    Decimal(UnsignedRealDecimal),
    Scientific(UnsignedRealScientific),
    Scientific2(UnsignedRealScientific2),
}

///
/// Type derived for non-terminal within
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Within {
    pub within: crate::ir::Token, /* within */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AddOperator(AddOperator),
    Algorithm(Algorithm),
    AlgorithmSection(AlgorithmSection),
    AlgorithmSectionList(Vec<AlgorithmSectionList>),
    AlgorithmSectionOpt(Option<AlgorithmSectionOpt>),
    And(And),
    Annotation(Annotation),
    AnnotationClause(AnnotationClause),
    ArithmeticExpression(ArithmeticExpression),
    ArithmeticExpressionList(Vec<ArithmeticExpressionList>),
    ArithmeticExpressionOpt(Option<ArithmeticExpressionOpt>),
    ArraySubscripts(ArraySubscripts),
    ArraySubscriptsList(Vec<ArraySubscriptsList>),
    Block(Block),
    Class(Class),
    ClassDefinition(ClassDefinition),
    ClassDefinitionOpt(Option<ClassDefinitionOpt>),
    ClassPrefixes(ClassPrefixes),
    ClassPrefixesGroup(ClassPrefixesGroup),
    ClassPrefixesOpt(Option<ClassPrefixesOpt>),
    ClassPrefixesOpt0(Option<ClassPrefixesOpt0>),
    ClassPrefixesOpt1(Option<ClassPrefixesOpt1>),
    ClassPrefixesOpt2(Option<ClassPrefixesOpt2>),
    ClassPrefixesOpt2Group(ClassPrefixesOpt2Group),
    ClassPrefixesOpt3(Option<ClassPrefixesOpt3>),
    ClassSpecifier(ClassSpecifier),
    ComponentClause(ComponentClause),
    ComponentClauseOpt(Option<ComponentClauseOpt>),
    ComponentDeclaration(ComponentDeclaration),
    ComponentList(ComponentList),
    ComponentListList(Vec<ComponentListList>),
    ComponentReference(ComponentReference),
    ComponentReferenceList(Vec<ComponentReferenceList>),
    ComponentReferenceOpt(Option<ComponentReferenceOpt>),
    ComponentReferenceOpt0(Option<ComponentReferenceOpt0>),
    Composition(Composition),
    CompositionList(Vec<CompositionList>),
    CompositionListGroup(CompositionListGroup),
    Connector(Connector),
    Constant(Constant),
    Declaration(Declaration),
    DeclarationOpt(Option<DeclarationOpt>),
    Description(Description),
    DescriptionOpt(Option<DescriptionOpt>),
    DescriptionString(DescriptionString),
    DescriptionStringOpt(Option<DescriptionStringOpt>),
    DescriptionStringOptList(Vec<DescriptionStringOptList>),
    Discrete(Discrete),
    Element(Element),
    ElementGroup(ElementGroup),
    ElementOpt(Option<ElementOpt>),
    ElementOpt0(Option<ElementOpt0>),
    ElementOpt1(Option<ElementOpt1>),
    ElementOpt2(Option<ElementOpt2>),
    ElementList(ElementList),
    ElementListList(Vec<ElementListList>),
    Encapsulated(Encapsulated),
    End(End),
    Equation(Equation),
    EquationSection(EquationSection),
    EquationSectionList(Vec<EquationSectionList>),
    EquationSectionOpt(Option<EquationSectionOpt>),
    Expandable(Expandable),
    Expression(Expression),
    Factor(Factor),
    FactorList(Vec<FactorList>),
    FactorListGroup(FactorListGroup),
    False(False),
    Final(Final),
    Flow(Flow),
    Function(Function),
    Ident(Ident),
    Import(Import),
    ImportClause(ImportClause),
    ImportClauseGroup(ImportClauseGroup),
    ImportClauseOpt(Option<ImportClauseOpt>),
    ImportClauseOptGroup(ImportClauseOptGroup),
    ImportClauseOptGroupGroup(ImportClauseOptGroupGroup),
    ImportList(ImportList),
    ImportListList(Vec<ImportListList>),
    Impure(Impure),
    Initial(Initial),
    Inner(Inner),
    Input(Input),
    LogicalExpression(LogicalExpression),
    LogicalExpressionList(Vec<LogicalExpressionList>),
    LogicalFactor(LogicalFactor),
    LogicalFactorOpt(Option<LogicalFactorOpt>),
    LogicalTerm(LogicalTerm),
    LogicalTermList(Vec<LogicalTermList>),
    LongClassSpecifier(LongClassSpecifier),
    Model(Model),
    MulOperator(MulOperator),
    Name(Name),
    NameList(Vec<NameList>),
    Not(Not),
    Operator(Operator),
    Or(Or),
    Outer(Outer),
    Output(Output),
    Package(Package),
    Parameter(Parameter),
    Partial(Partial),
    Primary(Primary),
    Protected(Protected),
    Public(Public),
    Pure(Pure),
    Record(Record),
    Redeclare(Redeclare),
    Relation(Relation),
    RelationOpt(Option<RelationOpt>),
    RelationalOperator(RelationalOperator),
    SimpleExpression(SimpleExpression),
    SimpleExpressionOpt(Option<SimpleExpressionOpt>),
    SimpleExpressionOpt0(Option<SimpleExpressionOpt0>),
    SomeEquation(SomeEquation),
    Statement(Statement),
    StoredDefinition(StoredDefinition),
    StoredDefinitionList(Vec<StoredDefinitionList>),
    StoredDefinitionOpt(Option<StoredDefinitionOpt>),
    StoredDefinitionOpt0(Option<StoredDefinitionOpt0>),
    StoredDefinitionOpt1(Option<StoredDefinitionOpt1>),
    Stream(Stream),
    String(String),
    Subscript(Subscript),
    Term(Term),
    TermList(Vec<TermList>),
    True(True),
    Type(Type),
    TypePrefix(TypePrefix),
    TypePrefixOpt(Option<TypePrefixOpt>),
    TypePrefixOpt0(Option<TypePrefixOpt0>),
    TypePrefixOpt0Group(TypePrefixOpt0Group),
    TypePrefixOpt1(Option<TypePrefixOpt1>),
    TypePrefixOpt1Group(TypePrefixOpt1Group),
    TypePrefixOptGroup(TypePrefixOptGroup),
    TypeSpecifier(TypeSpecifier),
    TypeSpecifierOpt(Option<TypeSpecifierOpt>),
    UnsignedInteger(UnsignedInteger),
    UnsignedNumber(UnsignedNumber),
    UnsignedReal(UnsignedReal),
    Within(Within),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ModelicaGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ModelicaGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `ModelicaGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ModelicaGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ModelicaGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData,
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `algorithm: 'algorithm';`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm(&mut self, algorithm: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm = algorithm
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let algorithm_built = Algorithm { algorithm };
        // Calling user action here
        self.user_grammar.algorithm(&algorithm_built)?;
        self.push(ASTType::Algorithm(algorithm_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `and: 'and';`
    ///
    #[parol_runtime::function_name::named]
    fn and(&mut self, and: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let and_built = And { and };
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `annotation: 'annotation';`
    ///
    #[parol_runtime::function_name::named]
    fn annotation(&mut self, annotation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation = annotation
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let annotation_built = Annotation { annotation };
        // Calling user action here
        self.user_grammar.annotation(&annotation_built)?;
        self.push(ASTType::Annotation(annotation_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `block: 'block';`
    ///
    #[parol_runtime::function_name::named]
    fn block(&mut self, block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = block
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let block_built = Block { block };
        // Calling user action here
        self.user_grammar.block(&block_built)?;
        self.push(ASTType::Block(block_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `class: 'class';`
    ///
    #[parol_runtime::function_name::named]
    fn class(&mut self, class: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class = class
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let class_built = Class { class };
        // Calling user action here
        self.user_grammar.class(&class_built)?;
        self.push(ASTType::Class(class_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `connector: 'connector';`
    ///
    #[parol_runtime::function_name::named]
    fn connector(&mut self, connector: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connector = connector
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let connector_built = Connector { connector };
        // Calling user action here
        self.user_grammar.connector(&connector_built)?;
        self.push(ASTType::Connector(connector_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `constant: 'constant';`
    ///
    #[parol_runtime::function_name::named]
    fn constant(&mut self, constant: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constant = constant
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let constant_built = Constant { constant };
        // Calling user action here
        self.user_grammar.constant(&constant_built)?;
        self.push(ASTType::Constant(constant_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `discrete: 'discrete';`
    ///
    #[parol_runtime::function_name::named]
    fn discrete(&mut self, discrete: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let discrete = discrete
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let discrete_built = Discrete { discrete };
        // Calling user action here
        self.user_grammar.discrete(&discrete_built)?;
        self.push(ASTType::Discrete(discrete_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `encapsulated: 'encapsulated';`
    ///
    #[parol_runtime::function_name::named]
    fn encapsulated(&mut self, encapsulated: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let encapsulated = encapsulated
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let encapsulated_built = Encapsulated { encapsulated };
        // Calling user action here
        self.user_grammar.encapsulated(&encapsulated_built)?;
        self.push(ASTType::Encapsulated(encapsulated_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `end: 'end';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `equation: 'equation';`
    ///
    #[parol_runtime::function_name::named]
    fn equation(&mut self, equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation = equation
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let equation_built = Equation { equation };
        // Calling user action here
        self.user_grammar.equation(&equation_built)?;
        self.push(ASTType::Equation(equation_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `expandable: 'expandable';`
    ///
    #[parol_runtime::function_name::named]
    fn expandable(&mut self, expandable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expandable = expandable
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let expandable_built = Expandable { expandable };
        // Calling user action here
        self.user_grammar.expandable(&expandable_built)?;
        self.push(ASTType::Expandable(expandable_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `false: 'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `final: 'final';`
    ///
    #[parol_runtime::function_name::named]
    fn r#final(&mut self, r#final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = r#final
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#final_built = Final { r#final };
        // Calling user action here
        self.user_grammar.r#final(&r#final_built)?;
        self.push(ASTType::Final(r#final_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `flow: 'flow';`
    ///
    #[parol_runtime::function_name::named]
    fn flow(&mut self, flow: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let flow = flow
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let flow_built = Flow { flow };
        // Calling user action here
        self.user_grammar.flow(&flow_built)?;
        self.push(ASTType::Flow(flow_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `function: 'function';`
    ///
    #[parol_runtime::function_name::named]
    fn function(&mut self, function: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function = function
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let function_built = Function { function };
        // Calling user action here
        self.user_grammar.function(&function_built)?;
        self.push(ASTType::Function(function_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `import: 'import';`
    ///
    #[parol_runtime::function_name::named]
    fn import(&mut self, import: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import = import
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_built = Import { import };
        // Calling user action here
        self.user_grammar.import(&import_built)?;
        self.push(ASTType::Import(import_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `impure: 'impure';`
    ///
    #[parol_runtime::function_name::named]
    fn impure(&mut self, impure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let impure = impure
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let impure_built = Impure { impure };
        // Calling user action here
        self.user_grammar.impure(&impure_built)?;
        self.push(ASTType::Impure(impure_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `initial: 'initial';`
    ///
    #[parol_runtime::function_name::named]
    fn initial(&mut self, initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial = initial
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let initial_built = Initial { initial };
        // Calling user action here
        self.user_grammar.initial(&initial_built)?;
        self.push(ASTType::Initial(initial_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `inner: 'inner';`
    ///
    #[parol_runtime::function_name::named]
    fn inner(&mut self, inner: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inner = inner
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inner_built = Inner { inner };
        // Calling user action here
        self.user_grammar.inner(&inner_built)?;
        self.push(ASTType::Inner(inner_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `input: 'input';`
    ///
    #[parol_runtime::function_name::named]
    fn input(&mut self, input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = input
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let input_built = Input { input };
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `model: 'model';`
    ///
    #[parol_runtime::function_name::named]
    fn model(&mut self, model: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let model = model
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let model_built = Model { model };
        // Calling user action here
        self.user_grammar.model(&model_built)?;
        self.push(ASTType::Model(model_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `not: 'not';`
    ///
    #[parol_runtime::function_name::named]
    fn not(&mut self, not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = not
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let not_built = Not { not };
        // Calling user action here
        self.user_grammar.not(&not_built)?;
        self.push(ASTType::Not(not_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `operator: 'operator';`
    ///
    #[parol_runtime::function_name::named]
    fn operator(&mut self, operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = operator
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator_built = Operator { operator };
        // Calling user action here
        self.user_grammar.operator(&operator_built)?;
        self.push(ASTType::Operator(operator_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `or: 'or';`
    ///
    #[parol_runtime::function_name::named]
    fn or(&mut self, or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let or_built = Or { or };
        // Calling user action here
        self.user_grammar.or(&or_built)?;
        self.push(ASTType::Or(or_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `outer: 'outer';`
    ///
    #[parol_runtime::function_name::named]
    fn outer(&mut self, outer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outer = outer
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let outer_built = Outer { outer };
        // Calling user action here
        self.user_grammar.outer(&outer_built)?;
        self.push(ASTType::Outer(outer_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `output: 'output';`
    ///
    #[parol_runtime::function_name::named]
    fn output(&mut self, output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = output
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let output_built = Output { output };
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `package: 'package';`
    ///
    #[parol_runtime::function_name::named]
    fn package(&mut self, package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = package
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let package_built = Package { package };
        // Calling user action here
        self.user_grammar.package(&package_built)?;
        self.push(ASTType::Package(package_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `parameter: 'parameter';`
    ///
    #[parol_runtime::function_name::named]
    fn parameter(&mut self, parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = parameter
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let parameter_built = Parameter { parameter };
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `partial: 'partial';`
    ///
    #[parol_runtime::function_name::named]
    fn partial(&mut self, partial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let partial = partial
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let partial_built = Partial { partial };
        // Calling user action here
        self.user_grammar.partial(&partial_built)?;
        self.push(ASTType::Partial(partial_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `protected: 'protected';`
    ///
    #[parol_runtime::function_name::named]
    fn protected(&mut self, protected: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let protected = protected
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let protected_built = Protected { protected };
        // Calling user action here
        self.user_grammar.protected(&protected_built)?;
        self.push(ASTType::Protected(protected_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `public: 'public';`
    ///
    #[parol_runtime::function_name::named]
    fn public(&mut self, public: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let public = public
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let public_built = Public { public };
        // Calling user action here
        self.user_grammar.public(&public_built)?;
        self.push(ASTType::Public(public_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `pure: 'pure';`
    ///
    #[parol_runtime::function_name::named]
    fn pure(&mut self, pure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pure = pure
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let pure_built = Pure { pure };
        // Calling user action here
        self.user_grammar.pure(&pure_built)?;
        self.push(ASTType::Pure(pure_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `record: 'record';`
    ///
    #[parol_runtime::function_name::named]
    fn record(&mut self, record: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let record = record
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let record_built = Record { record };
        // Calling user action here
        self.user_grammar.record(&record_built)?;
        self.push(ASTType::Record(record_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `redeclare: 'redeclare';`
    ///
    #[parol_runtime::function_name::named]
    fn redeclare(&mut self, redeclare: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let redeclare = redeclare
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let redeclare_built = Redeclare { redeclare };
        // Calling user action here
        self.user_grammar.redeclare(&redeclare_built)?;
        self.push(ASTType::Redeclare(redeclare_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `stream: 'stream';`
    ///
    #[parol_runtime::function_name::named]
    fn stream(&mut self, stream: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stream = stream
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let stream_built = Stream { stream };
        // Calling user action here
        self.user_grammar.stream(&stream_built)?;
        self.push(ASTType::Stream(stream_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `true: 'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `type: 'type';`
    ///
    #[parol_runtime::function_name::named]
    fn r#type(&mut self, r#type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = r#type
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#type_built = Type { r#type };
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `within: 'within';`
    ///
    #[parol_runtime::function_name::named]
    fn within(&mut self, within: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let within = within
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let within_built = Within { within };
        // Calling user action here
        self.user_grammar.within(&within_built)?;
        self.push(ASTType::Within(within_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `ident: /[_a-zA-Z][_a-zA-Z0-9]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `string: /"[\w]*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn string(&mut self, string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_built = String { string };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `unsigned_integer: /[0-9]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_integer(&mut self, unsigned_integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_integer = unsigned_integer
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_integer_built = UnsignedInteger { unsigned_integer };
        // Calling user action here
        self.user_grammar
            .unsigned_integer(&unsigned_integer_built)?;
        self.push(ASTType::UnsignedInteger(unsigned_integer_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `unsigned_real: /[0-9]+\.[0-9]+/@decimal;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_0(&mut self, decimal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decimal = decimal
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_0_built = UnsignedRealDecimal { decimal };
        let unsigned_real_0_built = UnsignedReal::Decimal(unsigned_real_0_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_0_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_0_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `unsigned_real: /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_1(&mut self, scientific: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scientific = scientific
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_1_built = UnsignedRealScientific { scientific };
        let unsigned_real_1_built = UnsignedReal::Scientific(unsigned_real_1_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_1_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_1_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `unsigned_real: /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_2(&mut self, scientific2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scientific2 = scientific2
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_2_built = UnsignedRealScientific2 { scientific2 };
        let unsigned_real_2_built = UnsignedReal::Scientific2(unsigned_real_2_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_2_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_2_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `stored_definition: stored_definitionOpt /* Option */ stored_definitionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition(
        &mut self,
        _stored_definition_opt: &ParseTreeType<'t>,
        _stored_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_list =
            pop_and_reverse_item!(self, stored_definition_list, StoredDefinitionList, context);
        let stored_definition_opt =
            pop_item!(self, stored_definition_opt, StoredDefinitionOpt, context);
        let stored_definition_built = StoredDefinition {
            stored_definition_opt,
            stored_definition_list,
        };
        // Calling user action here
        self.user_grammar
            .stored_definition(&stored_definition_built)?;
        self.push(ASTType::StoredDefinition(stored_definition_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `stored_definitionList /* Vec<T>::Push */: stored_definitionOpt0 /* Option */ class_definition ';'^ /* Clipped */ stored_definitionList;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_list_0(
        &mut self,
        _stored_definition_opt0: &ParseTreeType<'t>,
        _class_definition: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _stored_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut stored_definition_list =
            pop_item!(self, stored_definition_list, StoredDefinitionList, context);
        let class_definition = pop_item!(self, class_definition, ClassDefinition, context);
        let stored_definition_opt0 =
            pop_item!(self, stored_definition_opt0, StoredDefinitionOpt0, context);
        let stored_definition_list_0_built = StoredDefinitionList {
            class_definition,
            stored_definition_opt0,
        };
        // Add an element to the vector
        stored_definition_list.push(stored_definition_list_0_built);
        self.push(
            ASTType::StoredDefinitionList(stored_definition_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `stored_definitionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_list_1_built = Vec::new();
        self.push(
            ASTType::StoredDefinitionList(stored_definition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `stored_definitionOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt0_0(&mut self, _final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let stored_definition_opt0_0_built = StoredDefinitionOpt0 { r#final };
        self.push(
            ASTType::StoredDefinitionOpt0(Some(stored_definition_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `stored_definitionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `stored_definitionOpt /* Option<T>::Some */: within^ /* Clipped */ stored_definitionOpt1 /* Option */ ';'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt_0(
        &mut self,
        _within: &ParseTreeType<'t>,
        _stored_definition_opt1: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_opt1 =
            pop_item!(self, stored_definition_opt1, StoredDefinitionOpt1, context);
        self.pop(context);
        let stored_definition_opt_0_built = StoredDefinitionOpt {
            stored_definition_opt1,
        };
        self.push(
            ASTType::StoredDefinitionOpt(Some(stored_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `stored_definitionOpt1 /* Option<T>::Some */: name;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt1_0(&mut self, _name: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let stored_definition_opt1_0_built = StoredDefinitionOpt1 {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::StoredDefinitionOpt1(Some(stored_definition_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `stored_definitionOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `stored_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `class_definition: class_definitionOpt /* Option */ class_prefixes class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition(
        &mut self,
        _class_definition_opt: &ParseTreeType<'t>,
        _class_prefixes: &ParseTreeType<'t>,
        _class_specifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_specifier = pop_item!(self, class_specifier, ClassSpecifier, context);
        let class_prefixes = pop_item!(self, class_prefixes, ClassPrefixes, context);
        let class_definition_opt =
            pop_item!(self, class_definition_opt, ClassDefinitionOpt, context);
        let class_definition_built = ClassDefinition {
            class_definition_opt,
            class_prefixes,
            class_specifier,
        };
        // Calling user action here
        self.user_grammar
            .class_definition(&class_definition_built)?;
        self.push(ASTType::ClassDefinition(class_definition_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `class_definitionOpt /* Option<T>::Some */: encapsulated;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition_opt_0(&mut self, _encapsulated: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let encapsulated = pop_item!(self, encapsulated, Encapsulated, context);
        let class_definition_opt_0_built = ClassDefinitionOpt { encapsulated };
        self.push(
            ASTType::ClassDefinitionOpt(Some(class_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `class_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `class_prefixes: class_prefixesOpt /* Option */ class_prefixesGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes(
        &mut self,
        _class_prefixes_opt: &ParseTreeType<'t>,
        _class_prefixes_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_prefixes_group =
            pop_item!(self, class_prefixes_group, ClassPrefixesGroup, context);
        let class_prefixes_opt = pop_item!(self, class_prefixes_opt, ClassPrefixesOpt, context);
        let class_prefixes_built = ClassPrefixes {
            class_prefixes_opt,
            class_prefixes_group,
        };
        // Calling user action here
        self.user_grammar.class_prefixes(&class_prefixes_built)?;
        self.push(ASTType::ClassPrefixes(class_prefixes_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `class_prefixesGroup: class;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_0(&mut self, _class: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class = pop_item!(self, class, Class, context);
        let class_prefixes_group_0_built = ClassPrefixesGroupClass { class };
        let class_prefixes_group_0_built = ClassPrefixesGroup::Class(class_prefixes_group_0_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `class_prefixesGroup: model;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_1(&mut self, _model: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let model = pop_item!(self, model, Model, context);
        let class_prefixes_group_1_built = ClassPrefixesGroupModel { model };
        let class_prefixes_group_1_built = ClassPrefixesGroup::Model(class_prefixes_group_1_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `class_prefixesGroup: class_prefixesOpt0 /* Option */ record;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_2(
        &mut self,
        _class_prefixes_opt0: &ParseTreeType<'t>,
        _record: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let record = pop_item!(self, record, Record, context);
        let class_prefixes_opt0 = pop_item!(self, class_prefixes_opt0, ClassPrefixesOpt0, context);
        let class_prefixes_group_2_built = ClassPrefixesGroupClassPrefixesOpt0Record {
            class_prefixes_opt0,
            record,
        };
        let class_prefixes_group_2_built =
            ClassPrefixesGroup::ClassPrefixesOpt0Record(class_prefixes_group_2_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `class_prefixesGroup: block;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_3(&mut self, _block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = pop_item!(self, block, Block, context);
        let class_prefixes_group_3_built = ClassPrefixesGroupBlock { block };
        let class_prefixes_group_3_built = ClassPrefixesGroup::Block(class_prefixes_group_3_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `class_prefixesGroup: class_prefixesOpt1 /* Option */ connector;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_4(
        &mut self,
        _class_prefixes_opt1: &ParseTreeType<'t>,
        _connector: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connector = pop_item!(self, connector, Connector, context);
        let class_prefixes_opt1 = pop_item!(self, class_prefixes_opt1, ClassPrefixesOpt1, context);
        let class_prefixes_group_4_built = ClassPrefixesGroupClassPrefixesOpt1Connector {
            class_prefixes_opt1,
            connector,
        };
        let class_prefixes_group_4_built =
            ClassPrefixesGroup::ClassPrefixesOpt1Connector(class_prefixes_group_4_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `class_prefixesGroup: type;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_5(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let class_prefixes_group_5_built = ClassPrefixesGroupType { r#type };
        let class_prefixes_group_5_built = ClassPrefixesGroup::Type(class_prefixes_group_5_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `class_prefixesGroup: package;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_6(&mut self, _package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = pop_item!(self, package, Package, context);
        let class_prefixes_group_6_built = ClassPrefixesGroupPackage { package };
        let class_prefixes_group_6_built =
            ClassPrefixesGroup::Package(class_prefixes_group_6_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `class_prefixesGroup: class_prefixesOpt2 /* Option */ class_prefixesOpt3 /* Option */ function;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_7(
        &mut self,
        _class_prefixes_opt2: &ParseTreeType<'t>,
        _class_prefixes_opt3: &ParseTreeType<'t>,
        _function: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function = pop_item!(self, function, Function, context);
        let class_prefixes_opt3 = pop_item!(self, class_prefixes_opt3, ClassPrefixesOpt3, context);
        let class_prefixes_opt2 = pop_item!(self, class_prefixes_opt2, ClassPrefixesOpt2, context);
        let class_prefixes_group_7_built =
            ClassPrefixesGroupClassPrefixesOpt2ClassPrefixesOpt3Function {
                class_prefixes_opt2,
                class_prefixes_opt3,
                function,
            };
        let class_prefixes_group_7_built =
            ClassPrefixesGroup::ClassPrefixesOpt2ClassPrefixesOpt3Function(
                class_prefixes_group_7_built,
            );
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_7_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `class_prefixesGroup: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_group_8(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_prefixes_group_8_built = ClassPrefixesGroupOperator { operator };
        let class_prefixes_group_8_built =
            ClassPrefixesGroup::Operator(class_prefixes_group_8_built);
        self.push(
            ASTType::ClassPrefixesGroup(class_prefixes_group_8_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `class_prefixesOpt3 /* Option<T>::Some */: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt3_0(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_prefixes_opt3_0_built = ClassPrefixesOpt3 { operator };
        self.push(
            ASTType::ClassPrefixesOpt3(Some(class_prefixes_opt3_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `class_prefixesOpt3 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt3_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt3(None), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `class_prefixesOpt2 /* Option<T>::Some */: class_prefixesOpt2Group;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt2_0(
        &mut self,
        _class_prefixes_opt2_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_prefixes_opt2_group = pop_item!(
            self,
            class_prefixes_opt2_group,
            ClassPrefixesOpt2Group,
            context
        );
        let class_prefixes_opt2_0_built = ClassPrefixesOpt2 {
            class_prefixes_opt2_group,
        };
        self.push(
            ASTType::ClassPrefixesOpt2(Some(class_prefixes_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `class_prefixesOpt2Group: pure;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt2_group_0(&mut self, _pure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pure = pop_item!(self, pure, Pure, context);
        let class_prefixes_opt2_group_0_built = ClassPrefixesOpt2GroupPure { pure };
        let class_prefixes_opt2_group_0_built =
            ClassPrefixesOpt2Group::Pure(class_prefixes_opt2_group_0_built);
        self.push(
            ASTType::ClassPrefixesOpt2Group(class_prefixes_opt2_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `class_prefixesOpt2Group: impure;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt2_group_1(&mut self, _impure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let impure = pop_item!(self, impure, Impure, context);
        let class_prefixes_opt2_group_1_built = ClassPrefixesOpt2GroupImpure { impure };
        let class_prefixes_opt2_group_1_built =
            ClassPrefixesOpt2Group::Impure(class_prefixes_opt2_group_1_built);
        self.push(
            ASTType::ClassPrefixesOpt2Group(class_prefixes_opt2_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `class_prefixesOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `class_prefixesOpt1 /* Option<T>::Some */: expandable;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt1_0(&mut self, _expandable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expandable = pop_item!(self, expandable, Expandable, context);
        let class_prefixes_opt1_0_built = ClassPrefixesOpt1 { expandable };
        self.push(
            ASTType::ClassPrefixesOpt1(Some(class_prefixes_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `class_prefixesOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `class_prefixesOpt0 /* Option<T>::Some */: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt0_0(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_prefixes_opt0_0_built = ClassPrefixesOpt0 { operator };
        self.push(
            ASTType::ClassPrefixesOpt0(Some(class_prefixes_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `class_prefixesOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `class_prefixesOpt /* Option<T>::Some */: partial;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt_0(&mut self, _partial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let partial = pop_item!(self, partial, Partial, context);
        let class_prefixes_opt_0_built = ClassPrefixesOpt { partial };
        self.push(
            ASTType::ClassPrefixesOpt(Some(class_prefixes_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `class_prefixesOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `class_specifier: long_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_specifier(&mut self, _long_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let long_class_specifier =
            pop_item!(self, long_class_specifier, LongClassSpecifier, context);
        let class_specifier_built = ClassSpecifier {
            long_class_specifier,
        };
        // Calling user action here
        self.user_grammar.class_specifier(&class_specifier_built)?;
        self.push(ASTType::ClassSpecifier(class_specifier_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `long_class_specifier: ident@name : %t_type composition end^ /* Clipped */ ident : %t_type;`
    ///
    #[parol_runtime::function_name::named]
    fn long_class_specifier(
        &mut self,
        _name: &ParseTreeType<'t>,
        _composition: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        self.pop(context);
        let composition = pop_item!(self, composition, Composition, context);
        let name = pop_item!(self, name, Ident, context);
        let long_class_specifier_built = LongClassSpecifier {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            composition: (&composition)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .long_class_specifier(&long_class_specifier_built)?;
        self.push(
            ASTType::LongClassSpecifier(long_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `composition: element_list compositionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn composition(
        &mut self,
        _element_list: &ParseTreeType<'t>,
        _composition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let composition_list =
            pop_and_reverse_item!(self, composition_list, CompositionList, context);
        let element_list = pop_item!(self, element_list, ElementList, context);
        let composition_built = Composition {
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            composition_list,
        };
        // Calling user action here
        self.user_grammar.composition(&composition_built)?;
        self.push(ASTType::Composition(composition_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `compositionList /* Vec<T>::Push */: compositionListGroup compositionList;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_0(
        &mut self,
        _composition_list_group: &ParseTreeType<'t>,
        _composition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut composition_list = pop_item!(self, composition_list, CompositionList, context);
        let composition_list_group =
            pop_item!(self, composition_list_group, CompositionListGroup, context);
        let composition_list_0_built = CompositionList {
            composition_list_group,
        };
        // Add an element to the vector
        composition_list.push(composition_list_0_built);
        self.push(ASTType::CompositionList(composition_list), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `compositionListGroup: public element_list;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_0(
        &mut self,
        _public: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list = pop_item!(self, element_list, ElementList, context);
        let public = pop_item!(self, public, Public, context);
        let composition_list_group_0_built = CompositionListGroupPublicElementList {
            public,
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_0_built =
            CompositionListGroup::PublicElementList(composition_list_group_0_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `compositionListGroup: protected element_list;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_1(
        &mut self,
        _protected: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list = pop_item!(self, element_list, ElementList, context);
        let protected = pop_item!(self, protected, Protected, context);
        let composition_list_group_1_built = CompositionListGroupProtectedElementList {
            protected,
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_1_built =
            CompositionListGroup::ProtectedElementList(composition_list_group_1_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `compositionListGroup: equation_section;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_2(&mut self, _equation_section: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section = pop_item!(self, equation_section, EquationSection, context);
        let composition_list_group_2_built = CompositionListGroupEquationSection {
            equation_section: (&equation_section)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_2_built =
            CompositionListGroup::EquationSection(composition_list_group_2_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `compositionListGroup: algorithm_section;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_3(&mut self, _algorithm_section: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section = pop_item!(self, algorithm_section, AlgorithmSection, context);
        let composition_list_group_3_built = CompositionListGroupAlgorithmSection {
            algorithm_section: (&algorithm_section)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_3_built =
            CompositionListGroup::AlgorithmSection(composition_list_group_3_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `compositionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let composition_list_1_built = Vec::new();
        self.push(ASTType::CompositionList(composition_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `element_list: element_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list(&mut self, _element_list_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list_list =
            pop_and_reverse_item!(self, element_list_list, ElementListList, context);
        let element_list_built = ElementList { element_list_list };
        // Calling user action here
        self.user_grammar.element_list(&element_list_built)?;
        self.push(ASTType::ElementList(element_list_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `element_listList /* Vec<T>::Push */: element ';' element_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list_list_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        semicolon: &ParseTreeType<'t>,
        _element_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mut element_list_list = pop_item!(self, element_list_list, ElementListList, context);
        let element = pop_item!(self, element, Element, context);
        let element_list_list_0_built = ElementListList { semicolon, element };
        // Add an element to the vector
        element_list_list.push(element_list_list_0_built);
        self.push(ASTType::ElementListList(element_list_list), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `element_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list_list_1_built = Vec::new();
        self.push(ASTType::ElementListList(element_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `element: import_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_0(&mut self, _import_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause = pop_item!(self, import_clause, ImportClause, context);
        let element_0_built = ElementImportClause { import_clause };
        let element_0_built = Element::ImportClause(element_0_built);
        // Calling user action here
        self.user_grammar.element(&element_0_built)?;
        self.push(ASTType::Element(element_0_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `element: elementOpt /* Option */ elementOpt0 /* Option */ elementOpt1 /* Option */ elementOpt2 /* Option */ elementGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn element_1(
        &mut self,
        _element_opt: &ParseTreeType<'t>,
        _element_opt0: &ParseTreeType<'t>,
        _element_opt1: &ParseTreeType<'t>,
        _element_opt2: &ParseTreeType<'t>,
        _element_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_group = pop_item!(self, element_group, ElementGroup, context);
        let element_opt2 = pop_item!(self, element_opt2, ElementOpt2, context);
        let element_opt1 = pop_item!(self, element_opt1, ElementOpt1, context);
        let element_opt0 = pop_item!(self, element_opt0, ElementOpt0, context);
        let element_opt = pop_item!(self, element_opt, ElementOpt, context);
        let element_1_built = ElementElementOptElementOpt0ElementOpt1ElementOpt2ElementGroup {
            element_opt,
            element_opt0,
            element_opt1,
            element_opt2,
            element_group,
        };
        let element_1_built =
            Element::ElementOptElementOpt0ElementOpt1ElementOpt2ElementGroup(element_1_built);
        // Calling user action here
        self.user_grammar.element(&element_1_built)?;
        self.push(ASTType::Element(element_1_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `elementGroup: class_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_group_0(&mut self, _class_definition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_definition = pop_item!(self, class_definition, ClassDefinition, context);
        let element_group_0_built = ElementGroupClassDefinition { class_definition };
        let element_group_0_built = ElementGroup::ClassDefinition(element_group_0_built);
        self.push(ASTType::ElementGroup(element_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `elementGroup: component_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_group_1(&mut self, _component_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_clause = pop_item!(self, component_clause, ComponentClause, context);
        let element_group_1_built = ElementGroupComponentClause { component_clause };
        let element_group_1_built = ElementGroup::ComponentClause(element_group_1_built);
        self.push(ASTType::ElementGroup(element_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `elementOpt2 /* Option<T>::Some */: outer;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt2_0(&mut self, _outer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outer = pop_item!(self, outer, Outer, context);
        let element_opt2_0_built = ElementOpt2 { outer };
        self.push(ASTType::ElementOpt2(Some(element_opt2_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `elementOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `elementOpt1 /* Option<T>::Some */: inner;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt1_0(&mut self, _inner: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inner = pop_item!(self, inner, Inner, context);
        let element_opt1_0_built = ElementOpt1 { inner };
        self.push(ASTType::ElementOpt1(Some(element_opt1_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `elementOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `elementOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt0_0(&mut self, _final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let element_opt0_0_built = ElementOpt0 { r#final };
        self.push(ASTType::ElementOpt0(Some(element_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `elementOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `elementOpt /* Option<T>::Some */: redeclare;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt_0(&mut self, _redeclare: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let redeclare = pop_item!(self, redeclare, Redeclare, context);
        let element_opt_0_built = ElementOpt { redeclare };
        self.push(ASTType::ElementOpt(Some(element_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `elementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `import_clause: import import_clauseGroup description;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause(
        &mut self,
        _import: &ParseTreeType<'t>,
        _import_clause_group: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let import_clause_group = pop_item!(self, import_clause_group, ImportClauseGroup, context);
        let import = pop_item!(self, import, Import, context);
        let import_clause_built = ImportClause {
            import,
            import_clause_group,
            description,
        };
        // Calling user action here
        self.user_grammar.import_clause(&import_clause_built)?;
        self.push(ASTType::ImportClause(import_clause_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `import_clauseGroup: ident : %t_type '='^ /* Clipped */ name;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_group_0(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_clause_group_0_built = ImportClauseGroupIdentEquName {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let import_clause_group_0_built =
            ImportClauseGroup::IdentEquName(import_clause_group_0_built);
        self.push(
            ASTType::ImportClauseGroup(import_clause_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `import_clauseGroup: name import_clauseOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_group_1(
        &mut self,
        _name: &ParseTreeType<'t>,
        _import_clause_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause_opt = pop_item!(self, import_clause_opt, ImportClauseOpt, context);
        let name = pop_item!(self, name, Name, context);
        let import_clause_group_1_built = ImportClauseGroupNameImportClauseOpt {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            import_clause_opt,
        };
        let import_clause_group_1_built =
            ImportClauseGroup::NameImportClauseOpt(import_clause_group_1_built);
        self.push(
            ASTType::ImportClauseGroup(import_clause_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `import_clauseOpt /* Option<T>::Some */: import_clauseOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_0(&mut self, _import_clause_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause_opt_group =
            pop_item!(self, import_clause_opt_group, ImportClauseOptGroup, context);
        let import_clause_opt_0_built = ImportClauseOpt {
            import_clause_opt_group,
        };
        self.push(
            ASTType::ImportClauseOpt(Some(import_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `import_clauseOptGroup: '.*';`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_0(&mut self, dot_star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_star = dot_star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_clause_opt_group_0_built = ImportClauseOptGroupDotStar { dot_star };
        let import_clause_opt_group_0_built =
            ImportClauseOptGroup::DotStar(import_clause_opt_group_0_built);
        self.push(
            ASTType::ImportClauseOptGroup(import_clause_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `import_clauseOptGroup: '.'^ /* Clipped */ import_clauseOptGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_1(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _import_clause_opt_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause_opt_group_group = pop_item!(
            self,
            import_clause_opt_group_group,
            ImportClauseOptGroupGroup,
            context
        );
        let import_clause_opt_group_1_built = ImportClauseOptGroupDotImportClauseOptGroupGroup {
            import_clause_opt_group_group,
        };
        let import_clause_opt_group_1_built =
            ImportClauseOptGroup::DotImportClauseOptGroupGroup(import_clause_opt_group_1_built);
        self.push(
            ASTType::ImportClauseOptGroup(import_clause_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `import_clauseOptGroupGroup: '*';`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_group_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_clause_opt_group_group_0_built = ImportClauseOptGroupGroupStar { star };
        let import_clause_opt_group_group_0_built =
            ImportClauseOptGroupGroup::Star(import_clause_opt_group_group_0_built);
        self.push(
            ASTType::ImportClauseOptGroupGroup(import_clause_opt_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `import_clauseOptGroupGroup: '{' import_list '}';`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_group_1(
        &mut self,
        l_brace: &ParseTreeType<'t>,
        _import_list: &ParseTreeType<'t>,
        r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_brace = r_brace
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_list = pop_item!(self, import_list, ImportList, context);
        let import_clause_opt_group_group_1_built =
            ImportClauseOptGroupGroupLBraceImportListRBrace {
                l_brace,
                import_list,
                r_brace,
            };
        let import_clause_opt_group_group_1_built =
            ImportClauseOptGroupGroup::LBraceImportListRBrace(
                import_clause_opt_group_group_1_built,
            );
        self.push(
            ASTType::ImportClauseOptGroupGroup(import_clause_opt_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `import_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `import_list: ident : %t_type import_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list =
            pop_and_reverse_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_built = ImportList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            import_list_list,
        };
        // Calling user action here
        self.user_grammar.import_list(&import_list_built)?;
        self.push(ASTType::ImportList(import_list_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `import_listList /* Vec<T>::Push */: ','^ /* Clipped */ ident : %t_type import_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut import_list_list = pop_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_list_0_built = ImportListList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        import_list_list.push(import_list_list_0_built);
        self.push(ASTType::ImportListList(import_list_list), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `import_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list_1_built = Vec::new();
        self.push(ASTType::ImportListList(import_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `component_clause: type_prefix type_specifier component_clauseOpt /* Option */ component_list;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause(
        &mut self,
        _type_prefix: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _component_clause_opt: &ParseTreeType<'t>,
        _component_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list = pop_item!(self, component_list, ComponentList, context);
        let component_clause_opt =
            pop_item!(self, component_clause_opt, ComponentClauseOpt, context);
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let type_prefix = pop_item!(self, type_prefix, TypePrefix, context);
        let component_clause_built = ComponentClause {
            type_prefix,
            type_specifier,
            component_clause_opt,
            component_list: (&component_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .component_clause(&component_clause_built)?;
        self.push(ASTType::ComponentClause(component_clause_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `component_clauseOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let component_clause_opt_0_built = ComponentClauseOpt { array_subscripts };
        self.push(
            ASTType::ComponentClauseOpt(Some(component_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `component_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `type_prefix: type_prefixOpt /* Option */ type_prefixOpt0 /* Option */ type_prefixOpt1 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix(
        &mut self,
        _type_prefix_opt: &ParseTreeType<'t>,
        _type_prefix_opt0: &ParseTreeType<'t>,
        _type_prefix_opt1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt1 = pop_item!(self, type_prefix_opt1, TypePrefixOpt1, context);
        let type_prefix_opt0 = pop_item!(self, type_prefix_opt0, TypePrefixOpt0, context);
        let type_prefix_opt = pop_item!(self, type_prefix_opt, TypePrefixOpt, context);
        let type_prefix_built = TypePrefix {
            type_prefix_opt,
            type_prefix_opt0,
            type_prefix_opt1,
        };
        // Calling user action here
        self.user_grammar.type_prefix(&type_prefix_built)?;
        self.push(ASTType::TypePrefix(type_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `type_prefixOpt1 /* Option<T>::Some */: type_prefixOpt1Group;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_0(&mut self, _type_prefix_opt1_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt1_group =
            pop_item!(self, type_prefix_opt1_group, TypePrefixOpt1Group, context);
        let type_prefix_opt1_0_built = TypePrefixOpt1 {
            type_prefix_opt1_group,
        };
        self.push(
            ASTType::TypePrefixOpt1(Some(type_prefix_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `type_prefixOpt1Group: input;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_group_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let type_prefix_opt1_group_0_built = TypePrefixOpt1GroupInput { input };
        let type_prefix_opt1_group_0_built =
            TypePrefixOpt1Group::Input(type_prefix_opt1_group_0_built);
        self.push(
            ASTType::TypePrefixOpt1Group(type_prefix_opt1_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `type_prefixOpt1Group: output;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_group_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let type_prefix_opt1_group_1_built = TypePrefixOpt1GroupOutput { output };
        let type_prefix_opt1_group_1_built =
            TypePrefixOpt1Group::Output(type_prefix_opt1_group_1_built);
        self.push(
            ASTType::TypePrefixOpt1Group(type_prefix_opt1_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `type_prefixOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `type_prefixOpt0 /* Option<T>::Some */: type_prefixOpt0Group;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_0(&mut self, _type_prefix_opt0_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt0_group =
            pop_item!(self, type_prefix_opt0_group, TypePrefixOpt0Group, context);
        let type_prefix_opt0_0_built = TypePrefixOpt0 {
            type_prefix_opt0_group,
        };
        self.push(
            ASTType::TypePrefixOpt0(Some(type_prefix_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `type_prefixOpt0Group: discrete;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_0(&mut self, _discrete: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let discrete = pop_item!(self, discrete, Discrete, context);
        let type_prefix_opt0_group_0_built = TypePrefixOpt0GroupDiscrete { discrete };
        let type_prefix_opt0_group_0_built =
            TypePrefixOpt0Group::Discrete(type_prefix_opt0_group_0_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `type_prefixOpt0Group: parameter;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_1(&mut self, _parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let type_prefix_opt0_group_1_built = TypePrefixOpt0GroupParameter { parameter };
        let type_prefix_opt0_group_1_built =
            TypePrefixOpt0Group::Parameter(type_prefix_opt0_group_1_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `type_prefixOpt0Group: constant;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_2(&mut self, _constant: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constant = pop_item!(self, constant, Constant, context);
        let type_prefix_opt0_group_2_built = TypePrefixOpt0GroupConstant { constant };
        let type_prefix_opt0_group_2_built =
            TypePrefixOpt0Group::Constant(type_prefix_opt0_group_2_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `type_prefixOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `type_prefixOpt /* Option<T>::Some */: type_prefixOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_0(&mut self, _type_prefix_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt_group =
            pop_item!(self, type_prefix_opt_group, TypePrefixOptGroup, context);
        let type_prefix_opt_0_built = TypePrefixOpt {
            type_prefix_opt_group,
        };
        self.push(
            ASTType::TypePrefixOpt(Some(type_prefix_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `type_prefixOptGroup: flow;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_group_0(&mut self, _flow: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let flow = pop_item!(self, flow, Flow, context);
        let type_prefix_opt_group_0_built = TypePrefixOptGroupFlow { flow };
        let type_prefix_opt_group_0_built = TypePrefixOptGroup::Flow(type_prefix_opt_group_0_built);
        self.push(
            ASTType::TypePrefixOptGroup(type_prefix_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `type_prefixOptGroup: stream;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_group_1(&mut self, _stream: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stream = pop_item!(self, stream, Stream, context);
        let type_prefix_opt_group_1_built = TypePrefixOptGroupStream { stream };
        let type_prefix_opt_group_1_built =
            TypePrefixOptGroup::Stream(type_prefix_opt_group_1_built);
        self.push(
            ASTType::TypePrefixOptGroup(type_prefix_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `type_prefixOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `component_list: component_declaration component_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list(
        &mut self,
        _component_declaration: &ParseTreeType<'t>,
        _component_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list_list =
            pop_and_reverse_item!(self, component_list_list, ComponentListList, context);
        let component_declaration =
            pop_item!(self, component_declaration, ComponentDeclaration, context);
        let component_list_built = ComponentList {
            component_declaration,
            component_list_list,
        };
        // Calling user action here
        self.user_grammar.component_list(&component_list_built)?;
        self.push(ASTType::ComponentList(component_list_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `component_listList /* Vec<T>::Push */: ','^ /* Clipped */ component_declaration component_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _component_declaration: &ParseTreeType<'t>,
        _component_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut component_list_list =
            pop_item!(self, component_list_list, ComponentListList, context);
        let component_declaration =
            pop_item!(self, component_declaration, ComponentDeclaration, context);
        let component_list_list_0_built = ComponentListList {
            component_declaration,
        };
        // Add an element to the vector
        component_list_list.push(component_list_list_0_built);
        self.push(ASTType::ComponentListList(component_list_list), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `component_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list_list_1_built = Vec::new();
        self.push(
            ASTType::ComponentListList(component_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `component_declaration: declaration description;`
    ///
    #[parol_runtime::function_name::named]
    fn component_declaration(
        &mut self,
        _declaration: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let declaration = pop_item!(self, declaration, Declaration, context);
        let component_declaration_built = ComponentDeclaration {
            declaration,
            description,
        };
        // Calling user action here
        self.user_grammar
            .component_declaration(&component_declaration_built)?;
        self.push(
            ASTType::ComponentDeclaration(component_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `declaration: ident : %t_type declarationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _declaration_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let declaration_opt = pop_item!(self, declaration_opt, DeclarationOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let declaration_built = Declaration {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            declaration_opt,
        };
        // Calling user action here
        self.user_grammar.declaration(&declaration_built)?;
        self.push(ASTType::Declaration(declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `declarationOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let declaration_opt_0_built = DeclarationOpt { array_subscripts };
        self.push(
            ASTType::DeclarationOpt(Some(declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `declarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `equation_section: equation_sectionOpt /* Option */ equation^ /* Clipped */ equation_sectionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section(
        &mut self,
        _equation_section_opt: &ParseTreeType<'t>,
        _equation: &ParseTreeType<'t>,
        _equation_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section_list =
            pop_and_reverse_item!(self, equation_section_list, EquationSectionList, context);
        self.pop(context);
        let equation_section_opt =
            pop_item!(self, equation_section_opt, EquationSectionOpt, context);
        let equation_section_built = EquationSection {
            equation_section_opt,
            equation_section_list,
        };
        // Calling user action here
        self.user_grammar
            .equation_section(&equation_section_built)?;
        self.push(ASTType::EquationSection(equation_section_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `equation_sectionList /* Vec<T>::Push */: some_equation ';'^ /* Clipped */ equation_sectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_list_0(
        &mut self,
        _some_equation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _equation_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut equation_section_list =
            pop_item!(self, equation_section_list, EquationSectionList, context);
        let some_equation = pop_item!(self, some_equation, SomeEquation, context);
        let equation_section_list_0_built = EquationSectionList {
            some_equation: (&some_equation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        equation_section_list.push(equation_section_list_0_built);
        self.push(ASTType::EquationSectionList(equation_section_list), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `equation_sectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section_list_1_built = Vec::new();
        self.push(
            ASTType::EquationSectionList(equation_section_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `equation_sectionOpt /* Option<T>::Some */: initial^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_opt_0(&mut self, _initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let equation_section_opt_0_built = EquationSectionOpt {};
        self.push(
            ASTType::EquationSectionOpt(Some(equation_section_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `equation_sectionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EquationSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `algorithm_section: algorithm_sectionOpt /* Option */ algorithm^ /* Clipped */ algorithm_sectionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section(
        &mut self,
        _algorithm_section_opt: &ParseTreeType<'t>,
        _algorithm: &ParseTreeType<'t>,
        _algorithm_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section_list =
            pop_and_reverse_item!(self, algorithm_section_list, AlgorithmSectionList, context);
        self.pop(context);
        let algorithm_section_opt =
            pop_item!(self, algorithm_section_opt, AlgorithmSectionOpt, context);
        let algorithm_section_built = AlgorithmSection {
            algorithm_section_opt,
            algorithm_section_list,
        };
        // Calling user action here
        self.user_grammar
            .algorithm_section(&algorithm_section_built)?;
        self.push(ASTType::AlgorithmSection(algorithm_section_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `algorithm_sectionList /* Vec<T>::Push */: statement ';'^ /* Clipped */ algorithm_sectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _algorithm_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut algorithm_section_list =
            pop_item!(self, algorithm_section_list, AlgorithmSectionList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let algorithm_section_list_0_built = AlgorithmSectionList {
            statement: (&statement)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        algorithm_section_list.push(algorithm_section_list_0_built);
        self.push(
            ASTType::AlgorithmSectionList(algorithm_section_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `algorithm_sectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section_list_1_built = Vec::new();
        self.push(
            ASTType::AlgorithmSectionList(algorithm_section_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `algorithm_sectionOpt /* Option<T>::Some */: initial^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_opt_0(&mut self, _initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let algorithm_section_opt_0_built = AlgorithmSectionOpt {};
        self.push(
            ASTType::AlgorithmSectionOpt(Some(algorithm_section_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `algorithm_sectionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlgorithmSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `some_equation: simple_expression : term '='^ /* Clipped */ expression : term description;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation(
        &mut self,
        _simple_expression: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let expression = pop_item!(self, expression, Expression, context);
        let simple_expression = pop_item!(self, simple_expression, SimpleExpression, context);
        let some_equation_built = SomeEquation {
            simple_expression: (&simple_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description,
        };
        // Calling user action here
        self.user_grammar.some_equation(&some_equation_built)?;
        self.push(ASTType::SomeEquation(some_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `statement: component_reference ":="^ /* Clipped */ expression : term description;`
    ///
    #[parol_runtime::function_name::named]
    fn statement(
        &mut self,
        _component_reference: &ParseTreeType<'t>,
        _colon_equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let expression = pop_item!(self, expression, Expression, context);
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let statement_built = Statement {
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description,
        };
        // Calling user action here
        self.user_grammar.statement(&statement_built)?;
        self.push(ASTType::Statement(statement_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `expression: simple_expression : term;`
    ///
    #[parol_runtime::function_name::named]
    fn expression(&mut self, _simple_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression = pop_item!(self, simple_expression, SimpleExpression, context);
        let expression_built = Expression {
            simple_expression: (&simple_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `simple_expression: logical_expression : term simple_expressionOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression(
        &mut self,
        _logical_expression: &ParseTreeType<'t>,
        _simple_expression_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression_opt =
            pop_item!(self, simple_expression_opt, SimpleExpressionOpt, context);
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_built = SimpleExpression {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            simple_expression_opt,
        };
        // Calling user action here
        self.user_grammar
            .simple_expression(&simple_expression_built)?;
        self.push(ASTType::SimpleExpression(simple_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `simple_expressionOpt /* Option<T>::Some */: ':'^ /* Clipped */ logical_expression : term simple_expressionOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _logical_expression: &ParseTreeType<'t>,
        _simple_expression_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression_opt0 =
            pop_item!(self, simple_expression_opt0, SimpleExpressionOpt0, context);
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_opt_0_built = SimpleExpressionOpt {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            simple_expression_opt0,
        };
        self.push(
            ASTType::SimpleExpressionOpt(Some(simple_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `simple_expressionOpt0 /* Option<T>::Some */: ':'^ /* Clipped */ logical_expression : term;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt0_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _logical_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_opt0_0_built = SimpleExpressionOpt0 {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::SimpleExpressionOpt0(Some(simple_expression_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `simple_expressionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExpressionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `simple_expressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `logical_expression: logical_term : term logical_expressionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression(
        &mut self,
        _logical_term: &ParseTreeType<'t>,
        _logical_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression_list = pop_and_reverse_item!(
            self,
            logical_expression_list,
            LogicalExpressionList,
            context
        );
        let logical_term = pop_item!(self, logical_term, LogicalTerm, context);
        let logical_expression_built = LogicalExpression {
            logical_term: (&logical_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            logical_expression_list,
        };
        // Calling user action here
        self.user_grammar
            .logical_expression(&logical_expression_built)?;
        self.push(
            ASTType::LogicalExpression(logical_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// `logical_expressionList /* Vec<T>::Push */: or^ /* Clipped */ logical_term : term logical_expressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression_list_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _logical_term: &ParseTreeType<'t>,
        _logical_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_expression_list = pop_item!(
            self,
            logical_expression_list,
            LogicalExpressionList,
            context
        );
        let logical_term = pop_item!(self, logical_term, LogicalTerm, context);
        self.pop(context);
        let logical_expression_list_0_built = LogicalExpressionList {
            logical_term: (&logical_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        logical_expression_list.push(logical_expression_list_0_built);
        self.push(
            ASTType::LogicalExpressionList(logical_expression_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// `logical_expressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression_list_1_built = Vec::new();
        self.push(
            ASTType::LogicalExpressionList(logical_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// `logical_term: logical_factor : term logical_termList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term(
        &mut self,
        _logical_factor: &ParseTreeType<'t>,
        _logical_term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_term_list =
            pop_and_reverse_item!(self, logical_term_list, LogicalTermList, context);
        let logical_factor = pop_item!(self, logical_factor, LogicalFactor, context);
        let logical_term_built = LogicalTerm {
            logical_factor: (&logical_factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            logical_term_list,
        };
        // Calling user action here
        self.user_grammar.logical_term(&logical_term_built)?;
        self.push(ASTType::LogicalTerm(logical_term_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// `logical_termList /* Vec<T>::Push */: and^ /* Clipped */ logical_factor : term logical_termList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term_list_0(
        &mut self,
        _and: &ParseTreeType<'t>,
        _logical_factor: &ParseTreeType<'t>,
        _logical_term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_term_list = pop_item!(self, logical_term_list, LogicalTermList, context);
        let logical_factor = pop_item!(self, logical_factor, LogicalFactor, context);
        self.pop(context);
        let logical_term_list_0_built = LogicalTermList {
            logical_factor: (&logical_factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        logical_term_list.push(logical_term_list_0_built);
        self.push(ASTType::LogicalTermList(logical_term_list), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// `logical_termList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_term_list_1_built = Vec::new();
        self.push(ASTType::LogicalTermList(logical_term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// `logical_factor: logical_factorOpt /* Option */ relation : term;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor(
        &mut self,
        _logical_factor_opt: &ParseTreeType<'t>,
        _relation: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation = pop_item!(self, relation, Relation, context);
        let logical_factor_opt = pop_item!(self, logical_factor_opt, LogicalFactorOpt, context);
        let logical_factor_built = LogicalFactor {
            logical_factor_opt,
            relation: (&relation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.logical_factor(&logical_factor_built)?;
        self.push(ASTType::LogicalFactor(logical_factor_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// `logical_factorOpt /* Option<T>::Some */: not;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor_opt_0(&mut self, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let logical_factor_opt_0_built = LogicalFactorOpt { not };
        self.push(
            ASTType::LogicalFactorOpt(Some(logical_factor_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// `logical_factorOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LogicalFactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// `relation: arithmetic_expression : term relationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn relation(
        &mut self,
        _arithmetic_expression: &ParseTreeType<'t>,
        _relation_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation_opt = pop_item!(self, relation_opt, RelationOpt, context);
        let arithmetic_expression =
            pop_item!(self, arithmetic_expression, ArithmeticExpression, context);
        let relation_built = Relation {
            arithmetic_expression: (&arithmetic_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            relation_opt,
        };
        // Calling user action here
        self.user_grammar.relation(&relation_built)?;
        self.push(ASTType::Relation(relation_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// `relationOpt /* Option<T>::Some */: relational_operator arithmetic_expression : term;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_0(
        &mut self,
        _relational_operator: &ParseTreeType<'t>,
        _arithmetic_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression =
            pop_item!(self, arithmetic_expression, ArithmeticExpression, context);
        let relational_operator = pop_item!(self, relational_operator, RelationalOperator, context);
        let relation_opt_0_built = RelationOpt {
            relational_operator,
            arithmetic_expression: (&arithmetic_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(ASTType::RelationOpt(Some(relation_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// `relationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RelationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// `relational_operator: '<';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_0(&mut self, l_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_0_built = RelationalOperatorLT { l_t };
        let relational_operator_0_built = RelationalOperator::LT(relational_operator_0_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_0_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// `relational_operator: '<=';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_1(&mut self, l_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = l_t_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_1_built = RelationalOperatorLTEqu { l_t_equ };
        let relational_operator_1_built = RelationalOperator::LTEqu(relational_operator_1_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_1_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// `relational_operator: '>';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_2(&mut self, g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_2_built = RelationalOperatorGT { g_t };
        let relational_operator_2_built = RelationalOperator::GT(relational_operator_2_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_2_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// `relational_operator: '>=';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_3(&mut self, g_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = g_t_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_3_built = RelationalOperatorGTEqu { g_t_equ };
        let relational_operator_3_built = RelationalOperator::GTEqu(relational_operator_3_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_3_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// `relational_operator: '==';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_4(&mut self, equ_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ = equ_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_4_built = RelationalOperatorEquEqu { equ_equ };
        let relational_operator_4_built = RelationalOperator::EquEqu(relational_operator_4_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_4_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// `relational_operator: '<>';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_5(&mut self, l_t_g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_g_t = l_t_g_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_5_built = RelationalOperatorLTGT { l_t_g_t };
        let relational_operator_5_built = RelationalOperator::LTGT(relational_operator_5_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_5_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// `arithmetic_expression: arithmetic_expressionOpt /* Option */ term arithmetic_expressionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression(
        &mut self,
        _arithmetic_expression_opt: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _arithmetic_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression_list = pop_and_reverse_item!(
            self,
            arithmetic_expression_list,
            ArithmeticExpressionList,
            context
        );
        let term = pop_item!(self, term, Term, context);
        let arithmetic_expression_opt = pop_item!(
            self,
            arithmetic_expression_opt,
            ArithmeticExpressionOpt,
            context
        );
        let arithmetic_expression_built = ArithmeticExpression {
            arithmetic_expression_opt,
            term: (&term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            arithmetic_expression_list,
        };
        // Calling user action here
        self.user_grammar
            .arithmetic_expression(&arithmetic_expression_built)?;
        self.push(
            ASTType::ArithmeticExpression(arithmetic_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// `arithmetic_expressionList /* Vec<T>::Push */: add_operator term arithmetic_expressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_list_0(
        &mut self,
        _add_operator: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _arithmetic_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut arithmetic_expression_list = pop_item!(
            self,
            arithmetic_expression_list,
            ArithmeticExpressionList,
            context
        );
        let term = pop_item!(self, term, Term, context);
        let add_operator = pop_item!(self, add_operator, AddOperator, context);
        let arithmetic_expression_list_0_built = ArithmeticExpressionList {
            term: (&term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            add_operator,
        };
        // Add an element to the vector
        arithmetic_expression_list.push(arithmetic_expression_list_0_built);
        self.push(
            ASTType::ArithmeticExpressionList(arithmetic_expression_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// `arithmetic_expressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression_list_1_built = Vec::new();
        self.push(
            ASTType::ArithmeticExpressionList(arithmetic_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// `arithmetic_expressionOpt /* Option<T>::Some */: add_operator;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_opt_0(&mut self, _add_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let add_operator = pop_item!(self, add_operator, AddOperator, context);
        let arithmetic_expression_opt_0_built = ArithmeticExpressionOpt { add_operator };
        self.push(
            ASTType::ArithmeticExpressionOpt(Some(arithmetic_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// `arithmetic_expressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArithmeticExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// `add_operator: '+';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_0(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_0_built = AddOperatorPlus { plus };
        let add_operator_0_built = AddOperator::Plus(add_operator_0_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_0_built)?;
        self.push(ASTType::AddOperator(add_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// `add_operator: '-';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_1(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_1_built = AddOperatorMinus { minus };
        let add_operator_1_built = AddOperator::Minus(add_operator_1_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_1_built)?;
        self.push(ASTType::AddOperator(add_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// `add_operator: '.+';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_2(&mut self, dot_plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_plus = dot_plus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_2_built = AddOperatorDotPlus { dot_plus };
        let add_operator_2_built = AddOperator::DotPlus(add_operator_2_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_2_built)?;
        self.push(ASTType::AddOperator(add_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// `add_operator: '.-';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_3(&mut self, dot_minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_minus = dot_minus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_3_built = AddOperatorDotMinus { dot_minus };
        let add_operator_3_built = AddOperator::DotMinus(add_operator_3_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_3_built)?;
        self.push(ASTType::AddOperator(add_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// `term: factor : term termList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn term(&mut self, _factor: &ParseTreeType<'t>, _term_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list = pop_and_reverse_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let term_built = Term {
            factor: (&factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            term_list,
        };
        // Calling user action here
        self.user_grammar.term(&term_built)?;
        self.push(ASTType::Term(term_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// `termList /* Vec<T>::Push */: mul_operator factor : term termList;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_0(
        &mut self,
        _mul_operator: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut term_list = pop_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_operator = pop_item!(self, mul_operator, MulOperator, context);
        let term_list_0_built = TermList {
            factor: (&factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            mul_operator,
        };
        // Add an element to the vector
        term_list.push(term_list_0_built);
        self.push(ASTType::TermList(term_list), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// `termList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list_1_built = Vec::new();
        self.push(ASTType::TermList(term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// `mul_operator: '*';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_0_built = MulOperatorStar { star };
        let mul_operator_0_built = MulOperator::Star(mul_operator_0_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_0_built)?;
        self.push(ASTType::MulOperator(mul_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// `mul_operator: '/';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_1(&mut self, slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_1_built = MulOperatorSlash { slash };
        let mul_operator_1_built = MulOperator::Slash(mul_operator_1_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_1_built)?;
        self.push(ASTType::MulOperator(mul_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// `mul_operator: '.*';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_2(&mut self, dot_star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_star = dot_star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_2_built = MulOperatorDotStar { dot_star };
        let mul_operator_2_built = MulOperator::DotStar(mul_operator_2_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_2_built)?;
        self.push(ASTType::MulOperator(mul_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// `mul_operator: './';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_3(&mut self, dot_slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_slash = dot_slash
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_3_built = MulOperatorDotSlash { dot_slash };
        let mul_operator_3_built = MulOperator::DotSlash(mul_operator_3_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_3_built)?;
        self.push(ASTType::MulOperator(mul_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// `factor: primary : term factorList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor(
        &mut self,
        _primary: &ParseTreeType<'t>,
        _factor_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list = pop_and_reverse_item!(self, factor_list, FactorList, context);
        let primary = pop_item!(self, primary, Primary, context);
        let factor_built = Factor {
            primary: (&primary)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            factor_list,
        };
        // Calling user action here
        self.user_grammar.factor(&factor_built)?;
        self.push(ASTType::Factor(factor_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// `factorList /* Vec<T>::Push */: factorListGroup primary : term factorList;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_0(
        &mut self,
        _factor_list_group: &ParseTreeType<'t>,
        _primary: &ParseTreeType<'t>,
        _factor_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut factor_list = pop_item!(self, factor_list, FactorList, context);
        let primary = pop_item!(self, primary, Primary, context);
        let factor_list_group = pop_item!(self, factor_list_group, FactorListGroup, context);
        let factor_list_0_built = FactorList {
            primary: (&primary)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            factor_list_group,
        };
        // Add an element to the vector
        factor_list.push(factor_list_0_built);
        self.push(ASTType::FactorList(factor_list), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// `factorListGroup: '^';`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_group_0(&mut self, circumflex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = circumflex
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let factor_list_group_0_built = FactorListGroupCircumflex { circumflex };
        let factor_list_group_0_built = FactorListGroup::Circumflex(factor_list_group_0_built);
        self.push(ASTType::FactorListGroup(factor_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// `factorListGroup: '.^';`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_group_1(&mut self, dot_circumflex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_circumflex = dot_circumflex
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let factor_list_group_1_built = FactorListGroupDotCircumflex { dot_circumflex };
        let factor_list_group_1_built = FactorListGroup::DotCircumflex(factor_list_group_1_built);
        self.push(ASTType::FactorListGroup(factor_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// `factorList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list_1_built = Vec::new();
        self.push(ASTType::FactorList(factor_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// `primary: unsigned_number;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_0(&mut self, _unsigned_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_number = pop_item!(self, unsigned_number, UnsignedNumber, context);
        let primary_0_built = PrimaryUnsignedNumber { unsigned_number };
        let primary_0_built = Primary::UnsignedNumber(primary_0_built);
        // Calling user action here
        self.user_grammar.primary(&primary_0_built)?;
        self.push(ASTType::Primary(primary_0_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// `primary: string;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let primary_1_built = PrimaryString { string };
        let primary_1_built = Primary::String(primary_1_built);
        // Calling user action here
        self.user_grammar.primary(&primary_1_built)?;
        self.push(ASTType::Primary(primary_1_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// `primary: false;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_2(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let primary_2_built = PrimaryFalse { r#false };
        let primary_2_built = Primary::False(primary_2_built);
        // Calling user action here
        self.user_grammar.primary(&primary_2_built)?;
        self.push(ASTType::Primary(primary_2_built), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// `primary: true;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_3(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let primary_3_built = PrimaryTrue { r#true };
        let primary_3_built = Primary::True(primary_3_built);
        // Calling user action here
        self.user_grammar.primary(&primary_3_built)?;
        self.push(ASTType::Primary(primary_3_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// `primary: component_reference;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_4(&mut self, _component_reference: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let primary_4_built = PrimaryComponentReference {
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let primary_4_built = Primary::ComponentReference(primary_4_built);
        // Calling user action here
        self.user_grammar.primary(&primary_4_built)?;
        self.push(ASTType::Primary(primary_4_built), context);
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// `primary: end;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_5(&mut self, _end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let primary_5_built = PrimaryEnd { end };
        let primary_5_built = Primary::End(primary_5_built);
        // Calling user action here
        self.user_grammar.primary(&primary_5_built)?;
        self.push(ASTType::Primary(primary_5_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// `unsigned_number: unsigned_integer : %t_type;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_number_0(&mut self, _unsigned_integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_integer = pop_item!(self, unsigned_integer, UnsignedInteger, context);
        let unsigned_number_0_built = UnsignedNumberUnsignedInteger {
            unsigned_integer: (&unsigned_integer)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let unsigned_number_0_built = UnsignedNumber::UnsignedInteger(unsigned_number_0_built);
        // Calling user action here
        self.user_grammar
            .unsigned_number(&unsigned_number_0_built)?;
        self.push(ASTType::UnsignedNumber(unsigned_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// `unsigned_number: unsigned_real : %t_type;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_number_1(&mut self, _unsigned_real: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_real = pop_item!(self, unsigned_real, UnsignedReal, context);
        let unsigned_number_1_built = UnsignedNumberUnsignedReal {
            unsigned_real: (&unsigned_real)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let unsigned_number_1_built = UnsignedNumber::UnsignedReal(unsigned_number_1_built);
        // Calling user action here
        self.user_grammar
            .unsigned_number(&unsigned_number_1_built)?;
        self.push(ASTType::UnsignedNumber(unsigned_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// `type_specifier: type_specifierOpt /* Option */ name;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier(
        &mut self,
        _type_specifier_opt: &ParseTreeType<'t>,
        _name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let type_specifier_opt = pop_item!(self, type_specifier_opt, TypeSpecifierOpt, context);
        let type_specifier_built = TypeSpecifier {
            type_specifier_opt,
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.type_specifier(&type_specifier_built)?;
        self.push(ASTType::TypeSpecifier(type_specifier_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// `type_specifierOpt /* Option<T>::Some */: '.'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier_opt_0(&mut self, _dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_specifier_opt_0_built = TypeSpecifierOpt {};
        self.push(
            ASTType::TypeSpecifierOpt(Some(type_specifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// `type_specifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeSpecifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// `name: ident : %t_type nameList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn name(&mut self, _ident: &ParseTreeType<'t>, _name_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name_list = pop_and_reverse_item!(self, name_list, NameList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let name_built = Name {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            name_list,
        };
        // Calling user action here
        self.user_grammar.name(&name_built)?;
        self.push(ASTType::Name(name_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// `nameList /* Vec<T>::Push */: '.'^ /* Clipped */ ident : %t_type nameList;`
    ///
    #[parol_runtime::function_name::named]
    fn name_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _name_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut name_list = pop_item!(self, name_list, NameList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let name_list_0_built = NameList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        name_list.push(name_list_0_built);
        self.push(ASTType::NameList(name_list), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// `nameList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn name_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name_list_1_built = Vec::new();
        self.push(ASTType::NameList(name_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// `component_reference: component_referenceOpt /* Option */ ident : %t_type component_referenceList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference(
        &mut self,
        _component_reference_opt: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _component_reference_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_list = pop_and_reverse_item!(
            self,
            component_reference_list,
            ComponentReferenceList,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        let component_reference_opt = pop_item!(
            self,
            component_reference_opt,
            ComponentReferenceOpt,
            context
        );
        let component_reference_built = ComponentReference {
            component_reference_opt,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_reference_list,
        };
        // Calling user action here
        self.user_grammar
            .component_reference(&component_reference_built)?;
        self.push(
            ASTType::ComponentReference(component_reference_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// `component_referenceList /* Vec<T>::Push */: '.'^ /* Clipped */ ident : %t_type component_referenceOpt0 /* Option */ component_referenceList;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _component_reference_opt0: &ParseTreeType<'t>,
        _component_reference_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut component_reference_list = pop_item!(
            self,
            component_reference_list,
            ComponentReferenceList,
            context
        );
        let component_reference_opt0 = pop_item!(
            self,
            component_reference_opt0,
            ComponentReferenceOpt0,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        let component_reference_list_0_built = ComponentReferenceList {
            component_reference_opt0,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        component_reference_list.push(component_reference_list_0_built);
        self.push(
            ASTType::ComponentReferenceList(component_reference_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// `component_referenceList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_list_1_built = Vec::new();
        self.push(
            ASTType::ComponentReferenceList(component_reference_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// `component_referenceOpt0 /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt0_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let component_reference_opt0_0_built = ComponentReferenceOpt0 { array_subscripts };
        self.push(
            ASTType::ComponentReferenceOpt0(Some(component_reference_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// `component_referenceOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentReferenceOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// `component_referenceOpt /* Option<T>::Some */: '.'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt_0(&mut self, _dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_opt_0_built = ComponentReferenceOpt {};
        self.push(
            ASTType::ComponentReferenceOpt(Some(component_reference_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// `component_referenceOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentReferenceOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// `array_subscripts: '['^ /* Clipped */ subscript array_subscriptsList /* Vec */ ']'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _subscript: &ParseTreeType<'t>,
        _array_subscripts_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts_list =
            pop_and_reverse_item!(self, array_subscripts_list, ArraySubscriptsList, context);
        let subscript = pop_item!(self, subscript, Subscript, context);
        let array_subscripts_built = ArraySubscripts {
            subscript,
            array_subscripts_list,
        };
        // Calling user action here
        self.user_grammar
            .array_subscripts(&array_subscripts_built)?;
        self.push(ASTType::ArraySubscripts(array_subscripts_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// `array_subscriptsList /* Vec<T>::Push */: ','^ /* Clipped */ subscript array_subscriptsList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _subscript: &ParseTreeType<'t>,
        _array_subscripts_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_subscripts_list =
            pop_item!(self, array_subscripts_list, ArraySubscriptsList, context);
        let subscript = pop_item!(self, subscript, Subscript, context);
        let array_subscripts_list_0_built = ArraySubscriptsList { subscript };
        // Add an element to the vector
        array_subscripts_list.push(array_subscripts_list_0_built);
        self.push(ASTType::ArraySubscriptsList(array_subscripts_list), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// `array_subscriptsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts_list_1_built = Vec::new();
        self.push(
            ASTType::ArraySubscriptsList(array_subscripts_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// `subscript: ':';`
    ///
    #[parol_runtime::function_name::named]
    fn subscript_0(&mut self, colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let subscript_0_built = SubscriptColon { colon };
        let subscript_0_built = Subscript::Colon(subscript_0_built);
        // Calling user action here
        self.user_grammar.subscript(&subscript_0_built)?;
        self.push(ASTType::Subscript(subscript_0_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// `subscript: expression : term;`
    ///
    #[parol_runtime::function_name::named]
    fn subscript_1(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let subscript_1_built = SubscriptExpression {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let subscript_1_built = Subscript::Expression(subscript_1_built);
        // Calling user action here
        self.user_grammar.subscript(&subscript_1_built)?;
        self.push(ASTType::Subscript(subscript_1_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// `description: description_string descriptionOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn description(
        &mut self,
        _description_string: &ParseTreeType<'t>,
        _description_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_opt = pop_item!(self, description_opt, DescriptionOpt, context);
        let description_string = pop_item!(self, description_string, DescriptionString, context);
        let description_built = Description {
            description_string,
            description_opt,
        };
        // Calling user action here
        self.user_grammar.description(&description_built)?;
        self.push(ASTType::Description(description_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// `descriptionOpt /* Option<T>::Some */: annotation_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn description_opt_0(&mut self, _annotation_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation_clause = pop_item!(self, annotation_clause, AnnotationClause, context);
        let description_opt_0_built = DescriptionOpt { annotation_clause };
        self.push(
            ASTType::DescriptionOpt(Some(description_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// `descriptionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DescriptionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// `description_string: description_stringOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string(&mut self, _description_string_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt =
            pop_item!(self, description_string_opt, DescriptionStringOpt, context);
        let description_string_built = DescriptionString {
            description_string_opt,
        };
        // Calling user action here
        self.user_grammar
            .description_string(&description_string_built)?;
        self.push(
            ASTType::DescriptionString(description_string_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// `description_stringOpt /* Option<T>::Some */: string description_stringOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_0(
        &mut self,
        _string: &ParseTreeType<'t>,
        _description_string_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt_list = pop_and_reverse_item!(
            self,
            description_string_opt_list,
            DescriptionStringOptList,
            context
        );
        let string = pop_item!(self, string, String, context);
        let description_string_opt_0_built = DescriptionStringOpt {
            string,
            description_string_opt_list,
        };
        self.push(
            ASTType::DescriptionStringOpt(Some(description_string_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// `description_stringOptList /* Vec<T>::Push */: '+'^ /* Clipped */ string description_stringOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_list_0(
        &mut self,
        _plus: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
        _description_string_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_string_opt_list = pop_item!(
            self,
            description_string_opt_list,
            DescriptionStringOptList,
            context
        );
        let string = pop_item!(self, string, String, context);
        let description_string_opt_list_0_built = DescriptionStringOptList { string };
        // Add an element to the vector
        description_string_opt_list.push(description_string_opt_list_0_built);
        self.push(
            ASTType::DescriptionStringOptList(description_string_opt_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// `description_stringOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionStringOptList(description_string_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// `description_stringOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DescriptionStringOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// `annotation_clause: annotation;`
    ///
    #[parol_runtime::function_name::named]
    fn annotation_clause(&mut self, _annotation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation = pop_item!(self, annotation, Annotation, context);
        let annotation_clause_built = AnnotationClause { annotation };
        // Calling user action here
        self.user_grammar
            .annotation_clause(&annotation_clause_built)?;
        self.push(ASTType::AnnotationClause(annotation_clause_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ModelicaGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ModelicaGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.algorithm(&children[0]),
            1 => self.and(&children[0]),
            2 => self.annotation(&children[0]),
            3 => self.block(&children[0]),
            4 => self.class(&children[0]),
            5 => self.connector(&children[0]),
            6 => self.constant(&children[0]),
            7 => self.discrete(&children[0]),
            8 => self.encapsulated(&children[0]),
            9 => self.end(&children[0]),
            10 => self.equation(&children[0]),
            11 => self.expandable(&children[0]),
            12 => self.r#false(&children[0]),
            13 => self.r#final(&children[0]),
            14 => self.flow(&children[0]),
            15 => self.function(&children[0]),
            16 => self.import(&children[0]),
            17 => self.impure(&children[0]),
            18 => self.initial(&children[0]),
            19 => self.inner(&children[0]),
            20 => self.input(&children[0]),
            21 => self.model(&children[0]),
            22 => self.not(&children[0]),
            23 => self.operator(&children[0]),
            24 => self.or(&children[0]),
            25 => self.outer(&children[0]),
            26 => self.output(&children[0]),
            27 => self.package(&children[0]),
            28 => self.parameter(&children[0]),
            29 => self.partial(&children[0]),
            30 => self.protected(&children[0]),
            31 => self.public(&children[0]),
            32 => self.pure(&children[0]),
            33 => self.record(&children[0]),
            34 => self.redeclare(&children[0]),
            35 => self.stream(&children[0]),
            36 => self.r#true(&children[0]),
            37 => self.r#type(&children[0]),
            38 => self.within(&children[0]),
            39 => self.ident(&children[0]),
            40 => self.string(&children[0]),
            41 => self.unsigned_integer(&children[0]),
            42 => self.unsigned_real_0(&children[0]),
            43 => self.unsigned_real_1(&children[0]),
            44 => self.unsigned_real_2(&children[0]),
            45 => self.stored_definition(&children[0], &children[1]),
            46 => self.stored_definition_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            47 => self.stored_definition_list_1(),
            48 => self.stored_definition_opt0_0(&children[0]),
            49 => self.stored_definition_opt0_1(),
            50 => self.stored_definition_opt_0(&children[0], &children[1], &children[2]),
            51 => self.stored_definition_opt1_0(&children[0]),
            52 => self.stored_definition_opt1_1(),
            53 => self.stored_definition_opt_1(),
            54 => self.class_definition(&children[0], &children[1], &children[2]),
            55 => self.class_definition_opt_0(&children[0]),
            56 => self.class_definition_opt_1(),
            57 => self.class_prefixes(&children[0], &children[1]),
            58 => self.class_prefixes_group_0(&children[0]),
            59 => self.class_prefixes_group_1(&children[0]),
            60 => self.class_prefixes_group_2(&children[0], &children[1]),
            61 => self.class_prefixes_group_3(&children[0]),
            62 => self.class_prefixes_group_4(&children[0], &children[1]),
            63 => self.class_prefixes_group_5(&children[0]),
            64 => self.class_prefixes_group_6(&children[0]),
            65 => self.class_prefixes_group_7(&children[0], &children[1], &children[2]),
            66 => self.class_prefixes_group_8(&children[0]),
            67 => self.class_prefixes_opt3_0(&children[0]),
            68 => self.class_prefixes_opt3_1(),
            69 => self.class_prefixes_opt2_0(&children[0]),
            70 => self.class_prefixes_opt2_group_0(&children[0]),
            71 => self.class_prefixes_opt2_group_1(&children[0]),
            72 => self.class_prefixes_opt2_1(),
            73 => self.class_prefixes_opt1_0(&children[0]),
            74 => self.class_prefixes_opt1_1(),
            75 => self.class_prefixes_opt0_0(&children[0]),
            76 => self.class_prefixes_opt0_1(),
            77 => self.class_prefixes_opt_0(&children[0]),
            78 => self.class_prefixes_opt_1(),
            79 => self.class_specifier(&children[0]),
            80 => self.long_class_specifier(&children[0], &children[1], &children[2], &children[3]),
            81 => self.composition(&children[0], &children[1]),
            82 => self.composition_list_0(&children[0], &children[1]),
            83 => self.composition_list_group_0(&children[0], &children[1]),
            84 => self.composition_list_group_1(&children[0], &children[1]),
            85 => self.composition_list_group_2(&children[0]),
            86 => self.composition_list_group_3(&children[0]),
            87 => self.composition_list_1(),
            88 => self.element_list(&children[0]),
            89 => self.element_list_list_0(&children[0], &children[1], &children[2]),
            90 => self.element_list_list_1(),
            91 => self.element_0(&children[0]),
            92 => self.element_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            93 => self.element_group_0(&children[0]),
            94 => self.element_group_1(&children[0]),
            95 => self.element_opt2_0(&children[0]),
            96 => self.element_opt2_1(),
            97 => self.element_opt1_0(&children[0]),
            98 => self.element_opt1_1(),
            99 => self.element_opt0_0(&children[0]),
            100 => self.element_opt0_1(),
            101 => self.element_opt_0(&children[0]),
            102 => self.element_opt_1(),
            103 => self.import_clause(&children[0], &children[1], &children[2]),
            104 => self.import_clause_group_0(&children[0], &children[1], &children[2]),
            105 => self.import_clause_group_1(&children[0], &children[1]),
            106 => self.import_clause_opt_0(&children[0]),
            107 => self.import_clause_opt_group_0(&children[0]),
            108 => self.import_clause_opt_group_1(&children[0], &children[1]),
            109 => self.import_clause_opt_group_group_0(&children[0]),
            110 => self.import_clause_opt_group_group_1(&children[0], &children[1], &children[2]),
            111 => self.import_clause_opt_1(),
            112 => self.import_list(&children[0], &children[1]),
            113 => self.import_list_list_0(&children[0], &children[1], &children[2]),
            114 => self.import_list_list_1(),
            115 => self.component_clause(&children[0], &children[1], &children[2], &children[3]),
            116 => self.component_clause_opt_0(&children[0]),
            117 => self.component_clause_opt_1(),
            118 => self.type_prefix(&children[0], &children[1], &children[2]),
            119 => self.type_prefix_opt1_0(&children[0]),
            120 => self.type_prefix_opt1_group_0(&children[0]),
            121 => self.type_prefix_opt1_group_1(&children[0]),
            122 => self.type_prefix_opt1_1(),
            123 => self.type_prefix_opt0_0(&children[0]),
            124 => self.type_prefix_opt0_group_0(&children[0]),
            125 => self.type_prefix_opt0_group_1(&children[0]),
            126 => self.type_prefix_opt0_group_2(&children[0]),
            127 => self.type_prefix_opt0_1(),
            128 => self.type_prefix_opt_0(&children[0]),
            129 => self.type_prefix_opt_group_0(&children[0]),
            130 => self.type_prefix_opt_group_1(&children[0]),
            131 => self.type_prefix_opt_1(),
            132 => self.component_list(&children[0], &children[1]),
            133 => self.component_list_list_0(&children[0], &children[1], &children[2]),
            134 => self.component_list_list_1(),
            135 => self.component_declaration(&children[0], &children[1]),
            136 => self.declaration(&children[0], &children[1]),
            137 => self.declaration_opt_0(&children[0]),
            138 => self.declaration_opt_1(),
            139 => self.equation_section(&children[0], &children[1], &children[2]),
            140 => self.equation_section_list_0(&children[0], &children[1], &children[2]),
            141 => self.equation_section_list_1(),
            142 => self.equation_section_opt_0(&children[0]),
            143 => self.equation_section_opt_1(),
            144 => self.algorithm_section(&children[0], &children[1], &children[2]),
            145 => self.algorithm_section_list_0(&children[0], &children[1], &children[2]),
            146 => self.algorithm_section_list_1(),
            147 => self.algorithm_section_opt_0(&children[0]),
            148 => self.algorithm_section_opt_1(),
            149 => self.some_equation(&children[0], &children[1], &children[2], &children[3]),
            150 => self.statement(&children[0], &children[1], &children[2], &children[3]),
            151 => self.expression(&children[0]),
            152 => self.simple_expression(&children[0], &children[1]),
            153 => self.simple_expression_opt_0(&children[0], &children[1], &children[2]),
            154 => self.simple_expression_opt0_0(&children[0], &children[1]),
            155 => self.simple_expression_opt0_1(),
            156 => self.simple_expression_opt_1(),
            157 => self.logical_expression(&children[0], &children[1]),
            158 => self.logical_expression_list_0(&children[0], &children[1], &children[2]),
            159 => self.logical_expression_list_1(),
            160 => self.logical_term(&children[0], &children[1]),
            161 => self.logical_term_list_0(&children[0], &children[1], &children[2]),
            162 => self.logical_term_list_1(),
            163 => self.logical_factor(&children[0], &children[1]),
            164 => self.logical_factor_opt_0(&children[0]),
            165 => self.logical_factor_opt_1(),
            166 => self.relation(&children[0], &children[1]),
            167 => self.relation_opt_0(&children[0], &children[1]),
            168 => self.relation_opt_1(),
            169 => self.relational_operator_0(&children[0]),
            170 => self.relational_operator_1(&children[0]),
            171 => self.relational_operator_2(&children[0]),
            172 => self.relational_operator_3(&children[0]),
            173 => self.relational_operator_4(&children[0]),
            174 => self.relational_operator_5(&children[0]),
            175 => self.arithmetic_expression(&children[0], &children[1], &children[2]),
            176 => self.arithmetic_expression_list_0(&children[0], &children[1], &children[2]),
            177 => self.arithmetic_expression_list_1(),
            178 => self.arithmetic_expression_opt_0(&children[0]),
            179 => self.arithmetic_expression_opt_1(),
            180 => self.add_operator_0(&children[0]),
            181 => self.add_operator_1(&children[0]),
            182 => self.add_operator_2(&children[0]),
            183 => self.add_operator_3(&children[0]),
            184 => self.term(&children[0], &children[1]),
            185 => self.term_list_0(&children[0], &children[1], &children[2]),
            186 => self.term_list_1(),
            187 => self.mul_operator_0(&children[0]),
            188 => self.mul_operator_1(&children[0]),
            189 => self.mul_operator_2(&children[0]),
            190 => self.mul_operator_3(&children[0]),
            191 => self.factor(&children[0], &children[1]),
            192 => self.factor_list_0(&children[0], &children[1], &children[2]),
            193 => self.factor_list_group_0(&children[0]),
            194 => self.factor_list_group_1(&children[0]),
            195 => self.factor_list_1(),
            196 => self.primary_0(&children[0]),
            197 => self.primary_1(&children[0]),
            198 => self.primary_2(&children[0]),
            199 => self.primary_3(&children[0]),
            200 => self.primary_4(&children[0]),
            201 => self.primary_5(&children[0]),
            202 => self.unsigned_number_0(&children[0]),
            203 => self.unsigned_number_1(&children[0]),
            204 => self.type_specifier(&children[0], &children[1]),
            205 => self.type_specifier_opt_0(&children[0]),
            206 => self.type_specifier_opt_1(),
            207 => self.name(&children[0], &children[1]),
            208 => self.name_list_0(&children[0], &children[1], &children[2]),
            209 => self.name_list_1(),
            210 => self.component_reference(&children[0], &children[1], &children[2]),
            211 => self.component_reference_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            212 => self.component_reference_list_1(),
            213 => self.component_reference_opt0_0(&children[0]),
            214 => self.component_reference_opt0_1(),
            215 => self.component_reference_opt_0(&children[0]),
            216 => self.component_reference_opt_1(),
            217 => self.array_subscripts(&children[0], &children[1], &children[2], &children[3]),
            218 => self.array_subscripts_list_0(&children[0], &children[1], &children[2]),
            219 => self.array_subscripts_list_1(),
            220 => self.subscript_0(&children[0]),
            221 => self.subscript_1(&children[0]),
            222 => self.description(&children[0], &children[1]),
            223 => self.description_opt_0(&children[0]),
            224 => self.description_opt_1(),
            225 => self.description_string(&children[0]),
            226 => self.description_string_opt_0(&children[0], &children[1]),
            227 => self.description_string_opt_list_0(&children[0], &children[1], &children[2]),
            228 => self.description_string_opt_list_1(),
            229 => self.description_string_opt_1(),
            230 => self.annotation_clause(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
