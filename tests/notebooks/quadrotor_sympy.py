"""
Automatically generated by Rumoca
"""
import sympy
import numpy as np
import scipy.integrate

cos = sympy.cos
sin = sympy.sin
tan = sympy.tan

class Model:
    """
    Flattened Modelica Model
    """

    def __init__(self):
        # ============================================
        # Initialize
        self.solved = False

        # ============================================
        # Declare time
        self.time = sympy.symbols('time')

        # ============================================
        # Declare u
        ail = sympy.symbols('ail')
        elv = sympy.symbols('elv')
        rdr = sympy.symbols('rdr')
        thr = sympy.symbols('thr')
        self.u = sympy.Matrix([
            ail, 
            elv, 
            rdr, 
            thr])
        self.u0 = { 
            'ail': 0.0, 
            'elv': 0.0, 
            'rdr': 0.0, 
            'thr': 0.0}
        self.u_index = { 
            'ail': 0, 
            'elv': 1, 
            'rdr': 2, 
            'thr': 3}
        self.u_index_rev = [ 
            'ail', 
            'elv', 
            'rdr', 
            'thr']
        # ============================================
        # Declare p
        l = sympy.symbols('l')
        aileron_mix = sympy.symbols('aileron_mix')
        elevator_mix = sympy.symbols('elevator_mix')
        rudder_mix = sympy.symbols('rudder_mix')
        throttle_mix = sympy.symbols('throttle_mix')
        m = sympy.symbols('m')
        g = sympy.symbols('g')
        Jx = sympy.symbols('Jx')
        Jy = sympy.symbols('Jy')
        Jz = sympy.symbols('Jz')
        Jxz = sympy.symbols('Jxz')
        Lambda = sympy.symbols('Lambda')
        m1_Cm = sympy.symbols('m1_Cm')
        m1_Ct = sympy.symbols('m1_Ct')
        m1_tau = sympy.symbols('m1_tau')
        m2_Cm = sympy.symbols('m2_Cm')
        m2_Ct = sympy.symbols('m2_Ct')
        m2_tau = sympy.symbols('m2_tau')
        m3_Cm = sympy.symbols('m3_Cm')
        m3_Ct = sympy.symbols('m3_Ct')
        m3_tau = sympy.symbols('m3_tau')
        m4_Cm = sympy.symbols('m4_Cm')
        m4_Ct = sympy.symbols('m4_Ct')
        m4_tau = sympy.symbols('m4_tau')
        self.p = sympy.Matrix([
            l, 
            aileron_mix, 
            elevator_mix, 
            rudder_mix, 
            throttle_mix, 
            m, 
            g, 
            Jx, 
            Jy, 
            Jz, 
            Jxz, 
            Lambda, 
            m1_Cm, 
            m1_Ct, 
            m1_tau, 
            m2_Cm, 
            m2_Ct, 
            m2_tau, 
            m3_Cm, 
            m3_Ct, 
            m3_tau, 
            m4_Cm, 
            m4_Ct, 
            m4_tau])
        self.p0 = { 
            'l': 1.0, 
            'aileron_mix': 1, 
            'elevator_mix': 1, 
            'rudder_mix': 10, 
            'throttle_mix': 16.0, 
            'm': 1.0, 
            'g': 9.81, 
            'Jx': 1, 
            'Jy': 1, 
            'Jz': 1, 
            'Jxz': 0.0, 
            'Lambda': 1, 
            'm1_Cm': 0.01, 
            'm1_Ct': 0.01, 
            'm1_tau': 0.1, 
            'm2_Cm': 0.01, 
            'm2_Ct': 0.01, 
            'm2_tau': 0.1, 
            'm3_Cm': 0.01, 
            'm3_Ct': 0.01, 
            'm3_tau': 0.1, 
            'm4_Cm': 0.01, 
            'm4_Ct': 0.01, 
            'm4_tau': 0.1}
        self.p_index = { 
            'l': 0, 
            'aileron_mix': 1, 
            'elevator_mix': 2, 
            'rudder_mix': 3, 
            'throttle_mix': 4, 
            'm': 5, 
            'g': 6, 
            'Jx': 7, 
            'Jy': 8, 
            'Jz': 9, 
            'Jxz': 10, 
            'Lambda': 11, 
            'm1_Cm': 12, 
            'm1_Ct': 13, 
            'm1_tau': 14, 
            'm2_Cm': 15, 
            'm2_Ct': 16, 
            'm2_tau': 17, 
            'm3_Cm': 18, 
            'm3_Ct': 19, 
            'm3_tau': 20, 
            'm4_Cm': 21, 
            'm4_Ct': 22, 
            'm4_tau': 23}
        self.p_index_rev = [ 
            'l', 
            'aileron_mix', 
            'elevator_mix', 
            'rudder_mix', 
            'throttle_mix', 
            'm', 
            'g', 
            'Jx', 
            'Jy', 
            'Jz', 
            'Jxz', 
            'Lambda', 
            'm1_Cm', 
            'm1_Ct', 
            'm1_tau', 
            'm2_Cm', 
            'm2_Ct', 
            'm2_tau', 
            'm3_Cm', 
            'm3_Ct', 
            'm3_tau', 
            'm4_Cm', 
            'm4_Ct', 
            'm4_tau']
        # ============================================
        # Declare cp
        self.cp = sympy.Matrix([])
        self.cp0 = { }
        self.cp_index = { }
        self.cp_index_rev = [ ]
        # ============================================
        # Declare x
        x = sympy.symbols('x')
        y = sympy.symbols('y')
        h = sympy.symbols('h')
        P = sympy.symbols('P')
        Q = sympy.symbols('Q')
        R = sympy.symbols('R')
        U = sympy.symbols('U')
        V = sympy.symbols('V')
        W = sympy.symbols('W')
        phi = sympy.symbols('phi')
        theta = sympy.symbols('theta')
        psi = sympy.symbols('psi')
        m1_omega = sympy.symbols('m1_omega')
        m2_omega = sympy.symbols('m2_omega')
        m3_omega = sympy.symbols('m3_omega')
        m4_omega = sympy.symbols('m4_omega')
        self.x = sympy.Matrix([
            x, 
            y, 
            h, 
            P, 
            Q, 
            R, 
            U, 
            V, 
            W, 
            phi, 
            theta, 
            psi, 
            m1_omega, 
            m2_omega, 
            m3_omega, 
            m4_omega])
        self.x0 = { 
            'x': 0.0, 
            'y': 0.0, 
            'h': 0.0, 
            'P': 0.0, 
            'Q': 0.0, 
            'R': 0.0, 
            'U': 0.0, 
            'V': 0.0, 
            'W': 0.0, 
            'phi': 0.0, 
            'theta': 0.0, 
            'psi': 0.0, 
            'm1_omega': 0.0, 
            'm2_omega': 0.0, 
            'm3_omega': 0.0, 
            'm4_omega': 0.0}
        self.x_index = { 
            'x': 0, 
            'y': 1, 
            'h': 2, 
            'P': 3, 
            'Q': 4, 
            'R': 5, 
            'U': 6, 
            'V': 7, 
            'W': 8, 
            'phi': 9, 
            'theta': 10, 
            'psi': 11, 
            'm1_omega': 12, 
            'm2_omega': 13, 
            'm3_omega': 14, 
            'm4_omega': 15}
        self.x_index_rev = [ 
            'x', 
            'y', 
            'h', 
            'P', 
            'Q', 
            'R', 
            'U', 
            'V', 
            'W', 
            'phi', 
            'theta', 
            'psi', 
            'm1_omega', 
            'm2_omega', 
            'm3_omega', 
            'm4_omega']
        # ============================================
        # Declare m
        self.m = sympy.Matrix([])
        self.m0 = { }
        self.m_index = { }
        self.m_index_rev = [ ]
        # ============================================
        # Declare y
        m1_moment = sympy.symbols('m1_moment')
        m2_moment = sympy.symbols('m2_moment')
        m3_moment = sympy.symbols('m3_moment')
        m4_moment = sympy.symbols('m4_moment')
        Fx = sympy.symbols('Fx')
        Fy = sympy.symbols('Fy')
        Fz = sympy.symbols('Fz')
        Mx = sympy.symbols('Mx')
        My = sympy.symbols('My')
        Mz = sympy.symbols('Mz')
        m1_omega_ref = sympy.symbols('m1_omega_ref')
        m1_thrust = sympy.symbols('m1_thrust')
        m2_omega_ref = sympy.symbols('m2_omega_ref')
        m2_thrust = sympy.symbols('m2_thrust')
        m3_omega_ref = sympy.symbols('m3_omega_ref')
        m3_thrust = sympy.symbols('m3_thrust')
        m4_omega_ref = sympy.symbols('m4_omega_ref')
        m4_thrust = sympy.symbols('m4_thrust')
        self.y = sympy.Matrix([
            m1_moment, 
            m2_moment, 
            m3_moment, 
            m4_moment, 
            Fx, 
            Fy, 
            Fz, 
            Mx, 
            My, 
            Mz, 
            m1_omega_ref, 
            m1_thrust, 
            m2_omega_ref, 
            m2_thrust, 
            m3_omega_ref, 
            m3_thrust, 
            m4_omega_ref, 
            m4_thrust])
        self.y0 = { 
            'm1_moment': 0.0, 
            'm2_moment': 0.0, 
            'm3_moment': 0.0, 
            'm4_moment': 0.0, 
            'Fx': 0.0, 
            'Fy': 0.0, 
            'Fz': 0.0, 
            'Mx': 0.0, 
            'My': 0.0, 
            'Mz': 0.0, 
            'm1_omega_ref': 0.0, 
            'm1_thrust': 0.0, 
            'm2_omega_ref': 0.0, 
            'm2_thrust': 0.0, 
            'm3_omega_ref': 0.0, 
            'm3_thrust': 0.0, 
            'm4_omega_ref': 0.0, 
            'm4_thrust': 0.0}
        self.y_index = { 
            'm1_moment': 0, 
            'm2_moment': 1, 
            'm3_moment': 2, 
            'm4_moment': 3, 
            'Fx': 4, 
            'Fy': 5, 
            'Fz': 6, 
            'Mx': 7, 
            'My': 8, 
            'Mz': 9, 
            'm1_omega_ref': 10, 
            'm1_thrust': 11, 
            'm2_omega_ref': 12, 
            'm2_thrust': 13, 
            'm3_omega_ref': 14, 
            'm3_thrust': 15, 
            'm4_omega_ref': 16, 
            'm4_thrust': 17}
        self.y_index_rev = [ 
            'm1_moment', 
            'm2_moment', 
            'm3_moment', 
            'm4_moment', 
            'Fx', 
            'Fy', 
            'Fz', 
            'Mx', 
            'My', 
            'Mz', 
            'm1_omega_ref', 
            'm1_thrust', 
            'm2_omega_ref', 
            'm2_thrust', 
            'm3_omega_ref', 
            'm3_thrust', 
            'm4_omega_ref', 
            'm4_thrust']
        # ============================================
        # Declare z
        self.z = sympy.Matrix([])
        self.z0 = { }
        self.z_index = { }
        self.z_index_rev = [ ]
        
        # ============================================
        # Declare pre_x
        pre_x = sympy.symbols('pre_x')
        pre_y = sympy.symbols('pre_y')
        pre_h = sympy.symbols('pre_h')
        pre_P = sympy.symbols('pre_P')
        pre_Q = sympy.symbols('pre_Q')
        pre_R = sympy.symbols('pre_R')
        pre_U = sympy.symbols('pre_U')
        pre_V = sympy.symbols('pre_V')
        pre_W = sympy.symbols('pre_W')
        pre_phi = sympy.symbols('pre_phi')
        pre_theta = sympy.symbols('pre_theta')
        pre_psi = sympy.symbols('pre_psi')
        pre_m1_omega = sympy.symbols('pre_m1_omega')
        pre_m2_omega = sympy.symbols('pre_m2_omega')
        pre_m3_omega = sympy.symbols('pre_m3_omega')
        pre_m4_omega = sympy.symbols('pre_m4_omega')
        self.pre_x = sympy.Matrix([
            pre_x, 
            pre_y, 
            pre_h, 
            pre_P, 
            pre_Q, 
            pre_R, 
            pre_U, 
            pre_V, 
            pre_W, 
            pre_phi, 
            pre_theta, 
            pre_psi, 
            pre_m1_omega, 
            pre_m2_omega, 
            pre_m3_omega, 
            pre_m4_omega])

        # ============================================
        # Declare pre_m
        self.pre_m = sympy.Matrix([])

        # ============================================
        # Declare pre_z
        self.pre_z = sympy.Matrix([])

        # ============================================
        # Declare x_dot
        der_x = sympy.symbols('der_x')
        der_y = sympy.symbols('der_y')
        der_h = sympy.symbols('der_h')
        der_P = sympy.symbols('der_P')
        der_Q = sympy.symbols('der_Q')
        der_R = sympy.symbols('der_R')
        der_U = sympy.symbols('der_U')
        der_V = sympy.symbols('der_V')
        der_W = sympy.symbols('der_W')
        der_phi = sympy.symbols('der_phi')
        der_theta = sympy.symbols('der_theta')
        der_psi = sympy.symbols('der_psi')
        der_m1_omega = sympy.symbols('der_m1_omega')
        der_m2_omega = sympy.symbols('der_m2_omega')
        der_m3_omega = sympy.symbols('der_m3_omega')
        der_m4_omega = sympy.symbols('der_m4_omega')
        self.x_dot = sympy.Matrix([
            der_x, 
            der_y, 
            der_h, 
            der_P, 
            der_Q, 
            der_R, 
            der_U, 
            der_V, 
            der_W, 
            der_phi, 
            der_theta, 
            der_psi, 
            der_m1_omega, 
            der_m2_omega, 
            der_m3_omega, 
            der_m4_omega])

        # ============================================
        # Define Continous Update Function: fx
        self.fx = sympy.Matrix([
            Fx - (0), 
            Fy - (0), 
            Fz - (-((((m1_thrust + m2_thrust) + m3_thrust) + m4_thrust))), 
            Mx - ((l * (((-(m1_thrust) + m2_thrust) - m3_thrust) + m4_thrust))), 
            My - ((l * (((-(m1_thrust) + m2_thrust) + m3_thrust) - m4_thrust))), 
            Mz - ((((m1_moment + m2_moment) - m3_moment) - m4_moment)), 
            m1_omega_ref - (((((thr * throttle_mix) - (ail * aileron_mix)) + (elv * elevator_mix)) + (rdr * rudder_mix))), 
            m2_omega_ref - (((((thr * throttle_mix) + (ail * aileron_mix)) - (elv * elevator_mix)) + (rdr * rudder_mix))), 
            m3_omega_ref - (((((thr * throttle_mix) - (ail * aileron_mix)) - (elv * elevator_mix)) - (rdr * rudder_mix))), 
            m4_omega_ref - (((((thr * throttle_mix) + (ail * aileron_mix)) + (elv * elevator_mix)) - (rdr * rudder_mix))), 
            der_x - (((((U * cos(theta)) * cos(psi)) + (V * (-((cos(phi) * sin(psi))) + ((sin(phi) * sin(theta)) * cos(psi))))) + (W * ((sin(phi) * sin(psi)) + ((cos(phi) * sin(theta)) * cos(psi)))))), 
            der_y - (((((U * cos(theta)) * sin(psi)) + (V * ((cos(phi) * cos(psi)) + ((sin(phi) * sin(theta)) * sin(psi))))) + (W * (-((sin(phi) * cos(psi))) + ((cos(phi) * sin(theta)) * sin(psi)))))), 
            der_h - ((((U * sin(theta)) - ((V * sin(phi)) * cos(theta))) - ((W * cos(phi)) * cos(theta)))), 
            der_U - (((((R * V) - (Q * W)) - (g * sin(theta))) + (Fx / m))), 
            der_V - ((((-((R * U)) + (P * W)) + ((g * sin(phi)) * cos(theta))) + (Fy / m))), 
            der_W - (((((Q * U) - (P * V)) + ((g * cos(phi)) * cos(theta))) + (Fz / m))), 
            der_phi - ((P + (tan(theta) * ((Q * sin(phi)) + (R * cos(phi)))))), 
            der_theta - (((Q * cos(phi)) - (R * sin(phi)))), 
            der_psi - ((((Q * sin(phi)) + (R * cos(phi))) / cos(theta))), 
            (Lambda * der_P) - (((((((Jxz * ((Jx - Jy) + Jz)) * P) * Q) - ((((Jz * (Jz - Jy)) + (Jxz * Jxz)) * Q) * R)) + (Jz * Mx)) + (Jxz * Mz))), 
            (Jy * der_Q) - ((((((Jz - Jx) * P) * R) - (Jxz * ((P * P) - (R * R)))) + My)), 
            (Lambda * der_R) - (((((((((Jx - Jy) * Jx) + (Jxz * Jxz)) * P) * Q) - (((Jxz * ((Jx - Jy) + Jz)) * Q) * R)) + (Jxz * Mx)) + (Jx * Mz))), 
            der_m1_omega - (((1 / m1_tau) * (m1_omega_ref - m1_omega))), 
            m1_thrust - (((m1_Ct * m1_omega) * m1_omega)), 
            m1_moment - ((m1_Cm * m1_thrust)), 
            der_m2_omega - (((1 / m2_tau) * (m2_omega_ref - m2_omega))), 
            m2_thrust - (((m2_Ct * m2_omega) * m2_omega)), 
            m2_moment - ((m2_Cm * m2_thrust)), 
            der_m3_omega - (((1 / m3_tau) * (m3_omega_ref - m3_omega))), 
            m3_thrust - (((m3_Ct * m3_omega) * m3_omega)), 
            m3_moment - ((m3_Cm * m3_thrust)), 
            der_m4_omega - (((1 / m4_tau) * (m4_omega_ref - m4_omega))), 
            m4_thrust - (((m4_Ct * m4_omega) * m4_omega)), 
            m4_moment - ((m4_Cm * m4_thrust))])

        # ============================================
        # Define Conditions: c
        self.c = {  }

        # ============================================
        # Define Reset Functions: fr

        # ============================================
        # Events and Event callbacks


    def solve(self):
        # ============================================
        # Solve for explicit ODE
        v = sympy.Matrix(list(self.x_dot) + list(self.y))
        sol = sympy.solve(self.fx, v)
        self.sol_x_dot = self.x_dot.subs(sol)
        self.sol_y = self.y.subs(sol)
        self.f_x_dot = sympy.lambdify([self.time, self.x, self.m, self.u, self.p], list(self.sol_x_dot))
        self.f_y = sympy.lambdify([self.time, self.x, self.m, self.u, self.p], list(self.sol_y))
        self.solved = True

    def __repr__(self):
        return repr(self.__dict__)

    def simulate(self, t0, tf, dt, x0=None, f_u=None, max_events=100):
        """
        Simulate the modelica model
        """
        if not self.solved:
            self.solve()
        
        if f_u is None:
            def f_u(t):
                return np.zeros(self.u.shape[0])

        # ============================================
        # Declare initial vectors
        u0 = np.array([self.u0[k] for k in self.u0.keys()])
        p0 = np.array([self.p0[k] for k in self.p0.keys()])
        cp0 = np.array([self.cp0[k] for k in self.cp0.keys()])
        m0 = np.array([self.m0[k] for k in self.m0.keys()])
        y0 = np.array([self.y0[k] for k in self.y0.keys()])
        z0 = np.array([self.z0[k] for k in self.z0.keys()])
        
        if x0 is None:
            x0 = np.array([self.x0[k] for k in self.x0.keys()])

        # ============================================
        # Declare Events
        events = []

        event_callback = {}

        # ============================================
        # Solve IVP
        event_count = 0
        t1 = tf
        data = {
            't': [],
            'x': [],
            'u': [],
            'y': [],
        }

        while t0 < tf - dt and event_count < max_events:
            t_eval = np.arange(t0, tf, dt)
            res = scipy.integrate.solve_ivp(
                y0=x0,
                fun=lambda ti, x: self.f_x_dot(ti, x, m0, f_u(ti), p0),
                t_span=[t_eval[0], t_eval[-1]],
                t_eval=t_eval,
                events=events,
            )

            # check for event
            x1 = res['y'][:, -1]
            t1 = res['t'][-1]
            if res.t_events is not None:
                event_count += 1
                for i, t_event in enumerate(res.t_events):
                    if len(t_event) > 0:
                        if i in event_callback:
                            x1 = event_callback[i](t_event[i], x1)

            x = res['y']
            t = res['t']
            u = np.array([ f_u(ti) for ti in t ]).T
            y = np.array([ self.f_y(ti, xi, m0, ui, p0) for (ti, xi, ui) in zip(t, x.T, u.T) ]).T

            data['x'].append(x)
            data['t'].append(t)
            data['u'].append(u)
            data['y'].append(y)

            t0 = t1
            x0 = x1
        
        for k in data.keys():
            if len(data[k]) > 0:
                data[k] = np.hstack(data[k])
        return data
