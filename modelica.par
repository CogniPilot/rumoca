%start stored_definition
%title "Modelica grammar"
%comment "Modelica grammar 3.7-dev for `parol`"
%line_comment "//"
%t_type crate::ir::Token // %nt_type stored_definition = crate::modelica_grammar::StoredDefinition //%nt_type class_definition = crate::ir::ClassDefinition // %nt_type class_prefixes = crate::modelica_grammar::ClassPrefixes //%nt_type class_specifier = crate::modelica_grammar::ClassSpecifier //%nt_type long_class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type composition = crate::modelica_grammar::Composition
%nt_type element_list = crate::modelica_grammar::ElementList // %nt_type element = crate::modelica_grammar::Element // %nt_type component_clause = crate::modelica_grammar::ComponentClause
%nt_type component_list = crate::modelica_grammar::ComponentList // %nt_type component_declaration = crate::modelica_grammar::ComponentDeclaration // %nt_type declaration = crate::modelica_grammar::Declaration // %nt_type type_prefix = crate::modelica_grammar::TypePrefix // %nt_type type_specifier = crate::modelica_grammar::TypeSpecifier
%nt_type equation_section = crate::modelica_grammar::EquationSection
%nt_type algorithm_section = crate::modelica_grammar::AlgorithmSection
%nt_type some_equation = crate::ir::Equation
%nt_type simple_expression = crate::ir::Expression
%nt_type expression = crate::ir::Expression
%nt_type logical_expression = crate::ir::Expression
%nt_type logical_term = crate::ir::Expression
%nt_type logical_factor = crate::ir::Expression
%nt_type relation = crate::ir::Expression // %nt_type relational_operator = crate::modelica_grammar::RelationalOperator
%nt_type arithmetic_expression = crate::ir::Expression // %nt_type add_operator = crate::modelica_grammar::AddOperator
%nt_type term = crate::ir::Expression // %nt_type mul_operator = crate::modelica_grammar::MulOperator
%nt_type factor = crate::ir::Expression
%nt_type primary = crate::ir::Expression
%nt_type component_reference = crate::ir::ComponentReference
%nt_type name = crate::ir::Name
%nt_type statement = crate::ir::Statement
%nt_type array_subscripts = crate::modelica_grammar::ArraySubscripts
%nt_type subscript = crate::ir::Subscript // terminals
%nt_type ident = crate::ir::Token
%nt_type unsigned_integer = crate::ir::Token
%nt_type unsigned_real = crate::ir::Token

%%

//=============================================================================
// 2.3.3 Modelica Keywords
algorithm
    : 'algorithm'
    ;

and : 'and'
    ;

annotation
    : 'annotation'
    ;

block
    : 'block'
    ;

break
    : 'break'
    ;

class
    : 'class'
    ;

connect
    : 'connect'
    ;

connector
    : 'connector'
    ;

constant
    : 'constant'
    ;

constrainedby
    : 'constrainedby'
    ;

der : 'der'
    ;

discrete
    : 'discrete'
    ;

each: 'each'
    ;

else: 'else'
    ;

elseif
    : 'elseif'
    ;

elsewhen
    : 'elsewhen'
    ;

encapsulated
    : 'encapsulated'
    ;

end : 'end'
    ;

enumeration
    : 'enumeration'
    ;

equation
    : 'equation'
    ;

expandable
    : 'expandable'
    ;

extends
    : 'extends'
    ;

external
    : 'external'
    ;

false
    : 'false'
    ;

final
    : 'final'
    ;

flow: 'flow'
    ;

for : 'for'
    ;

function
    : 'function'
    ;

if  : 'if'
    ;

import
    : 'import'
    ;

impure
    : 'impure'
    ;

in  : 'in'
    ;

initial
    : 'initial'
    ;

inner
    : 'inner'
    ;

input
    : 'input'
    ;

loop: 'loop'
    ;

model
    : 'model'
    ;

not : 'not'
    ;

operator
    : 'operator'
    ;

or  : 'or'
    ;

outer
    : 'outer'
    ;

output
    : 'output'
    ;

package
    : 'package'
    ;

parameter
    : 'parameter'
    ;

partial
    : 'partial'
    ;

protected
    : 'protected'
    ;

public
    : 'public'
    ;

pure: 'pure'
    ;

record
    : 'record'
    ;

redeclare
    : 'redeclare'
    ;

replaceable
    : 'replaceable'
    ;

return
    : 'return'
    ;

stream
    : 'stream'
    ;

then: 'then'
    ;

true: 'true'
    ;

type: 'type'
    ;

when: 'when'
    ;

while
    : 'while'
    ;

within
    : 'within'
    ;

//=============================================================================
// A.1 Lexical conventions
// IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
ident
    : /[_a-zA-Z][_a-zA-Z0-9]*/
    ;

// Q-IDENT = "'" { Q-CHAR | S-ESCAPE } "'"
// NON-DIGIT = "_" | letters "a"..."z" | letters "A"..."Z"
// DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
// Q-CHAR = NON-DIGIT | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")"
//    | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | ">" | "="
//    | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | " " | """
// S-ESCAPE = "\'" | "\"" | "\?" | "\\"
//    | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"
// STRING = """ { S-CHAR | S-ESCAPE } """
string
    : /"[\w]*"/
    ;

// S-CHAR is any member of the Unicode character set
// (https://unicode.org; see section 13.4 for storing as UTF-8 on files)
// except double-quote ‚Äò‚Äù‚Äô, and backslash ‚Äò\‚Äô.
// UNSIGNED-INTEGER = DIGIT { DIGIT }
unsigned_integer
    : /[0-9]+/
    ;

// UNSIGNED-REAL =
//    UNSIGNED-INTEGER  "." [ UNSIGNED-INTEGER ]
//    | UNSIGNED_INTEGER [ "." [ UNSIGNED_INTEGER ] ]
//      ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER
//    | "."  UNSIGNED-INTEGER [ ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER ]
unsigned_real
    : /[0-9]+\.[0-9]+/@decimal
    | /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific
    | /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2
    ;

//=============================================================================
// A.2.1 Stored Definition ‚Äì Within
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ stored-definition :
//‚úÖ    [ within [ name ] ";" ]
//‚úÖ    { [ final ] class-definition ";" }
stored_definition
    : [ within^ [ name ] ';'^ ] { [ final ] class_definition ';'^ }
    ;

//=============================================================================
// A.2.2 Class Definition
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ class-definition :
//‚úÖ    [ encapsulated ] class-prefixes class-specifier
class_definition
    : [ encapsulated ] class_prefixes class_specifier
    ;

//‚úÖ class-prefixes :
//‚úÖ    [ partial ]
//‚úÖ    ( class
//‚úÖ      | model
//‚úÖ      | [ operator ] record
//‚úÖ      | block
//‚úÖ      | [ expandable ] connector
//‚úÖ      | type
//‚úÖ      | package
//‚úÖ      | [ pure | impure ] [ operator ] function
//‚úÖ      | operator
//‚úÖ    )
class_prefixes
    : [ partial ]
      ( class | model | [ operator ] record | block | [ expandable ] connector | type | package | [ pure | impure ] [ operator ] function | operator )
    ;

//‚úÖ class-specifier :
//‚úÖ    long-class-specifier
//‚úÖ    | short-class-specifier
//‚úÖ    | der-class-specifier
class_specifier
    : long_class_specifier
    | short_class_specifier
    | der_class_specifier
    ;

//‚úÖ long-class-specifier :
//‚úÖ    IDENT description-string composition end IDENT
//‚úÖ    | extends IDENT [ class-modification ] description-string composition end IDENT
long_class_specifier
    : ident@name composition end^ ident
    | extends^ name [ class_modification ] description_string
      // composition (TODO: won't compile if added)
      end^ ident
    ;

//‚úÖ short-class-specifier :
//‚úÖ    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//‚úÖ    [ class-modification ] description
//‚úÖ    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description
short_class_specifier
    : ident '='^ base_prefix type_specifier [ array_subscripts ] [ class_modification ] description
    | ident '='^ enumeration '('^ ( [ enum_list ] | ':'^ ) ')'^ description
    ;

//‚úÖ der-class-specifier :
//‚úÖ    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description
der_class_specifier
    : ident '=' der '('^ type_specifier ','^ ident { ','^ ident } ')'^ description
    ;

//‚úÖ base-prefix :
//‚úÖ    [ input | output ]
base_prefix
    : [ input | output ]
    ;

//‚úÖ enum-list :
//‚úÖ    enumeration-literal { "," enumeration-literal }
enum_list
    : enumeration_literal { ','^ enumeration_literal }
    ;

//‚úÖ enumeration-literal :
//‚úÖ    IDENT description
enumeration_literal
    : ident description
    ;

//‚úÖ composition :
//‚úÖ    element-list
//‚úÖ    { public element-list
//‚úÖ      | protected element-list
//‚úÖ      | equation-section
//‚úÖ      | algorithm-section
//‚úÖ    }
//‚úÖ    [ external [ language-specification ]
//‚úÖ      [ external-function-call ] [ annotation-clause ] ";"
//‚úÖ    ]
//‚úÖ    [ annotation-clause ";" ]
composition
    : element_list
      { public element_list | protected element_list | equation_section | algorithm_section }
      [ external^ [ language_specification ] [ external_function_call ] [ annotation_clause ] ';'^ ]
      [ annotation_clause ';'^ ]
    ;

//‚úÖ language-specification :
//‚úÖ    STRING
language_specification
    : string
    ;

//‚úÖ external-function-call :
//‚úÖ    [ component-reference "=" ]
//‚úÖ    IDENT "(" [ expression-list ] ")"
external_function_call
    : [ component_reference '='^ ] ident '('^ [ expression_list ] ')'^
    ;

//‚úÖ element-list :
//‚úÖ    { element ";" }
element_list
    : { element ';' }
    ;

//‚úÖ element :
//‚úÖ    import-clause
//‚úÖ    | extends-clause
//‚úÖ    | [ redeclare ]
//‚úÖ      [ final ]
//‚úÖ      [ inner ] [ outer ]
//‚úÖ      ( class-definition
//‚úÖ        | component-clause
//‚úÖ        | replaceable ( class-definition | component-clause )
//‚úÖ          [ constraining-clause description ]
//‚úÖ      )
element
    : import_clause
    | extends_clause
    | [ redeclare ] [ final ] [ inner ] [ outer ] ( class_definition | component_clause )
    | replaceable ( class_definition | component_clause ) [ constraining_clause description ]
    ;

//‚úÖ import-clause :
//‚úÖ    import
//‚úÖ    ( IDENT "=" name
//‚úÖ      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//‚úÖ    )
//‚úÖ    description
import_clause
    : import ( ident '='^ name | name [ '.*' | '.'^ ( '*' | '{' import_list '}' ) ] ) description
    ;

//‚úÖ import-list :
//‚úÖ    IDENT { "," IDENT }
import_list
    : ident { ','^ ident }
    ;

//=============================================================================
// A.2.3 Extends
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ extends-clause :
//‚úÖ    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]
extends_clause
    : extends^ type_specifier [ class_or_inheritance_modification ] [ annotation_clause ]
    ;

//‚úÖ constraining-clause :
//‚úÖ    constrainedby type-specifier [ class-modification ]
constraining_clause
    : constrainedby^ type_specifier [ class_modification ]
    ;

//‚úÖ class-or-inheritance-modification :
//‚úÖ    "(" [ argument-or-inheritance-modification-list ] ")"
class_or_inheritance_modification
    : '('^ [ argument_or_inheritance_modification_list ] ')'^
    ;

//‚úÖ argument-or-inheritance-modification-list :
//‚úÖ     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }
argument_or_inheritance_modification_list
    : ( argument | inheritance_modification ) { ','^ ( argument | inheritance_modification ) }
    ;

//‚úÖ inheritance-modification :
//‚úÖ     break ( connect-equation | IDENT )
inheritance_modification
    : break^ ( connect_equation | ident )
    ;

//-----------------------------------------------------------------------------
// A.2.4 Component Clause
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ component-clause :
//‚úÖ    type-prefix type-specifier [ array-subscripts ] component-list
component_clause
    : type_prefix type_specifier [ array_subscripts ] component_list
    ;

//‚úÖ type-prefix :
//‚úÖ    [ flow | stream ]
//‚úÖ    [ discrete | parameter | constant ]
//‚úÖ    [ input | output ]
type_prefix
    : [ flow | stream ] [ discrete | parameter | constant ] [ input | output ]
    ;

//‚úÖ component-list :
//‚úÖ    component-declaration { "," component-declaration }
component_list
    : component_declaration { ','^ component_declaration }
    ;

//‚úÖ component-declaration :
//‚úÖ    declaration [ condition-attribute ] description
component_declaration
    : declaration // [ condition_attribute ]
      description
    ;

//‚úÖ condition-attribute :
//‚úÖ    if expression
// condition_attribute :
//     if^ expression
//     ;
//‚úÖ declaration :
//‚úÖ    IDENT [ array-subscripts ] [ modification ]
declaration
    : ident [ array_subscripts ] // [ modification ]
    ;

//=============================================================================
// A.2.5 Modification
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ modification :
//‚úÖ    class-modification [ "=" modification-expression ]
//‚úÖ    | "=" modification-expression
modification
    : class_modification [ '='^ modification_expression ]
    | '='^ modification_expression
    ;

//‚úÖ modification-expression :
//‚úÖ    expression
//‚úÖ    | break
modification_expression
    : expression
    | break
    ;

//‚úÖ class-modification :
//‚úÖ    "(" [ argument-list ] ")"
class_modification
    : '('^ [ argument_list ] ')'^
    ;

//‚úÖ argument-list :
//‚úÖ    argument { "," argument }
argument_list
    : argument { ','^ argument }
    ;

//‚úÖ argument :
//‚úÖ    element-modification-or-replaceable
//‚úÖ    | element-redeclaration
argument
    : element_modification_or_replaceable
    | element_redeclaration
    ;

//‚úÖ element-modification-or-replaceable :
//‚úÖ    [ each ] [ final ] ( element-modification | element-replaceable )
element_modification_or_replaceable
    : [ each ] [ final ] ( element_modification | element_replaceable )
    ;

//‚úÖ element-modification :
//‚úÖ    name [ modification ] description-string
element_modification
    : name [ modification ] description_string
    ;

//‚úÖ element-redeclaration :
//‚úÖ    redeclare [ each ] [ final ]
//‚úÖ    ( short-class-definition | component-clause1 | element-replaceable )
element_redeclaration
    : redeclare [ each ] [ final ]
      ( short_class_definition | component_clause1 | element_replaceable )
    ;

//‚úÖ element-replaceable :
//‚úÖ    replaceable ( short-class-definition | component-clause1 )
//‚úÖ    [ constraining-clause ]
element_replaceable
    : replaceable ( short_class_definition | component_clause1 ) [ constraining_clause ]
    ;

//‚úÖ component-clause1 :
//‚úÖ    type-prefix type-specifier component-declaration1
component_clause1
    : type_prefix type_specifier component_declaration1
    ;

//‚úÖ component-declaration1 :
//‚úÖ    declaration description
component_declaration1
    : declaration description
    ;

//‚úÖ short-class-definition :
//‚úÖ    class-prefixes short-class-specifier
short_class_definition
    : class_prefixes short_class_specifier
    ;

//=============================================================================
// A.2.6 Equations
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ equation-section :
//‚úÖ    [ initial ] equation { some-equation ";" }
equation_section
    : [ initial^ ] equation^ { some_equation ';'^ }
    ;

//‚úÖ algorithm-section :
//‚úÖ    [ initial ] algorithm { statement ";" }
algorithm_section
    : [ initial^ ] algorithm^ { statement ';'^ }
    ;

//‚úÖ some-equation :
//‚úÖ    ( simple-expression "=" expression
//‚úÖ      | if-equation
//‚úÖ      | for-equation
//‚úÖ      | connect-equation
//‚úÖ      | when-equation
//‚úÖ      | component-reference function-call-args
//‚úÖ    )
//‚úÖ    description
some_equation
    : 
      ( simple_expression '='^ expression | if_equation | for_equation | connect_equation | when_equation )
      /*component_reference function_call_args*/ description
    ;

//‚úÖ statement :
//‚úÖ    ( component-reference ( ":=" expression | function-call-args )
//‚úÖ      | "(" output-expression-list ")" ":="
//‚úÖ        component-reference function-call-args
//‚úÖ      | break
//‚úÖ      | return
//‚úÖ      | if-statement
//‚úÖ      | for-statement
//‚úÖ      | while-statement
//‚úÖ      | when-statement
//‚úÖ    )
//‚úÖ    description
statement
    : 
      ( component_reference ( ":="^ expression ) | break | return | if_statement | for_statement | while_statement | when_statement )
      description
    ;

//‚úÖ if-equation :
//‚úÖ    if expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    { elseif expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    }
//‚úÖ    [ else
//‚úÖ      { some-equation ";" }
//‚úÖ    ]
//‚úÖ    end if
if_equation
    : if^ expression then^ { some_equation ';'^ } { elseif^ expression then^ { some_equation ';'^ } }
      [ else^ { some_equation ';'^ } ] end^ if
    ;

//‚úÖ if-statement :
//‚úÖ    if expression then
//‚úÖ      { statement ";" }
//‚úÖ    { elseif expression then
//‚úÖ      { statement ";" }
//‚úÖ    }
//‚úÖ    [ else
//‚úÖ      { statement ";" }
//‚úÖ    ]
//‚úÖ    end if
if_statement
    : if^ expression then^ { statement ';'^ } { elseif^ expression then^ { statement ';'^ } }
      [ else^ { statement ';'^ } ] end^ if
    ;

//‚úÖ for-equation :
//‚úÖ    for for-indices loop
//‚úÖ      { some-equation ";" }
//‚úÖ    end for
for_equation
    : for^ for_indices loop^ { some_equation ';'^ } end^ for
    ;

//‚úÖ for-statement :
//‚úÖ    for for-indices loop
//‚úÖ      { statement ";" }
//‚úÖ    end for
for_statement
    : for^ for_indices loop^ { statement ';'^ } end^ for
    ;

//‚úÖ for-indices :
//‚úÖ    for-index { "," for-index }
for_indices
    : for_index { ','^ for_index }
    ;

//‚úÖ for-index :
//‚úÖ    IDENT [ in expression ]
for_index
    : ident [ in^ expression ]
    ;

//‚úÖ while-statement :
//‚úÖ    while expression loop
//‚úÖ      { statement ";" }
//‚úÖ    end while
while_statement
    : while^ expression loop^ { statement ';'^ } end^ while
    ;

//‚úÖ when-equation :
//‚úÖ    when expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    { elsewhen expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    }
//‚úÖ    end when
when_equation
    : when^ expression then^ { some_equation ';'^ }
      { elsewhen^ expression then^ { some_equation ';'^ } } end^ when
    ;

//‚úÖ when-statement :
//‚úÖ    when expression then
//‚úÖ      { statement ";" }
//‚úÖ    { elsewhen expression then
//‚úÖ      { statement ";" }
//‚úÖ    }
//‚úÖ    end when
when_statement
    : when^ expression then^ { statement ';'^ } { elsewhen^ expression then^ { statement ';'^ } }
      end^ when
    ;

//‚úÖ connect-equation :
//‚úÖ    connect "(" component-reference "," component-reference ")"
connect_equation
    : connect '('^ component_reference ','^ component_reference ')'^
    ;

//=============================================================================
// A.2.7 Expressions
// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//‚úÖ expression :
//‚úÖ    simple-expression
//‚úÖ    | if expression then expression
//‚úÖ      { elseif expression then expression }
//‚úÖ      else expression
expression
    : simple_expression /*
     | if^ expression then^ expression { elseif^ expression then^ expression } else^ expression
     */
    ;

//‚úÖ simple-expression :
//‚úÖ    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
simple_expression
    : logical_expression [ ':'^ logical_expression [ ':'^ logical_expression ] ]
    ;

//‚úÖ logical-expression :
//‚úÖ    logical-term { or logical-term }
logical_expression
    : logical_term { or^ logical_term }
    ;

//‚úÖ logical-term :
//‚úÖ    logical-factor { and logical-factor }
logical_term
    : logical_factor { and^ logical_factor }
    ;

//‚úÖ logical-factor :
//‚úÖ    [ not ] relation
logical_factor
    : [ not ] relation
    ;

//‚úÖ relation :
//‚úÖ    arithmetic-expression [ relational-operator arithmetic-expression ]
relation
    : arithmetic_expression [ relational_operator arithmetic_expression ]
    ;

//‚úÖ relational-operator :
//‚úÖ    "<" | "<=" | ">" | ">=" | "==" | "<>"
relational_operator
    : '<'
    | '<='
    | '>'
    | '>='
    | '=='
    | '<>'
    ;

//‚úÖ arithmetic-expression :
//‚úÖ    [ add-operator ] term { add-operator term }
arithmetic_expression
    : [ add_operator ] term { add_operator term }
    ;

//‚úÖ add-operator :
//‚úÖ    "+" | "-" | ".+" | ".-"
add_operator
    : '+'
    | '-'
    | '.+'
    | '.-'
    ;

//‚úÖ term :
//‚úÖ    factor { mul-operator factor }
term: factor { mul_operator factor }
    ;

//‚úÖ mul-operator :
//‚úÖ    "*" | "/" | ".*" | "./"
mul_operator
    : '*'
    | '/'
    | '.*'
    | './'
    ;

//‚úÖ factor :
//‚úÖ    primary [ ( "^" | ".^" ) primary ]
factor
    : primary { ( '^' | '.^' ) primary }
    ;

//‚úÖ primary :
//‚úÖ    UNSIGNED-NUMBER
//‚úÖ    | STRING
//‚úÖ    | false
//‚úÖ    | true
//‚úÖ    | ( component-reference | der | initial | pure ) function-call-args
//‚úÖ    | component-reference
//‚úÖ    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//‚úÖ    | "[" expression-list { ";" expression-list } "]"
//‚úÖ    | "{" array-arguments "}"
//‚úÖ    | end
primary
    : unsigned_number
    | string
    | false
    | true // | ( component_reference | der | initial | pure ) function_call_args
    | component_reference // | '('^ output_expression_list ')' [ ( array_subscripts | '.'^ ident ) ]
// | '['^ expression_list { ';' expression_list } ']'^
// | '{'^ array_arguments '}'^
    | end
    ;

//‚úÖ UNSIGNED-NUMBER :
//‚úÖ    UNSIGNED-INTEGER | UNSIGNED-REAL
unsigned_number
    : unsigned_integer
    | unsigned_real
    ;

//‚úÖ type-specifier :
//‚úÖ    ["."] name
type_specifier
    : [ '.'^ ] name
    ;

//‚úÖ name :
//‚úÖ    IDENT { "." IDENT }
name: ident { '.'^ ident }
    ;

//‚úÖ component-reference :
//‚úÖ    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
component_reference
    : [ '.'^ ] ident { '.'^ //[ array_subscripts ]
      ident [ array_subscripts ] }
    ;

//‚úÖ result-reference :
//‚úÖ    component-reference
//‚úÖ    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"
// result_reference :
//     component_reference
//     | der '('^ component_reference [ ','^ unsigned_integer ] ')'^
//     ;
//‚úÖ function-call-args :
//‚úÖ    "(" [ function-arguments ] ")"
// function_call_args
//     : '('^ [ function_arguments ] ')'^
//     ;
//‚úÖ function-arguments :
//‚úÖ    expression [ "," function-arguments-non-first | for for-indices ]
//‚úÖ    | function-partial-application [ "," function-arguments-non-first ]
//‚úÖ    | named-arguments
// function_arguments
//     : expression [ ','^ function_arguments_non_first | for for_indices ]
//     | function_partial_application [ ','^ function_arguments_non_first ]
//     | named_arguments
//     ;
//‚úÖ function-arguments-non-first :
//‚úÖ    function-argument [ "," function-arguments-non-first ]
//‚úÖ    | named-arguments
// function_arguments_non_first
//     : function_argument [ ','^ function_arguments_non_first ]
//     | named_arguments
//     ;
//‚úÖ array-arguments :
//‚úÖ    expression [ "," array-arguments-non-first | for for-indices ]
// array_arguments
//     : expression [ ','^ array_arguments_non_first | for for_indices ]
//     ;
//‚úÖ array-arguments-non-first :
//‚úÖ    expression [ "," array-arguments-non-first ]
// array_arguments_non_first
//     : expression [ ','^ array_arguments_non_first ]
//     ;
//‚úÖ named-arguments: named-argument [ "," named-arguments ]
// named_arguments
//     : named_argument [ ','^ named_arguments ]
//     ;
//‚úÖ named-argument: IDENT "=" function-argument
// named_argument
//     : ident '='^ function_argument
//     ;
//‚úÖ function-argument :
//‚úÖ    function-partial-application | expression
// function_argument
//     : function_partial_application
//     | expression
//     ;
//‚úÖ function-partial-application :
//‚úÖ    function type-specifier "(" [ named-arguments ] ")"
// function_partial_application
//     : function type_specifier '('^ [ named_arguments ] ')'^
//     ;
//‚úÖ output-expression-list :
//‚úÖ    [ expression ] { "," [ expression ] }
// output_expression_list :
//     [ expression ] { ','^ [ expression ] }
//     ;
//‚úÖ expression-list :
//‚úÖ    expression { "," expression }
expression_list
    : expression { ','^ expression }
    ;

//‚úÖ array-subscripts :
//‚úÖ    "[" subscript { "," subscript } "]"
array_subscripts
    : '['^ subscript { ','^ subscript } ']'^
    ;

//‚úÖ subscript :
//‚úÖ    ":" | expression
subscript
    : ':'
    | expression
    ;

//‚úÖ description :
//‚úÖ    description-string [ annotation-clause ]
description
    : description_string [ annotation_clause ]
    ;

//‚úÖ description-string :
//‚úÖ    [ STRING { "+" STRING } ]
description_string
    : [ string { '+'^ string } ]
    ;

//‚úÖ annotation-clause :
//‚úÖ    annotation class-modification
annotation_clause
    : annotation class_modification
    ;
