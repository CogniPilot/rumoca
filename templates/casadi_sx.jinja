{%- macro render_model(model) %}
class {{ model.name }}(BaseModel):
    """
    {{ model.description }}
    """

    def __init__(self):

        # declare constants
        {%- for const in model.c %}
        {{ const.name }} = {{ render_expression(expr=const.start) }}
        {%- endfor %}

        # declare parameters
        {{ render_vector("self.p", model.p) | indent(4) }}

        # declare parameter start values
        {{ render_vector_start_dict("self.p0", model.p) | indent(4) }}

        # declare discrete states
        {{ render_vector("self.z", model.z) | indent(4) }}

        # declare discrete states start values
        {{ render_vector_start_dict("self.z0", model.z) | indent(4) }}

        # declare inputs
        {{ render_vector("self.u", model.u) | indent(4) }}

        # declare outputs
        {{ render_vector("self.y", model.y) | indent(4) }}

        # declare continuous states
        {{ render_vector("self.x", model.x) | indent(4) }}

        # declare continuous states start values
        {{ render_vector_start_dict("self.x0", model.x) | indent(4) }}

        # ode
        {{ render_vector_expression("self.ode", model.ode) | indent(4) }}

        # alg
        {{ render_vector_expression("self.alg", model.alg) | indent(4) }}

{%- endmacro %}

{%- macro render_vector(target, var_list) -%}
    {% for var in var_list -%}
    {{ var.name }} = ca.SX.sym('{{ var.name }}'
        {%- if var.array_subscripts | length > 0 %}, {% for sub in var.array_subscripts -%}
            {{ render_expression(expr=sub) -}}{% if not loop.last %},{% endif %}
        {%- endfor -%}{%- endif -%})
    {% endfor -%}
    {{ target }} = ca.vertcat(
    {%- for var in var_list %}
        {{ var.name }}{% if not loop.last %},{% endif %}
    {%- endfor %})
{%- endmacro -%}

{%- macro render_vector_start_dict(target, var_list) -%}
    {{ target }} = {
    {%- for var in var_list %}
        '{{ var.name }}': {{ render_expression(expr=var.start) -}}
        {% if not loop.last %},{% endif %}
    {%- endfor %}
    }
{%- endmacro -%}

{%- macro render_vector_expression(target, expr_list) -%}
    {{ target }} = ca.vertcat(
    {%- for expr in expr_list %}
        {{ render_expression(expr=expr) }}{% if not loop.last %},{% endif %}
    {%- endfor %})
{%- endmacro -%}

{%- macro render_binary(op, expr) -%}
    {{ render_expression(expr=expr.lhs) }}{{ op }}{{ render_expression(expr=expr.rhs) -}}
{%- endmacro -%}

{%- macro render_unary(op, expr) -%}
    {{ op }}{{ render_expression(expr=expr.rhs) -}}
{%- endmacro -%}

{%- macro render_expression(expr) -%}
    {% if "UnsignedReal" in expr -%}
        {{ expr.UnsignedReal }}
    {%- elif "UnsignedInteger" in expr -%}
        {{ expr.UnsignedInteger }}
    {%- elif "Ref" in expr -%}
        {{ expr.Ref.comp.name }}
        {%- if expr.Ref.comp.array_subscripts | length > 0 %}[{% for sub in expr.Ref.comp.array_subscripts -%}
            {#- handles index from 1 to 0 from Modelica to python-#}
            {{ render_expression(expr=sub) | int - 1 }}{% if not loop.last %},{% endif %}
        {%- endfor -%}]{%- endif -%}
    {%- elif "Add" in expr -%}
        {{ render_binary(op=" + ", expr=expr.Add) -}}
    {%- elif "Sub" in expr -%}
        {{ render_binary(op=" - ", expr=expr.Sub) -}}
    {%- elif "Mul" in expr -%}
        {{ render_binary(op="*", expr=expr.Mul) -}}
    {%- elif "Div" in expr -%}
        {{ render_binary(op="/", expr=expr.Div) -}}
    {%- elif "Exp" in expr -%}
        {{- render_binary(op="^", expr=expr.Exp) -}}
    {%- elif "Negative" in expr -%}
        {{ render_unary(op="-", expr=expr.Negative) -}}
    {%- elif "Parenthesis" in expr -%}
        ( {{- render_expression(expr=expr.Parenthesis.rhs) -}} )
    {%- elif "Not" in expr %}
        {{- render_unary(op="!", expr=expr.Not) -}}
    {%- elif "Or" in expr -%}
        ca.logic_or(
            {{- render_expression(expr=expr.Or.lhs) -}},
            {{- render_expression(expr=expr.Or.rhs) -}})
    {%- elif "And" in expr -%}
        ca.logic_and(
            {{- render_expression(expr=expr.And.lhs) -}},
            {{- render_expression(expr=expr.And.rhs) -}})
    {%- elif "Equal" in expr -%}
            {{- render_expression(expr=expr.Equal.lhs) -}} ==
            {{- render_expression(expr=expr.Equal.rhs) -}}
    {%- elif "ArrayArguments" in expr -%}
        ca.vertcat(
        {%- for arg in expr.ArrayArguments.args %}
            {{ render_expression(expr=arg) }}{% if not loop.last %},{% endif %}
        {%- endfor %})
    {%- elif "FunctionCall" in expr -%}
        {{ expr.FunctionCall.comp.name }}(
            {%- for arg in expr.FunctionCall.args -%}
                {{ render_expression(expr=arg) }}{% if not loop.last %}, {% endif %}
            {%- endfor %})
    {%- endif %}
{%- endmacro -%}
{#-
"""
RAW JSON STRUCT:
{{ model | pprint }}
"""
-#}
import casadi as ca
import numpy as np

class BaseModel:

    def __repr__(self):
        return repr(self.__dict__)

    def simulate(self, t=None, u=None):
        if t is None:
            t = np.arange(0, 1, 0.01)
        if u is None:
            u = 0

        p0 = np.array([self.p0[k] for k in self.p0.keys()])
        z0 = np.array([self.z0[k] for k in self.z0.keys()])
        x0 = np.array([self.x0[k] for k in self.x0.keys()])

        F = ca.integrator(
            'F', 'idas',
            {'x': self.x, 'z': self.z, 'p': self.p, 'u': self.u, 'ode': self.ode, 'alg': self.alg},
            t[0], t)

        res = F(x0=x0, z0=z0, p=p0, u=u)
        return {
            't': t,
            'x': res['xf'].T
        }
    
    def linearize(self):
        A = ca.jacobian(self.ode, self.x)
        B = ca.jacobian(self.ode, self.u)
        C = ca.jacobian(self.y, self.x)
        D = ca.jacobian(self.y, self.u)
        return (A, B, C, D)

{%- for model in models %}
{{ render_model(model=model) }}
{%- endfor %}