{# Class Macro #}
{%- macro render_class(class) %}
class {{ class.name }}(BaseModel):

    def __init__(self):

        # declare constants
        {%- for comp in class.components if comp.variability == "Constant" %}
        {{ comp.name }} = 0;
        {%- endfor %}

        # declare parameters
        {%- for comp in class.components if comp.variability == "Parameter" %}
        {{ comp.name }} = ca.SX.sym('{{ comp.name }}');
        {%- endfor %}
        self.p = ca.vertcat(
        {%- for comp in class.components if comp.variability == "Parameter" %}
            {{ comp.name }}{% if not loop.last %},{% endif %}
        {%- endfor %});
        self.p0 = {
        {%- for comp in class.components if comp.variability == "Parameter" %}
            '{{ comp.name }}': 0{% if not loop.last %},{% endif %}
        {%- endfor %}
        };

        # declare  discrete states
        {%- for comp in class.components if comp.variability == "Discrete" %}
        {{ comp.name }} = ca.SX.sym('{{ comp.name }}');
        {%- endfor %}
        self.z = ca.vertcat(
        {%- for comp in class.components if comp.variability == "Discrete" %}
            {{ comp.name }}{% if not loop.last %},{% endif %}
        {%- endfor %});
        self.z0 = {
        {%- for comp in class.components if comp.variability == "Discrete" %}
            '{{ comp.name }}': 0{% if not loop.last %},{% endif %}
        {%- endfor %}
        };

        # declare continuous states
        {%- for comp in class.components if comp.variability == "Continuous" %}
        {{ comp.name }} = ca.SX.sym('{{ comp.name }}');
        {%- endfor %}
        self.x = ca.vertcat(
        {%- for comp in class.components if comp.variability == "Continuous" %}
            {{ comp.name }}{% if not loop.last %},{% endif %}
        {%- endfor %});
        self.x0 = {
        {%- for comp in class.components if comp.variability == "Continuous" %}
            '{{ comp.name }}': 0{% if not loop.last %},{% endif %}
        {%- endfor %}
        };

        # declare state derivative equations
        {%- for eq in class.equations %}
        {{ render_equation(eq=eq) }}
        {%- endfor %}

        # declare state derivative vector
        self.x_dot = ca.vertcat(
        {%- for comp in class.components if comp.variability == "Continuous" %}
            der_{{ comp.name }}{% if not loop.last %},{% endif %}
        {%- endfor %});

        self.z = ca.vertcat()
        self.alg = ca.vertcat()

{%- endmacro %}

{#- Equation Macro -#}
{%- macro render_equation(eq) -%}
    {%- if "Der" in eq -%}
        der_{{ eq.Der.comp.name }} = {{ render_expression(expr=eq.Der.rhs) }};
    {%- endif %}
{%- endmacro -%}

{#- Binary Operation -#}
{%- macro binary(op, expr) %}
    {{- render_expression(expr=expr.lhs) }}{{ op }}{{ render_expression(expr=expr.rhs) -}}
{%- endmacro -%}

{#- Expression Macro -#}
{%- macro render_expression(expr) %}
    {%- if "UnsignedReal" in expr %}
        {{- expr.UnsignedReal }}
    {%- elif "UnsignedInteger" in expr %}
        {{- expr.UnsignedInteger }}
    {%- elif "Ref" in expr %}
        {{- expr.Ref.comp.name }}
    {%- elif "Add" in expr %}
        {{- binary(op=" + ", expr=expr.Add) -}}
    {%- elif "Sub" in expr %}
        {{- binary(op=" - ", expr=expr.Sub) -}}
    {%- elif "Mul" in expr %}
        {{- binary(op="*", expr=expr.Mul) -}}
    {%- elif "Div" in expr %}
        {{- binary(op="/", expr=expr.Div) -}}
    {%- elif "Exp" in expr %}
        {{- binary(op="^", expr=expr.Exp) -}}
    {%- elif "Or" in expr -%}
        ca.logic_or(
            {{- render_expression(expr=expr.Or.lhs) -}},
            {{- render_expression(expr=expr.Or.rhs) -}})
    {%- elif "And" in expr -%}
        ca.logic_and(
            {{- render_expression(expr=expr.And.lhs) -}},
            {{- render_expression(expr=expr.And.rhs) -}})
    {%- elif "Equal" in expr -%}
            {{- render_expression(expr=expr.Equal.lhs) -}} ==
            {{- render_expression(expr=expr.Equal.rhs) -}}
    {%- endif %}
{%- endmacro -%}

{#- Render File #}
import casadi as ca
import numpy as np

class BaseModel:

    def __repr__(self):
        return repr(self.__dict__)

    def simulate(self, t=None, u=None):
        if t is None:
            t = np.arange(0, 1, 0.01)
        if u is None:
            u = 0

        p0 = np.array([self.p0[k] for k in self.p0.keys()]);
        z0 = np.array([self.z0[k] for k in self.z0.keys()]);
        x0 = np.array([self.x0[k] for k in self.x0.keys()]);

        dae = {'x': self.x, 'z': self.z, 'p': self.p, 'ode': self.x_dot, 'alg': self.alg}
        F = ca.integrator('F', 'idas', dae, t[0], t)
        res = F(x0=x0, z0=z0, p=p0, u=u)
        return {
            't': t,
            'xf': res['xf'].T
        }
{%- for class in def.classes %}
{{ render_class(class=class) }}
{%- endfor %}
