use crate::tokens::{Token, LexicalError};
use crate::ast;

// Based on Modelica 3.7-dev Specification
grammar;

// 2.3.3 Modelica Keywords
// ============================================================================
extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        // keywords
        "algorithm" => Token::KeywordAlgorithm,
        "and" => Token::KeywordAnd,
        "annotation" => Token::KeywordAnnotation,
        "block" => Token::KeywordBlock,
        "break" => Token::KeywordBreak,
        "class" => Token::KeywordClass,
        "connect" => Token::KeywordConnect,
        "connector" => Token::KeywordConnector,
        "constant" => Token::KeywordConstant,
        "constrainedby" => Token::KeywordConstrainedby,
        "der" => Token::KeywordDer,
        "discrete" => Token::KeywordDiscrete,
        "each" => Token::KeywordEach,
        "else" => Token::KeywordElse,
        "elseif" => Token::KeywordElseif,
        "elsewhen" => Token::KeywordElsewhen,
        "encapsulated" => Token::KeywordEncapsulated,
        "end" => Token::KeywordEnd,
        "enumeration" => Token::KeywordEnumeration,
        "equation" => Token::KeywordEquation,
        "expandable" => Token::KeywordExpandable,
        "extends" => Token::KeywordExtends,
        "external" => Token::KeywordExternal,
        "final" => Token::KeywordFinal,
        "flow" => Token::KeywordFlow,
        "for" => Token::KeywordFor,
        "function" => Token::KeywordFunction,
        "if" => Token::KeywordIf,
        "import" => Token::KeywordImport,
        "impure" => Token::KeywordImpure,
        "in" => Token::KeywordIn,
        "initial" => Token::KeywordInitial,
        "inner" => Token::KeywordInner,
        "input" => Token::KeywordInput,
        "loop" => Token::KeywordLoop,
        "model" => Token::KeywordModel,
        "not" => Token::KeywordNot,
        "operator" => Token::KeywordOperator,
        "or" => Token::KeywordOr,
        "outer" => Token::KeywordOuter,
        "output" => Token::KeywordOutput,
        "package" => Token::KeywordPackage,
        "parameter" => Token::KeywordParameter,
        "partial" => Token::KeywordPartial,
        "protected" => Token::KeywordProtected,
        "public" => Token::KeywordPublic,
        "pure" => Token::KeywordPure,
        "record" => Token::KeywordRecord,
        "redeclare" => Token::KeywordRedeclare,
        "replaceable" => Token::KeywordReplaceable,
        "return" => Token::KeywordReturn,
        "stream" => Token::KeywordStream,
        "then" => Token::KeywordThen,
        "boolean" => Token::Boolean,
        "type" => Token::KeywordType,
        "when" => Token::KeywordWhen,
        "while" => Token::KeywordWhile,
        "within" => Token::KeywordWithin,

        // other lexical tokens
        "identifier" => Token::Identifier(<String>),
        "unsigned_integer" => Token::UnsignedInteger(<i64>),
        "unsigned_real" => Token::UnsignedReal(<f64>),
        "boolean" => Token::Boolean(<bool>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":=" => Token::Assign,
        "=" => Token::Equal,
        ";" => Token::Semicolon,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "^" => Token::OperatorExp,

        ".+" => Token::OperatorElemAdd,
        ".-" => Token::OperatorElemSub,
        ".*" => Token::OperatorElemMul,
        "./" => Token::OperatorElemDiv,
        ".^" => Token::OperatorElemExp,

        "<" => Token::OperatorLessThan,
        "<=" => Token::OperatorLessThanOrEqual,
        ">" => Token::OperatorGreaterThan,
        ">=" => Token::OperatorGreaterThanOrEqual,
        "==" => Token::OperatorEqual,
        "<>" => Token::OperatorNotEqual,
    }
}

// A.2.1 Stored Definition â€“ Within
// ============================================================================
// stored-definition :
//    [ within [ name ] ";" ]
//    { [ final ] class-definition ";" }
pub StoredDefinition: ast::StoredDefinition = {
    <classes:ClassDefinition*> => {
        ast::StoredDefinition{
            classes: classes
        }
    }
}

// A.2.2 Class Definition
// ============================================================================
// class-definition :
//    [ encapsulated ] class-prefixes class-specifier
// class-prefixes :
//    [ partial ]
//    ( class
//      | model
//      | [ operator ] record
//      | block
//      | [ expandable ] connector
//      | type
//      | package
//      | [ pure | impure ] [ operator ] function
//      | operator
//    )
pub ClassDefinition: ast::ClassDefinition = {
    <encapsulated: "encapsulated"?> <partial: "partial"?> <class_type: ClassType> <name:"identifier">
    <components: ComponentSection>
    <equations: EquationSection?>
    <algorithms: AlgorithmSection?>
    "end" "identifier" ";" => {
        ast::ClassDefinition {
            name: name,
            class_type: class_type,
            encapsulated: encapsulated.is_some(),
            partial: partial.is_some(),
            components: components,
            equations: equations,
            algorithms: algorithms
        }
    }
}

pub ClassType: ast::ClassType = {
    "model" => ast::ClassType::Model,
    "record" => ast::ClassType::Record,
    "operator" "record" => ast::ClassType::OperatorRecord,
    "block" => ast::ClassType::Block,
    "expandable" "connector" => ast::ClassType::ExpandableConnector,
    "connector" => ast::ClassType::Connector,
    "type" => ast::ClassType::Type,
    "package" => ast::ClassType::Package,
}

// TODO
// class-specifier :
//    long-class-specifier | short-class-specifier | der-class-specifier
// long-class-specifier :
//    IDENT description-string composition end IDENT
//    | extends IDENT [ class-modification ] description-string composition
//      end IDENT
// short-class-specifier :
//    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//    [ class-modification ] description
//    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description
// der-class-specifier :
//    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description
// base-prefix :
//    [ input | output ]
// enum-list :
//    enumeration-literal { "," enumeration-literal }
// enumeration-literal :
//    IDENT description
// composition :
//    element-list
//    { public element-list
//      | protected element-list
//      | equation-section
//      | algorithm-section
//    }
//    [ external [ language-specification ]
//      [ external-function-call ] [ annotation-clause ] ";"
//    ]
//    [ annotation-clause ";" ]
// language-specification :
//    STRING
// external-function-call :
//    [ component-reference "=" ]
//    IDENT "(" [ expression-list ] ")"
// element-list :
//    { element ";" }
// element :
//    import-clause
//    | extends-clause
//    | [ redeclare ]
//      [ final ]
//      [ inner ] [ outer ]
//      ( class-definition
//        | component-clause
//        | replaceable ( class-definition | component-clause )
//          [ constraining-clause description ]
//      )
// import-clause :
//    import
//    ( IDENT "=" name
//      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//    )
//    description
// import-list :
//    IDENT { "," IDENT }
//
pub ComponentSection: Vec<ast::ComponentDeclaration> = {
    <components:ComponentDeclaration*> => components
}

// A.2.3 Extends (TODO)
// ============================================================================
// extends-clause :
//    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]
// constraining-clause :
//    constrainedby type-specifier [ class-modification ]
// class-or-inheritance-modification :
//    "(" [ argument-or-inheritance-modification-list ] ")"
// argument-or-inheritance-modification-list :
//     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }
// inheritance-modification :
//     break ( connect-equation | IDENT )


// A.2.4 Component Clause
// ============================================================================
// component-clause :
//    type-prefix type-specifier [ array-subscripts ] component-list
// type-prefix :
//    [ flow | stream ]
//    [ discrete | parameter | constant ]
//    [ input | output ]
// component-list :
//    component-declaration { "," component-declaration }
// component-declaration :
//    declaration [ condition-attribute ] description
// condition-attribute :
//    if expression
// declaration :
//    IDENT [ array-subscripts ] [ modification ]
pub ComponentDeclaration: ast::ComponentDeclaration = {
    <class:"identifier"> <name:"identifier"> ";" => {
        ast::ComponentDeclaration{
            name,
            class
        }
    },
}

// A.2.5 Modification (TODO)
// ============================================================================
// modification :
//    class-modification [ "=" modification-expression ]
//    | "=" modification-expression
// modification-expression :
//    expression
//    | break
// class-modification :
//    "(" [ argument-list ] ")"
// argument-list :
//    argument { "," argument }
// argument :
//    element-modification-or-replaceable
//    | element-redeclaration
// element-modification-or-replaceable :
//    [ each ] [ final ] ( element-modification | element-replaceable )
// element-modification :
//    name [ modification ] description-string
// element-redeclaration :
//    redeclare [ each ] [ final ]
//    ( short-class-definition | component-clause1 | element-replaceable )
// element-replaceable :
//    replaceable ( short-class-definition | component-clause1 )
//    [ constraining-clause ]
// component-clause1 :
//    type-prefix type-specifier component-declaration1
// component-declaration1 :
//    declaration description
// short-class-definition :
//    class-prefixes short-class-specifier


// A.2.6 Equations
// ============================================================================
// equation-section :
//    [ initial ] equation { some-equation ";" }
pub EquationSection: Vec<ast::Equation> = {
    <_initial:"initial"?> "equation" <equations:Equation*> => equations
}
// algorithm-section :
//    [ initial ] algorithm { statement ";" }
pub AlgorithmSection: Vec<ast::Statement> = {
    <_initial:"initial"?> "algorithm" <statements:Statement*> => statements
}

// some-equation :
//    ( simple-expression "=" expression
//      | if-equation
//      | for-equation
//      | connect-equation
//      | when-equation
//      | component-reference function-call-args
//    )
//    description
pub Equation: ast::Equation = {
    <lhs:Expression> "=" <rhs:Expression> ";" => {
        ast::Equation::Simple {
            lhs,
            rhs
        }
    },
    "der" "(" <comp:ComponentReference> ")" "=" <rhs:Expression> ";" => {
        ast::Equation::Der {
            comp,
            rhs
        }
    },
}

// statement :
//    ( component-reference ( ":=" expression | function-call-args )
//      | "(" output-expression-list ")" ":="
//        component-reference function-call-args
//      | break
//      | return
//      | if-statement
//      | for-statement
//      | while-statement
//      | when-statement
//    )
//    description

pub Statement: ast::Statement = {
    <comp: ComponentReference> ":=" <expr:Expression> ";" => {
        ast::Statement::Assignment{
            comp,
            expr
        }
    },

}

// if-equation :
//    if expression then
//      { some-equation ";" }
//    { elseif expression then
//      { some-equation ";" }
//    }
//    [ else
//      { some-equation ";" }
//    ]
//    end if
pub IfEquation: ast::Equation = {
    "if" <if_cond:Expression> "then" <if_eqs:Equation*> ";"
    <else_if_blocks: ElseIfEquationBlock*>
    <else_eqs: ElseEquationBlock?>
    "end" "if" => {
        ast::Equation::If {
            if_cond, if_eqs,
            else_if_blocks,
            else_eqs,
        }
    }
}

pub ElseIfEquationBlock: ast::EquationBlock = {
    "elseif" <cond:Expression> "then" <eqs:Equation*> ";" => {
        ast::EquationBlock {
            cond, eqs
        }
    }
}

pub ElseEquationBlock: Vec<ast::Equation> = {
    "else" <eqs:Equation*> ";" => {
        eqs
    }
}

// if-statement :
//    if expression then
//      { statement ";" }
//    { elseif expression then
//      { statement ";" }
//    }
//    [ else
//      { statement ";" }
//    ]
//    end if
pub IfStatement: ast::Statement = {
    "if" <if_cond:Expression> "then" <if_eqs:Statement*> ";"
    <else_if_blocks: ElseIfStatementBlock*>
    <else_eqs: ElseStatementBlock?>
    "end" "if" => {
        ast::Statement::If {
            if_cond, if_eqs,
            else_if_blocks,
            else_eqs,
        }
    }
}

pub ElseIfStatementBlock: ast::StatementBlock = {
    "elseif" <cond:Expression> "then" <eqs:Statement*> ";" => {
        ast::StatementBlock {
            cond, eqs
        }
    }
}

pub ElseStatementBlock: Vec<ast::Statement> = {
    "else" <eqs:Statement*> ";" => {
        eqs
    }
}

// for-equation :
//    for for-indices loop
//      { some-equation ";" }
//    end for
// for-statement :
//    for for-indices loop
//      { statement ";" }
//    end for
// for-indices :
//    for-index { "," for-index }
// for-index :
//    IDENT [ in expression ]
// while-statement :
//    while expression loop
//      { statement ";" }
//    end while
// when-equation :
//    when expression then
//      { some-equation ";" }
//    { elsewhen expression then
//      { some-equation ";" }
//    }
//    end when
// when-statement :
//    when expression then
//      { statement ";" }
//    { elsewhen expression then
//      { statement ";" }
//    }
//    end when
// connect-equation :
//    connect "(" component-reference "," component-reference ")"


// A.2.7 Expressions
// ============================================================================
// expression :
//    simple-expression
//    | if expression then expression
//      { elseif expression then expression }
//      else expression
// simple-expression :
//    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]


pub Expression: Box<ast::Expression> = {
// primary :
//    UNSIGNED-NUMBER
//    | STRING
//    | false
//    | true
//    | ( component-reference | der | initial | pure ) function-call-args
//    | component-reference
//    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//    | "[" expression-list { ";" expression-list } "]"
//    | "{" array-arguments "}"
//    | end
    #[precedence(level="1")]
    <val:"unsigned_integer"> => {
        Box::new(ast::Expression::UnsignedInteger(val))
    },
    <val:"unsigned_real"> => {
        Box::new(ast::Expression::UnsignedReal(val))
    },
    <val:"boolean"> => {
        Box::new(ast::Expression::Boolean(val))
    },
    <comp:ComponentReference> => {
        Box::new(ast::Expression::Ref{comp})
    },
    "(" <Expression> ")",

// factor :
//    primary [ ( "^" | ".^" ) primary ]
    #[precedence(level="2")] #[assoc(side="left")]
    <lhs:Expression> "^" <rhs:Expression> => {
        Box::new(ast::Expression::Exp {
            lhs,
            rhs
        })
    },
    <lhs:Expression> ".^" <rhs:Expression> => {
        Box::new(ast::Expression::ElemExp {
            lhs,
            rhs
        })
    },
// term :
//    factor { mul-operator factor }
// mul-operator :
//    "*" | "/" | ".*" | "./"
    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Expression> "*" <rhs:Expression> => {
        Box::new(ast::Expression::Mul {
            lhs,
            rhs
        })
    },
    <lhs:Expression> ".*" <rhs:Expression> => {
        Box::new(ast::Expression::ElemMul {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "/" <rhs:Expression> => {
        Box::new(ast::Expression::Div {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "./" <rhs:Expression> => {
        Box::new(ast::Expression::ElemDiv {
            lhs,
            rhs
        })
    },

// arithmetic-expression :
//    [ add-operator ] term { add-operator term }
// add-operator :
//    "+" | "-" | ".+" | ".-"
    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:Expression> "+" <rhs:Expression> => {
        Box::new(ast::Expression::Add {
            lhs,
            rhs
        })
    },
    <lhs:Expression> ".+" <rhs:Expression> => {
        Box::new(ast::Expression::ElemAdd {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "-" <rhs:Expression> => {
        Box::new(ast::Expression::Sub {
            lhs,
            rhs
        })
    },
    <lhs:Expression> ".-" <rhs:Expression> => {
        Box::new(ast::Expression::ElemSub {
            lhs,
            rhs
        })
    },

// relation :
//    arithmetic-expression [ relational-operator arithmetic-expression ]
// relational-operator :
//    "<" | "<=" | ">" | ">=" | "==" | "<>#[assoc(side="left")]"
    #[precedence(level="5")] #[assoc(side="left")]
    <lhs:Expression> "<" <rhs:Expression> => {
        Box::new(ast::Expression::LessThan {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "<=" <rhs:Expression> => {
        Box::new(ast::Expression::LessThanOrEqual {
            lhs,
            rhs
        })
    },
    <lhs:Expression> ">=" <rhs:Expression> => {
        Box::new(ast::Expression::GreaterThanOrEqual {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "==" <rhs:Expression> => {
        Box::new(ast::Expression::Equal {
            lhs,
            rhs
        })
    },
    <lhs:Expression> "<>" <rhs:Expression> => {
        Box::new(ast::Expression::NotEqual {
            lhs,
            rhs
        })
    },

// logical-factor :
//    [ not ] relation
    #[precedence(level="6")]
    "not" <expr:Expression> => {
        Box::new(ast::Expression::Not {
            expr
        })
    },
// logical-expression :
//    logical-term { or logical-term }
    #[precedence(level="7")] #[assoc(side="left")]
    <lhs:Expression> "or" <rhs:Expression> => {
        Box::new(ast::Expression::Or {
            lhs,
            rhs
        })
    },
// logical-term :
//    logical-factor { and logical-factor }
    #[precedence(level="8")] #[assoc(side="left")]
    <lhs:Expression> "and" <rhs:Expression> => {
        Box::new(ast::Expression::And {
            lhs,
            rhs
        })
    },
}

// UNSIGNED-NUMBER :
//    UNSIGNED-INTEGER | UNSIGNED-REAL
// type-specifier :
//    ["."] name
// name :
//    IDENT { "." IDENT }
// component-reference :
//    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
pub ComponentReference: ast::ComponentReference = {
    <name:"identifier"> => {
        ast::ComponentReference{
            name
        }
    },
}
// result-reference :
//    component-reference
//    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"
// function-call-args :
//    "(" [ function-arguments ] ")"
// function-arguments :
//    expression [ "," function-arguments-non-first | for for-indices ]
//    | function-partial-application [ "," function-arguments-non-first ]
//    | named-arguments
// function-arguments-non-first :
//    function-argument [ "," function-arguments-non-first ]
//    | named-arguments
// array-arguments :
//    expression [ "," array-arguments-non-first | for for-indices ]
// array-arguments-non-first :
//    expression [ "," array-arguments-non-first ]
// named-arguments: named-argument [ "," named-arguments ]
// named-argument: IDENT "=" function-argument
// function-argument :
//    function-partial-application | expression
// function-partial-application :
//    function type-specifier "(" [ named-arguments ] ")"
// output-expression-list :
//    [ expression ] { "," [ expression ] }
// expression-list :
//    expression { "," expression }
// array-subscripts :
//    "[" subscript { "," subscript } "]"
// subscript :
//    ":" | expression
// description :
//    description-string [ annotation-clause ]
// description-string :
//    [ STRING { "+" STRING } ]
// annotation-clause :
//    annotation class-modification
