use crate::tokens::{Token, LexicalError};
use crate::ast;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        "algorithm" => Token::KeywordAlgorithm,
        "and" => Token::KeywordAnd,
        "annotation" => Token::KeywordAnnotation,
        "block" => Token::KeywordBlock,
        "break" => Token::KeywordBreak,
        "class" => Token::KeywordClass,
        "connect" => Token::KeywordConnect,
        "constant" => Token::KeywordConstant,
        "constrainedby" => Token::KeywordConstrainedby,
        "der" => Token::KeywordDer,
        "discrete" => Token::KeywordDiscrete,
        "each" => Token::KeywordEach,
        "else" => Token::KeywordElse,
        "elseif" => Token::KeywordElseif,
        "elsewhen" => Token::KeywordElsewhen,
        "encapsulated" => Token::KeywordEncapsulated,
        "end" => Token::KeywordEnd,
        "enumeration" => Token::KeywordEnumeration,
        "equation" => Token::KeywordEquation,
        "expandable" => Token::KeywordExpandable,
        "extends" => Token::KeywordExtends,
        "external" => Token::KeywordExternal,
        "false" => Token::KeywordFalse,
        "final" => Token::KeywordFinal,
        "flow" => Token::KeywordFlow,
        "for" => Token::KeywordFor,
        "function" => Token::KeywordFunction,
        "print" => Token::KeywordPrint,
        "identifier" => Token::Identifier(<String>),
        "int" => Token::Integer(<i64>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
    }
}

pub StoredDefinition: ast::StoredDefinition = {
    <classes:ClassDefinition*> => {
        ast::StoredDefinition{
            classes: classes
        }
    }
}

pub ClassDefinition: ast::ClassDefinition = {
    "block" <name:"identifier">
    <components: ComponentSection>
    <equations: EquationSection?>
    "end" "block" ";" => {
        ast::ClassDefinition {
            name: name,
            components: components,
            equations: equations,
        }
    }
}

pub ComponentSection: Vec<ast::ComponentDeclaration> = {
    <components:ComponentDeclaration*> => components
}

pub ComponentDeclaration: ast::ComponentDeclaration = {
    <class:"identifier"> <name:"identifier"> ";" => {
        ast::ComponentDeclaration{
            name,
            class
        }
    },
}

pub EquationSection: Vec<ast::Equation> = {
    "equation" <equations:Equation*> => equations
}

pub Script: Vec<ast::Statement> = {
    <stmts:Statement*> => stmts
}

pub Equation: ast::Equation = {
    <lhs:Expression> "=" <rhs:Expression> ";" => {
        ast::Equation::Simple {
            lhs,
            rhs
        }
    },
}

pub Statement: ast::Statement = {
    "block" <name:"identifier"> "=" <value:Expression> ";" => {
        ast::Statement::Variable{
            name,
            value
        }
    },
    "print" <value:Expression> ";" => {
        ast::Statement::Print {
            value
        }
    },
}

pub Expression: Box<ast::Expression> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="left")]
    <lhs:Expression> "*" <rhs:Expression> => {
        Box::new(ast::Expression::BinaryOperation {
            lhs,
            operator: ast::Operator::Mul,
            rhs
        })
    },

    <lhs:Expression> "/" <rhs:Expression> => {
        Box::new(ast::Expression::BinaryOperation {
            lhs,
            operator: ast::Operator::Div,
            rhs
        })
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Expression> "+" <rhs:Expression> => {
        Box::new(ast::Expression::BinaryOperation {
            lhs,
            operator: ast::Operator::Add,
            rhs
        })
    },

    <lhs:Expression> "-" <rhs:Expression> => {
        Box::new(ast::Expression::BinaryOperation {
            lhs,
            operator: ast::Operator::Sub,
            rhs
        })
    },
}

pub Term: Box<ast::Expression> = {
    <val:"int"> => {
        Box::new(ast::Expression::Integer(val))
    },
    <name:"identifier"> => {
        Box::new(ast::Expression::Variable(name))
    },
    "(" <Expression> ")",
}
