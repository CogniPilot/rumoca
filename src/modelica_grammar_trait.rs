// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ModelicaGrammarTrait {
    /// Semantic action for non-terminal 'algorithm'
    fn algorithm(&mut self, _arg: &Algorithm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'and'
    fn and(&mut self, _arg: &And) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'annotation'
    fn annotation(&mut self, _arg: &Annotation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'block'
    fn block(&mut self, _arg: &Block) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'break'
    fn r#break(&mut self, _arg: &Break) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class'
    fn class(&mut self, _arg: &Class) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'connect'
    fn connect(&mut self, _arg: &Connect) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'connector'
    fn connector(&mut self, _arg: &Connector) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'constant'
    fn constant(&mut self, _arg: &Constant) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'constrainedby'
    fn constrainedby(&mut self, _arg: &Constrainedby) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'der'
    fn der(&mut self, _arg: &Der) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'discrete'
    fn discrete(&mut self, _arg: &Discrete) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'each'
    fn each(&mut self, _arg: &Each) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'elseif'
    fn elseif(&mut self, _arg: &Elseif) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'elsewhen'
    fn elsewhen(&mut self, _arg: &Elsewhen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'encapsulated'
    fn encapsulated(&mut self, _arg: &Encapsulated) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'end'
    fn end(&mut self, _arg: &End) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'enumeration'
    fn enumeration(&mut self, _arg: &Enumeration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'equation'
    fn equation(&mut self, _arg: &Equation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'expandable'
    fn expandable(&mut self, _arg: &Expandable) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'extends'
    fn extends(&mut self, _arg: &Extends) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'external'
    fn external(&mut self, _arg: &External) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'false'
    fn r#false(&mut self, _arg: &False) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'final'
    fn r#final(&mut self, _arg: &Final) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'flow'
    fn flow(&mut self, _arg: &Flow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'for'
    fn r#for(&mut self, _arg: &For) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function'
    fn function(&mut self, _arg: &Function) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'if'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import'
    fn import(&mut self, _arg: &Import) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'impure'
    fn impure(&mut self, _arg: &Impure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'in'
    fn r#in(&mut self, _arg: &In) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'initial'
    fn initial(&mut self, _arg: &Initial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'inner'
    fn inner(&mut self, _arg: &Inner) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'loop'
    fn r#loop(&mut self, _arg: &Loop) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'model'
    fn model(&mut self, _arg: &Model) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'not'
    fn not(&mut self, _arg: &Not) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'operator'
    fn operator(&mut self, _arg: &Operator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'or'
    fn or(&mut self, _arg: &Or) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'outer'
    fn outer(&mut self, _arg: &Outer) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'package'
    fn package(&mut self, _arg: &Package) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'partial'
    fn partial(&mut self, _arg: &Partial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'protected'
    fn protected(&mut self, _arg: &Protected) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'public'
    fn public(&mut self, _arg: &Public) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'pure'
    fn pure(&mut self, _arg: &Pure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'record'
    fn record(&mut self, _arg: &Record) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'redeclare'
    fn redeclare(&mut self, _arg: &Redeclare) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'replaceable'
    fn replaceable(&mut self, _arg: &Replaceable) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'return'
    fn r#return(&mut self, _arg: &Return) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'stream'
    fn stream(&mut self, _arg: &Stream) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'then'
    fn then(&mut self, _arg: &Then) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'true'
    fn r#true(&mut self, _arg: &True) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'when'
    fn when(&mut self, _arg: &When) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'while'
    fn r#while(&mut self, _arg: &While) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'within'
    fn within(&mut self, _arg: &Within) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ident'
    fn ident(&mut self, _arg: &Ident) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'string'
    fn string(&mut self, _arg: &String) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_integer'
    fn unsigned_integer(&mut self, _arg: &UnsignedInteger) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_real'
    fn unsigned_real(&mut self, _arg: &UnsignedReal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'stored_definition'
    fn stored_definition(&mut self, _arg: &StoredDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_definition'
    fn class_definition(&mut self, _arg: &ClassDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_type'
    fn class_type(&mut self, _arg: &ClassType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_prefixes'
    fn class_prefixes(&mut self, _arg: &ClassPrefixes) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_specifier'
    fn class_specifier(&mut self, _arg: &ClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'long_class_specifier'
    fn long_class_specifier(&mut self, _arg: &LongClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'standard_class_specifier'
    fn standard_class_specifier(&mut self, _arg: &StandardClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'extends_class_specifier'
    fn extends_class_specifier(&mut self, _arg: &ExtendsClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'short_class_specifier'
    fn short_class_specifier(&mut self, _arg: &ShortClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type_class_specifier'
    fn type_class_specifier(&mut self, _arg: &TypeClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'enum_class_specifier'
    fn enum_class_specifier(&mut self, _arg: &EnumClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'der_class_specifier'
    fn der_class_specifier(&mut self, _arg: &DerClassSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'base_prefix'
    fn base_prefix(&mut self, _arg: &BasePrefix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'enum_list'
    fn enum_list(&mut self, _arg: &EnumList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'enumeration_literal'
    fn enumeration_literal(&mut self, _arg: &EnumerationLiteral) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'composition'
    fn composition(&mut self, _arg: &Composition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'language_specification'
    fn language_specification(&mut self, _arg: &LanguageSpecification) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'external_function_call'
    fn external_function_call(&mut self, _arg: &ExternalFunctionCall) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_list'
    fn element_list(&mut self, _arg: &ElementList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element'
    fn element(&mut self, _arg: &Element) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_definition'
    fn element_definition(&mut self, _arg: &ElementDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_replaceable_definition'
    fn element_replaceable_definition(
        &mut self,
        _arg: &ElementReplaceableDefinition,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import_clause'
    fn import_clause(&mut self, _arg: &ImportClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'import_list'
    fn import_list(&mut self, _arg: &ImportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'extends_clause'
    fn extends_clause(&mut self, _arg: &ExtendsClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'constraining_clause'
    fn constraining_clause(&mut self, _arg: &ConstrainingClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_or_inheritance_modification'
    fn class_or_inheritance_modification(
        &mut self,
        _arg: &ClassOrInheritanceModification,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'argument_or_inheritance_modification_list'
    fn argument_or_inheritance_modification_list(
        &mut self,
        _arg: &ArgumentOrInheritanceModificationList,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'inheritance_modification'
    fn inheritance_modification(&mut self, _arg: &InheritanceModification) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_clause'
    fn component_clause(&mut self, _arg: &ComponentClause) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type_prefix'
    fn type_prefix(&mut self, _arg: &TypePrefix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_list'
    fn component_list(&mut self, _arg: &ComponentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_declaration'
    fn component_declaration(&mut self, _arg: &ComponentDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'condition_attribute'
    fn condition_attribute(&mut self, _arg: &ConditionAttribute) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'declaration'
    fn declaration(&mut self, _arg: &Declaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'modification'
    fn modification(&mut self, _arg: &Modification) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'modification_expression'
    fn modification_expression(&mut self, _arg: &ModificationExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'class_modification'
    fn class_modification(&mut self, _arg: &ClassModification) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'argument_list'
    fn argument_list(&mut self, _arg: &ArgumentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'argument'
    fn argument(&mut self, _arg: &Argument) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_modification_or_replaceable'
    fn element_modification_or_replaceable(
        &mut self,
        _arg: &ElementModificationOrReplaceable,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_modification'
    fn element_modification(&mut self, _arg: &ElementModification) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_redeclaration'
    fn element_redeclaration(&mut self, _arg: &ElementRedeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'element_replaceable'
    fn element_replaceable(&mut self, _arg: &ElementReplaceable) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_clause1'
    fn component_clause1(&mut self, _arg: &ComponentClause1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_declaration1'
    fn component_declaration1(&mut self, _arg: &ComponentDeclaration1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'short_class_definition'
    fn short_class_definition(&mut self, _arg: &ShortClassDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'equation_section'
    fn equation_section(&mut self, _arg: &EquationSection) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'algorithm_section'
    fn algorithm_section(&mut self, _arg: &AlgorithmSection) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'some_equation_option'
    fn some_equation_option(&mut self, _arg: &SomeEquationOption) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'simple_equation'
    fn simple_equation(&mut self, _arg: &SimpleEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'some_equation'
    fn some_equation(&mut self, _arg: &SomeEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'statement_option'
    fn statement_option(&mut self, _arg: &StatementOption) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_statement'
    fn component_statement(&mut self, _arg: &ComponentStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_call_output_statement'
    fn function_call_output_statement(&mut self, _arg: &FunctionCallOutputStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'equation_block'
    fn equation_block(&mut self, _arg: &EquationBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'if_equation'
    fn if_equation(&mut self, _arg: &IfEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'statement_block'
    fn statement_block(&mut self, _arg: &StatementBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'if_statement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'for_equation'
    fn for_equation(&mut self, _arg: &ForEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'for_statement'
    fn for_statement(&mut self, _arg: &ForStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'for_indices'
    fn for_indices(&mut self, _arg: &ForIndices) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'for_index'
    fn for_index(&mut self, _arg: &ForIndex) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'while_statement'
    fn while_statement(&mut self, _arg: &WhileStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'when_equation'
    fn when_equation(&mut self, _arg: &WhenEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'when_statement'
    fn when_statement(&mut self, _arg: &WhenStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'connect_equation'
    fn connect_equation(&mut self, _arg: &ConnectEquation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'if_expression'
    fn if_expression(&mut self, _arg: &IfExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'simple_expression'
    fn simple_expression(&mut self, _arg: &SimpleExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_expression'
    fn logical_expression(&mut self, _arg: &LogicalExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_term'
    fn logical_term(&mut self, _arg: &LogicalTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'logical_factor'
    fn logical_factor(&mut self, _arg: &LogicalFactor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'relation'
    fn relation(&mut self, _arg: &Relation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'relational_operator'
    fn relational_operator(&mut self, _arg: &RelationalOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'arithmetic_expression'
    fn arithmetic_expression(&mut self, _arg: &ArithmeticExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'add_operator'
    fn add_operator(&mut self, _arg: &AddOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'term'
    fn term(&mut self, _arg: &Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'mul_operator'
    fn mul_operator(&mut self, _arg: &MulOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'primary'
    fn primary(&mut self, _arg: &Primary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_primary'
    fn component_primary(&mut self, _arg: &ComponentPrimary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'output_primary'
    fn output_primary(&mut self, _arg: &OutputPrimary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'range_primary'
    fn range_primary(&mut self, _arg: &RangePrimary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'array_primary'
    fn array_primary(&mut self, _arg: &ArrayPrimary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'global_function_call'
    fn global_function_call(&mut self, _arg: &GlobalFunctionCall) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'unsigned_number'
    fn unsigned_number(&mut self, _arg: &UnsignedNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'type_specifier'
    fn type_specifier(&mut self, _arg: &TypeSpecifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'name'
    fn name(&mut self, _arg: &Name) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_reference'
    fn component_reference(&mut self, _arg: &ComponentReference) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'component_ref_part'
    fn component_ref_part(&mut self, _arg: &ComponentRefPart) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_call_args'
    fn function_call_args(&mut self, _arg: &FunctionCallArgs) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_arguments'
    fn function_arguments(&mut self, _arg: &FunctionArguments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_arguments_non_first'
    fn function_arguments_non_first(&mut self, _arg: &FunctionArgumentsNonFirst) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'array_arguments'
    fn array_arguments(&mut self, _arg: &ArrayArguments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'array_arguments_non_first'
    fn array_arguments_non_first(&mut self, _arg: &ArrayArgumentsNonFirst) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'named_arguments'
    fn named_arguments(&mut self, _arg: &NamedArguments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'named_argument'
    fn named_argument(&mut self, _arg: &NamedArgument) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_argument'
    fn function_argument(&mut self, _arg: &FunctionArgument) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'function_partial_application'
    fn function_partial_application(&mut self, _arg: &FunctionPartialApplication) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'output_expression_list'
    fn output_expression_list(&mut self, _arg: &OutputExpressionList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'expression_list'
    fn expression_list(&mut self, _arg: &ExpressionList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'array_subscripts'
    fn array_subscripts(&mut self, _arg: &ArraySubscripts) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'subscript'
    fn subscript(&mut self, _arg: &Subscript) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'description'
    fn description(&mut self, _arg: &Description) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'description_string'
    fn description_string(&mut self, _arg: &DescriptionString) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'annotation_clause'
    fn annotation_clause(&mut self, _arg: &AnnotationClause) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'_>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 59
///
/// `ident: /[_a-zA-Z][_a-zA-Z0-9]*/@basic_ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentBasicIdent {
    pub basic_ident: crate::ir::ast::Token, /* [_a-zA-Z][_a-zA-Z0-9]* */
}

///
/// Type derived for production 60
///
/// `ident: /\'[_a-zA-Z0-9!#\$%&\(\)\*\+,-\.\/:;<>=\?@\[\]\^\{\}\|~ \"]*\'/@q_ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentQIdent {
    pub q_ident: crate::ir::ast::Token, /* \'[_a-zA-Z0-9!#\$%&\(\)\*\+,-\.\/:;<>=\?@\[\]\^\{\}\|~ \"]*\' */
}

///
/// Type derived for production 63
///
/// `unsigned_real: /[0-9]+\.[0-9]+/@decimal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealDecimal {
    pub decimal: crate::ir::ast::Token, /* [0-9]+\.[0-9]+ */
}

///
/// Type derived for production 64
///
/// `unsigned_real: /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealScientific {
    pub scientific: crate::ir::ast::Token, /* [0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)? */
}

///
/// Type derived for production 65
///
/// `unsigned_real: /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedRealScientific2 {
    pub scientific2: crate::ir::ast::Token, /* \.[0-9]+([eE][+-]?[0-9]+)? */
}

///
/// Type derived for production 78
///
/// `class_type: class;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeClass {
    pub class: Class,
}

///
/// Type derived for production 79
///
/// `class_type: model;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeModel {
    pub model: Model,
}

///
/// Type derived for production 80
///
/// `class_type: class_typeOpt /* Option */ record;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeClassTypeOptRecord {
    pub class_type_opt: Option<ClassTypeOpt>,
    pub record: Record,
}

///
/// Type derived for production 81
///
/// `class_type: block;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeBlock {
    pub block: Block,
}

///
/// Type derived for production 82
///
/// `class_type: class_typeOpt0 /* Option */ connector;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeClassTypeOpt0Connector {
    pub class_type_opt0: Option<ClassTypeOpt0>,
    pub connector: Connector,
}

///
/// Type derived for production 83
///
/// `class_type: type;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeType {
    pub r#type: Type,
}

///
/// Type derived for production 84
///
/// `class_type: package;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypePackage {
    pub package: Package,
}

///
/// Type derived for production 85
///
/// `class_type: class_typeOpt1 /* Option */ class_typeOpt2 /* Option */ function;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeClassTypeOpt1ClassTypeOpt2Function {
    pub class_type_opt1: Option<ClassTypeOpt1>,
    pub class_type_opt2: Option<ClassTypeOpt2>,
    pub function: Function,
}

///
/// Type derived for production 86
///
/// `class_type: operator;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOperator {
    pub operator: Operator,
}

///
/// Type derived for production 90
///
/// `class_typeOpt1Group: pure;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt1GroupPure {
    pub pure: Pure,
}

///
/// Type derived for production 91
///
/// `class_typeOpt1Group: impure;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt1GroupImpure {
    pub impure: Impure,
}

///
/// Type derived for production 100
///
/// `class_specifier: long_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassSpecifierLongClassSpecifier {
    pub long_class_specifier: LongClassSpecifier,
}

///
/// Type derived for production 101
///
/// `class_specifier: short_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassSpecifierShortClassSpecifier {
    pub short_class_specifier: ShortClassSpecifier,
}

///
/// Type derived for production 102
///
/// `class_specifier: der_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassSpecifierDerClassSpecifier {
    pub der_class_specifier: DerClassSpecifier,
}

///
/// Type derived for production 103
///
/// `long_class_specifier: standard_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LongClassSpecifierStandardClassSpecifier {
    pub standard_class_specifier: StandardClassSpecifier,
}

///
/// Type derived for production 104
///
/// `long_class_specifier: extends_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LongClassSpecifierExtendsClassSpecifier {
    pub extends_class_specifier: ExtendsClassSpecifier,
}

///
/// Type derived for production 109
///
/// `short_class_specifier: type_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ShortClassSpecifierTypeClassSpecifier {
    pub type_class_specifier: Box<TypeClassSpecifier>,
}

///
/// Type derived for production 110
///
/// `short_class_specifier: enum_class_specifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ShortClassSpecifierEnumClassSpecifier {
    pub enum_class_specifier: Box<EnumClassSpecifier>,
}

///
/// Type derived for production 117
///
/// `enum_class_specifierGroup: enum_class_specifierOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumClassSpecifierGroupEnumClassSpecifierOpt {
    pub enum_class_specifier_opt: Option<Box<EnumClassSpecifierOpt>>,
}

///
/// Type derived for production 118
///
/// `enum_class_specifierGroup: ':'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumClassSpecifierGroupColon {}

///
/// Type derived for production 126
///
/// `base_prefixOptGroup: input;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasePrefixOptGroupInput {
    pub input: Input,
}

///
/// Type derived for production 127
///
/// `base_prefixOptGroup: output;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasePrefixOptGroupOutput {
    pub output: Output,
}

///
/// Type derived for production 135
///
/// `compositionListGroup: public element_list;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupPublicElementList {
    pub public: Public,
    pub element_list: crate::modelica_grammar::ElementList,
}

///
/// Type derived for production 136
///
/// `compositionListGroup: protected element_list;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupProtectedElementList {
    pub protected: Protected,
    pub element_list: crate::modelica_grammar::ElementList,
}

///
/// Type derived for production 137
///
/// `compositionListGroup: equation_section;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupEquationSection {
    pub equation_section: crate::modelica_grammar::EquationSection,
}

///
/// Type derived for production 138
///
/// `compositionListGroup: algorithm_section;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionListGroupAlgorithmSection {
    pub algorithm_section: crate::modelica_grammar::AlgorithmSection,
}

///
/// Type derived for production 159
///
/// `element: import_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementImportClause {
    pub import_clause: ImportClause,
}

///
/// Type derived for production 160
///
/// `element: extends_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementExtendsClause {
    pub extends_clause: ExtendsClause,
}

///
/// Type derived for production 161
///
/// `element: element_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementElementDefinition {
    pub element_definition: ElementDefinition,
}

///
/// Type derived for production 162
///
/// `element: element_replaceable_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementElementReplaceableDefinition {
    pub element_replaceable_definition: ElementReplaceableDefinition,
}

///
/// Type derived for production 164
///
/// `element_definitionGroup: class_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionGroupClassDefinition {
    pub class_definition: crate::ir::ast::ClassDefinition,
}

///
/// Type derived for production 165
///
/// `element_definitionGroup: component_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionGroupComponentClause {
    pub component_clause: ComponentClause,
}

///
/// Type derived for production 175
///
/// `element_replaceable_definitionGroup: class_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableDefinitionGroupClassDefinition {
    pub class_definition: crate::ir::ast::ClassDefinition,
}

///
/// Type derived for production 176
///
/// `element_replaceable_definitionGroup: component_clause;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableDefinitionGroupComponentClause {
    pub component_clause: ComponentClause,
}

///
/// Type derived for production 180
///
/// `import_clauseGroup: ident '='^ /* Clipped */ name;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseGroupIdentEquName {
    pub ident: crate::ir::ast::Token,
    pub name: crate::ir::ast::Name,
}

///
/// Type derived for production 181
///
/// `import_clauseGroup: name import_clauseOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseGroupNameImportClauseOpt {
    pub name: crate::ir::ast::Name,
    pub import_clause_opt: Option<ImportClauseOpt>,
}

///
/// Type derived for production 183
///
/// `import_clauseOptGroup: '.*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupDotStar {
    pub dot_star: crate::ir::ast::Token, /* .* */
}

///
/// Type derived for production 184
///
/// `import_clauseOptGroup: '.' import_clauseOptGroupGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupDotImportClauseOptGroupGroup {
    pub dot: crate::ir::ast::Token, /* . */
    pub import_clause_opt_group_group: ImportClauseOptGroupGroup,
}

///
/// Type derived for production 185
///
/// `import_clauseOptGroupGroup: '*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupGroupStar {
    pub star: crate::ir::ast::Token, /* * */
}

///
/// Type derived for production 186
///
/// `import_clauseOptGroupGroup: '{'^ /* Clipped */ import_list '}'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOptGroupGroupLBraceImportListRBrace {
    pub import_list: ImportList,
}

///
/// Type derived for production 203
///
/// `argument_or_inheritance_modification_listGroup: argument;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationListGroupArgument {
    pub argument: crate::ir::ast::Expression,
}

///
/// Type derived for production 204
///
/// `argument_or_inheritance_modification_listGroup: inheritance_modification;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationListGroupInheritanceModification {
    pub inheritance_modification: InheritanceModification,
}

///
/// Type derived for production 206
///
/// `argument_or_inheritance_modification_listListGroup: argument;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationListListGroupArgument {
    pub argument: crate::ir::ast::Expression,
}

///
/// Type derived for production 207
///
/// `argument_or_inheritance_modification_listListGroup: inheritance_modification;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationListListGroupInheritanceModification {
    pub inheritance_modification: InheritanceModification,
}

///
/// Type derived for production 210
///
/// `inheritance_modificationGroup: connect_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InheritanceModificationGroupConnectEquation {
    pub connect_equation: ConnectEquation,
}

///
/// Type derived for production 211
///
/// `inheritance_modificationGroup: ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InheritanceModificationGroupIdent {
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for production 217
///
/// `type_prefixOpt1Group: input;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1GroupInput {
    pub input: Input,
}

///
/// Type derived for production 218
///
/// `type_prefixOpt1Group: output;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1GroupOutput {
    pub output: Output,
}

///
/// Type derived for production 221
///
/// `type_prefixOpt0Group: discrete;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupDiscrete {
    pub discrete: Discrete,
}

///
/// Type derived for production 222
///
/// `type_prefixOpt0Group: parameter;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupParameter {
    pub parameter: Parameter,
}

///
/// Type derived for production 223
///
/// `type_prefixOpt0Group: constant;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0GroupConstant {
    pub constant: Constant,
}

///
/// Type derived for production 226
///
/// `type_prefixOptGroup: flow;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOptGroupFlow {
    pub flow: Flow,
}

///
/// Type derived for production 227
///
/// `type_prefixOptGroup: stream;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOptGroupStream {
    pub stream: Stream,
}

///
/// Type derived for production 241
///
/// `modification: class_modification modificationOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModificationClassModificationModificationOpt {
    pub class_modification: Box<ClassModification>,
    pub modification_opt: Option<ModificationOpt>,
}

///
/// Type derived for production 242
///
/// `modification: '='^ /* Clipped */ modification_expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModificationEquModificationExpression {
    pub modification_expression: ModificationExpression,
}

///
/// Type derived for production 245
///
/// `modification_expression: expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModificationExpressionExpression {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for production 246
///
/// `modification_expression: break;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModificationExpressionBreak {
    pub r#break: Break,
}

///
/// Type derived for production 253
///
/// `argument: element_modification_or_replaceable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentElementModificationOrReplaceable {
    pub element_modification_or_replaceable: Box<ElementModificationOrReplaceable>,
}

///
/// Type derived for production 254
///
/// `argument: element_redeclaration;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentElementRedeclaration {
    pub element_redeclaration: Box<ElementRedeclaration>,
}

///
/// Type derived for production 256
///
/// `element_modification_or_replaceableGroup: element_modification;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOrReplaceableGroupElementModification {
    pub element_modification: Box<ElementModification>,
}

///
/// Type derived for production 257
///
/// `element_modification_or_replaceableGroup: element_replaceable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOrReplaceableGroupElementReplaceable {
    pub element_replaceable: Box<ElementReplaceable>,
}

///
/// Type derived for production 266
///
/// `element_redeclarationGroup: short_class_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclarationGroupShortClassDefinition {
    pub short_class_definition: Box<ShortClassDefinition>,
}

///
/// Type derived for production 267
///
/// `element_redeclarationGroup: component_clause1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclarationGroupComponentClause1 {
    pub component_clause1: Box<ComponentClause1>,
}

///
/// Type derived for production 268
///
/// `element_redeclarationGroup: element_replaceable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclarationGroupElementReplaceable {
    pub element_replaceable: Box<ElementReplaceable>,
}

///
/// Type derived for production 274
///
/// `element_replaceableGroup: short_class_definition;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableGroupShortClassDefinition {
    pub short_class_definition: Box<ShortClassDefinition>,
}

///
/// Type derived for production 275
///
/// `element_replaceableGroup: component_clause1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableGroupComponentClause1 {
    pub component_clause1: Box<ComponentClause1>,
}

///
/// Type derived for production 291
///
/// `some_equation_option: simple_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquationOptionSimpleEquation {
    pub simple_equation: SimpleEquation,
}

///
/// Type derived for production 292
///
/// `some_equation_option: if_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquationOptionIfEquation {
    pub if_equation: IfEquation,
}

///
/// Type derived for production 293
///
/// `some_equation_option: for_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquationOptionForEquation {
    pub for_equation: ForEquation,
}

///
/// Type derived for production 294
///
/// `some_equation_option: connect_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquationOptionConnectEquation {
    pub connect_equation: ConnectEquation,
}

///
/// Type derived for production 295
///
/// `some_equation_option: when_equation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquationOptionWhenEquation {
    pub when_equation: WhenEquation,
}

///
/// Type derived for production 300
///
/// `statement_option: component_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionComponentStatement {
    pub component_statement: ComponentStatement,
}

///
/// Type derived for production 301
///
/// `statement_option: function_call_output_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionFunctionCallOutputStatement {
    pub function_call_output_statement: FunctionCallOutputStatement,
}

///
/// Type derived for production 302
///
/// `statement_option: break;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionBreak {
    pub r#break: Break,
}

///
/// Type derived for production 303
///
/// `statement_option: return;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionReturn {
    pub r#return: Return,
}

///
/// Type derived for production 304
///
/// `statement_option: if_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionIfStatement {
    pub if_statement: IfStatement,
}

///
/// Type derived for production 305
///
/// `statement_option: for_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionForStatement {
    pub for_statement: ForStatement,
}

///
/// Type derived for production 306
///
/// `statement_option: while_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionWhileStatement {
    pub while_statement: WhileStatement,
}

///
/// Type derived for production 307
///
/// `statement_option: when_statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptionWhenStatement {
    pub when_statement: WhenStatement,
}

///
/// Type derived for production 309
///
/// `component_statementGroup: ':='^ /* Clipped */ expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentStatementGroupColonEquExpression {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for production 310
///
/// `component_statementGroup: function_call_args;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentStatementGroupFunctionCallArgs {
    pub function_call_args: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for production 355
///
/// `expression: simple_expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionSimpleExpression {
    pub simple_expression: Box<crate::ir::ast::Expression>,
}

///
/// Type derived for production 356
///
/// `expression: if_expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIfExpression {
    pub if_expression: Box<IfExpression>,
}

///
/// Type derived for production 377
///
/// `relational_operator: '<';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLT {
    pub l_t: crate::ir::ast::Token, /* < */
}

///
/// Type derived for production 378
///
/// `relational_operator: '<=';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLTEqu {
    pub l_t_equ: crate::ir::ast::Token, /* <= */
}

///
/// Type derived for production 379
///
/// `relational_operator: '>';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorGT {
    pub g_t: crate::ir::ast::Token, /* > */
}

///
/// Type derived for production 380
///
/// `relational_operator: '>=';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorGTEqu {
    pub g_t_equ: crate::ir::ast::Token, /* >= */
}

///
/// Type derived for production 381
///
/// `relational_operator: '==';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorEquEqu {
    pub equ_equ: crate::ir::ast::Token, /* == */
}

///
/// Type derived for production 382
///
/// `relational_operator: '<>';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOperatorLTGT {
    pub l_t_g_t: crate::ir::ast::Token, /* <> */
}

///
/// Type derived for production 388
///
/// `add_operator: '+';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorPlus {
    pub plus: crate::ir::ast::Token, /* + */
}

///
/// Type derived for production 389
///
/// `add_operator: '-';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorMinus {
    pub minus: crate::ir::ast::Token, /* - */
}

///
/// Type derived for production 390
///
/// `add_operator: '.+';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorDotPlus {
    pub dot_plus: crate::ir::ast::Token, /* .+ */
}

///
/// Type derived for production 391
///
/// `add_operator: '.-';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOperatorDotMinus {
    pub dot_minus: crate::ir::ast::Token, /* .- */
}

///
/// Type derived for production 395
///
/// `mul_operator: '*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorStar {
    pub star: crate::ir::ast::Token, /* * */
}

///
/// Type derived for production 396
///
/// `mul_operator: '/';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorSlash {
    pub slash: crate::ir::ast::Token, /* / */
}

///
/// Type derived for production 397
///
/// `mul_operator: '.*';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorDotStar {
    pub dot_star: crate::ir::ast::Token, /* .* */
}

///
/// Type derived for production 398
///
/// `mul_operator: './';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOperatorDotSlash {
    pub dot_slash: crate::ir::ast::Token, /* ./ */
}

///
/// Type derived for production 401
///
/// `factorListGroup: '^';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorListGroupCircumflex {
    pub circumflex: crate::ir::ast::Token, /* ^ */
}

///
/// Type derived for production 402
///
/// `factorListGroup: '.^';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorListGroupDotCircumflex {
    pub dot_circumflex: crate::ir::ast::Token, /* .^ */
}

///
/// Type derived for production 404
///
/// `primary: unsigned_number;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryUnsignedNumber {
    pub unsigned_number: UnsignedNumber,
}

///
/// Type derived for production 405
///
/// `primary: string;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryString {
    pub string: crate::ir::ast::Token,
}

///
/// Type derived for production 406
///
/// `primary: false;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryFalse {
    pub r#false: False,
}

///
/// Type derived for production 407
///
/// `primary: true;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryTrue {
    pub r#true: True,
}

///
/// Type derived for production 408
///
/// `primary: global_function_call;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryGlobalFunctionCall {
    pub global_function_call: Box<GlobalFunctionCall>,
}

///
/// Type derived for production 409
///
/// `primary: component_primary;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryComponentPrimary {
    pub component_primary: Box<ComponentPrimary>,
}

///
/// Type derived for production 410
///
/// `primary: output_primary;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryOutputPrimary {
    pub output_primary: Box<OutputPrimary>,
}

///
/// Type derived for production 411
///
/// `primary: range_primary;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryRangePrimary {
    pub range_primary: Box<RangePrimary>,
}

///
/// Type derived for production 412
///
/// `primary: array_primary;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryArrayPrimary {
    pub array_primary: Box<ArrayPrimary>,
}

///
/// Type derived for production 413
///
/// `primary: end;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryEnd {
    pub end: End,
}

///
/// Type derived for production 419
///
/// `output_primaryOptGroup: array_subscripts;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputPrimaryOptGroupArraySubscripts {
    pub array_subscripts: Box<crate::modelica_grammar::ArraySubscripts>,
}

///
/// Type derived for production 420
///
/// `output_primaryOptGroup: '.'^ /* Clipped */ ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputPrimaryOptGroupDotIdent {
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for production 427
///
/// `global_function_callGroup: der;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GlobalFunctionCallGroupDer {
    pub der: Der,
}

///
/// Type derived for production 428
///
/// `global_function_callGroup: initial;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GlobalFunctionCallGroupInitial {
    pub initial: Initial,
}

///
/// Type derived for production 429
///
/// `global_function_callGroup: pure;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GlobalFunctionCallGroupPure {
    pub pure: Pure,
}

///
/// Type derived for production 430
///
/// `unsigned_number: unsigned_integer;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedNumberUnsignedInteger {
    pub unsigned_integer: crate::ir::ast::Token,
}

///
/// Type derived for production 431
///
/// `unsigned_number: unsigned_real;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedNumberUnsignedReal {
    pub unsigned_real: crate::ir::ast::Token,
}

///
/// Type derived for production 451
///
/// `function_arguments: expression function_argumentsOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsExpressionFunctionArgumentsOpt {
    pub expression: Box<crate::ir::ast::Expression>,
    pub function_arguments_opt: Option<Box<FunctionArgumentsOpt>>,
}

///
/// Type derived for production 452
///
/// `function_arguments: function_partial_application function_argumentsOpt0 /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsFunctionPartialApplicationFunctionArgumentsOpt0 {
    pub function_partial_application: Box<FunctionPartialApplication>,
    pub function_arguments_opt0: Option<Box<FunctionArgumentsOpt0>>,
}

///
/// Type derived for production 453
///
/// `function_arguments: named_arguments;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsNamedArguments {
    pub named_arguments: Box<NamedArguments>,
}

///
/// Type derived for production 457
///
/// `function_argumentsOptGroup: ','^ /* Clipped */ function_arguments_non_first;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsOptGroupCommaFunctionArgumentsNonFirst {
    pub function_arguments_non_first: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for production 458
///
/// `function_argumentsOptGroup: for for_indices;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsOptGroupForForIndices {
    pub r#for: For,
    pub for_indices: ForIndices,
}

///
/// Type derived for production 460
///
/// `function_arguments_non_first: function_argument function_arguments_non_firstOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsNonFirstFunctionArgumentFunctionArgumentsNonFirstOpt {
    pub function_argument: crate::ir::ast::Expression,
    pub function_arguments_non_first_opt: Option<Box<FunctionArgumentsNonFirstOpt>>,
}

///
/// Type derived for production 461
///
/// `function_arguments_non_first: named_arguments;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsNonFirstNamedArguments {
    pub named_arguments: NamedArguments,
}

///
/// Type derived for production 466
///
/// `array_argumentsOptGroup: ','^ /* Clipped */ array_arguments_non_first;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArgumentsOptGroupCommaArrayArgumentsNonFirst {
    pub array_arguments_non_first: Box<ArrayArgumentsNonFirst>,
}

///
/// Type derived for production 467
///
/// `array_argumentsOptGroup: for for_indices;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArgumentsOptGroupForForIndices {
    pub r#for: For,
    pub for_indices: Box<ForIndices>,
}

///
/// Type derived for production 476
///
/// `function_argument: function_partial_application;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentFunctionPartialApplication {
    pub function_partial_application: Box<FunctionPartialApplication>,
}

///
/// Type derived for production 477
///
/// `function_argument: expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentExpression {
    pub expression: Box<crate::ir::ast::Expression>,
}

///
/// Type derived for production 494
///
/// `subscript: ':';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubscriptColon {
    pub colon: crate::ir::ast::Token, /* : */
}

///
/// Type derived for production 495
///
/// `subscript: expression;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubscriptExpression {
    pub expression: Box<crate::ir::ast::Expression>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal add_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOperator {
    Plus(AddOperatorPlus),
    Minus(AddOperatorMinus),
    DotPlus(AddOperatorDotPlus),
    DotMinus(AddOperatorDotMinus),
}

///
/// Type derived for non-terminal algorithm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Algorithm {
    pub algorithm: crate::ir::ast::Token, /* algorithm */
}

///
/// Type derived for non-terminal algorithm_section
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSection {
    pub algorithm_section_opt: Option<AlgorithmSectionOpt>,
    pub algorithm_section_list: Vec<AlgorithmSectionList>,
}

///
/// Type derived for non-terminal algorithm_sectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSectionList {
    pub statement: crate::ir::ast::Statement,
}

///
/// Type derived for non-terminal algorithm_sectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlgorithmSectionOpt {}

///
/// Type derived for non-terminal and
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct And {
    pub and: crate::ir::ast::Token, /* and */
}

///
/// Type derived for non-terminal annotation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Annotation {
    pub annotation: crate::ir::ast::Token, /* annotation */
}

///
/// Type derived for non-terminal annotation_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AnnotationClause {
    pub annotation: Annotation,
    pub class_modification: Box<ClassModification>,
}

///
/// Type derived for non-terminal argument
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Argument {
    ElementModificationOrReplaceable(Box<ArgumentElementModificationOrReplaceable>),
    ElementRedeclaration(Box<ArgumentElementRedeclaration>),
}

///
/// Type derived for non-terminal argument_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentList {
    pub argument: Box<crate::ir::ast::Expression>,
    pub argument_list_list: Vec<ArgumentListList>,
}

///
/// Type derived for non-terminal argument_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentListList {
    pub argument: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal argument_or_inheritance_modification_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationList {
    pub argument_or_inheritance_modification_list_group: ArgumentOrInheritanceModificationListGroup,
    pub argument_or_inheritance_modification_list_list:
        Vec<ArgumentOrInheritanceModificationListList>,
}

///
/// Type derived for non-terminal argument_or_inheritance_modification_listGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArgumentOrInheritanceModificationListGroup {
    Argument(ArgumentOrInheritanceModificationListGroupArgument),
    InheritanceModification(ArgumentOrInheritanceModificationListGroupInheritanceModification),
}

///
/// Type derived for non-terminal argument_or_inheritance_modification_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentOrInheritanceModificationListList {
    pub argument_or_inheritance_modification_list_list_group:
        ArgumentOrInheritanceModificationListListGroup,
}

///
/// Type derived for non-terminal argument_or_inheritance_modification_listListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArgumentOrInheritanceModificationListListGroup {
    Argument(ArgumentOrInheritanceModificationListListGroupArgument),
    InheritanceModification(ArgumentOrInheritanceModificationListListGroupInheritanceModification),
}

///
/// Type derived for non-terminal arithmetic_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpression {
    pub arithmetic_expression_opt: Option<ArithmeticExpressionOpt>,
    pub term: Box<crate::ir::ast::Expression>,
    pub arithmetic_expression_list: Vec<ArithmeticExpressionList>,
}

///
/// Type derived for non-terminal arithmetic_expressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpressionList {
    pub add_operator: AddOperator,
    pub term: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal arithmetic_expressionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArithmeticExpressionOpt {
    pub add_operator: AddOperator,
}

///
/// Type derived for non-terminal array_arguments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArguments {
    pub expression: Box<crate::ir::ast::Expression>,
    pub array_arguments_opt: Option<Box<ArrayArgumentsOpt>>,
}

///
/// Type derived for non-terminal array_argumentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArgumentsOpt {
    pub array_arguments_opt_group: ArrayArgumentsOptGroup,
}

///
/// Type derived for non-terminal array_argumentsOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayArgumentsOptGroup {
    CommaArrayArgumentsNonFirst(ArrayArgumentsOptGroupCommaArrayArgumentsNonFirst),
    ForForIndices(ArrayArgumentsOptGroupForForIndices),
}

///
/// Type derived for non-terminal array_arguments_non_first
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArgumentsNonFirst {
    pub expression: crate::ir::ast::Expression,
    pub array_arguments_non_first_opt: Option<Box<ArrayArgumentsNonFirstOpt>>,
}

///
/// Type derived for non-terminal array_arguments_non_firstOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayArgumentsNonFirstOpt {
    pub array_arguments_non_first: ArrayArgumentsNonFirst,
}

///
/// Type derived for non-terminal array_primary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayPrimary {
    pub array_arguments: Box<ArrayArguments>,
}

///
/// Type derived for non-terminal array_subscripts
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySubscripts {
    pub subscript: Box<crate::ir::ast::Subscript>,
    pub array_subscripts_list: Vec<ArraySubscriptsList>,
}

///
/// Type derived for non-terminal array_subscriptsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySubscriptsList {
    pub subscript: crate::ir::ast::Subscript,
}

///
/// Type derived for non-terminal base_prefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasePrefix {
    pub base_prefix_opt: Option<BasePrefixOpt>,
}

///
/// Type derived for non-terminal base_prefixOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasePrefixOpt {
    pub base_prefix_opt_group: BasePrefixOptGroup,
}

///
/// Type derived for non-terminal base_prefixOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasePrefixOptGroup {
    Input(BasePrefixOptGroupInput),
    Output(BasePrefixOptGroupOutput),
}

///
/// Type derived for non-terminal block
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Block {
    pub block: crate::ir::ast::Token, /* block */
}

///
/// Type derived for non-terminal break
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Break {
    pub r#break: crate::ir::ast::Token, /* break */
}

///
/// Type derived for non-terminal class
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Class {
    pub class: crate::ir::ast::Token, /* class */
}

///
/// Type derived for non-terminal class_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassDefinition {
    pub class_definition_opt: Option<ClassDefinitionOpt>,
    pub class_prefixes: ClassPrefixes,
    pub class_specifier: ClassSpecifier,
}

///
/// Type derived for non-terminal class_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassDefinitionOpt {
    pub encapsulated: Encapsulated,
}

///
/// Type derived for non-terminal class_modification
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassModification {
    pub class_modification_opt: Option<Box<ClassModificationOpt>>,
}

///
/// Type derived for non-terminal class_modificationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassModificationOpt {
    pub argument_list: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal class_or_inheritance_modification
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassOrInheritanceModification {
    pub class_or_inheritance_modification_opt: Option<ClassOrInheritanceModificationOpt>,
}

///
/// Type derived for non-terminal class_or_inheritance_modificationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassOrInheritanceModificationOpt {
    pub argument_or_inheritance_modification_list: ArgumentOrInheritanceModificationList,
}

///
/// Type derived for non-terminal class_prefixes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixes {
    pub class_prefixes_opt: Option<ClassPrefixesOpt>,
    pub class_type: ClassType,
}

///
/// Type derived for non-terminal class_prefixesOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassPrefixesOpt {
    pub partial: Partial,
}

///
/// Type derived for non-terminal class_specifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ClassSpecifier {
    LongClassSpecifier(ClassSpecifierLongClassSpecifier),
    ShortClassSpecifier(ClassSpecifierShortClassSpecifier),
    DerClassSpecifier(ClassSpecifierDerClassSpecifier),
}

///
/// Type derived for non-terminal class_type
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ClassType {
    Class(ClassTypeClass),
    Model(ClassTypeModel),
    ClassTypeOptRecord(ClassTypeClassTypeOptRecord),
    Block(ClassTypeBlock),
    ClassTypeOpt0Connector(ClassTypeClassTypeOpt0Connector),
    Type(ClassTypeType),
    Package(ClassTypePackage),
    ClassTypeOpt1ClassTypeOpt2Function(ClassTypeClassTypeOpt1ClassTypeOpt2Function),
    Operator(ClassTypeOperator),
}

///
/// Type derived for non-terminal class_typeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt {
    pub operator: Operator,
}

///
/// Type derived for non-terminal class_typeOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt0 {
    pub expandable: Expandable,
}

///
/// Type derived for non-terminal class_typeOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt1 {
    pub class_type_opt1_group: ClassTypeOpt1Group,
}

///
/// Type derived for non-terminal class_typeOpt1Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ClassTypeOpt1Group {
    Pure(ClassTypeOpt1GroupPure),
    Impure(ClassTypeOpt1GroupImpure),
}

///
/// Type derived for non-terminal class_typeOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ClassTypeOpt2 {
    pub operator: Operator,
}

///
/// Type derived for non-terminal component_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentClause {
    pub type_prefix: TypePrefix,
    pub type_specifier: TypeSpecifier,
    pub component_clause_opt: Option<ComponentClauseOpt>,
    pub component_list: crate::modelica_grammar::ComponentList,
}

///
/// Type derived for non-terminal component_clause1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentClause1 {
    pub type_prefix: TypePrefix,
    pub type_specifier: TypeSpecifier,
    pub component_declaration1: ComponentDeclaration1,
}

///
/// Type derived for non-terminal component_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentClauseOpt {
    pub array_subscripts: crate::modelica_grammar::ArraySubscripts,
}

///
/// Type derived for non-terminal component_declaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentDeclaration {
    pub declaration: Declaration,
    pub component_declaration_opt: Option<ComponentDeclarationOpt>,
    pub description: Description,
}

///
/// Type derived for non-terminal component_declaration1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentDeclaration1 {
    pub declaration: Declaration,
    pub description: Description,
}

///
/// Type derived for non-terminal component_declarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentDeclarationOpt {
    pub condition_attribute: ConditionAttribute,
}

///
/// Type derived for non-terminal component_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentList {
    pub component_declaration: ComponentDeclaration,
    pub component_list_list: Vec<ComponentListList>,
}

///
/// Type derived for non-terminal component_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentListList {
    pub component_declaration: ComponentDeclaration,
}

///
/// Type derived for non-terminal component_primary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentPrimary {
    pub component_reference: Box<crate::ir::ast::ComponentReference>,
    pub component_primary_opt: Option<Box<ComponentPrimaryOpt>>,
}

///
/// Type derived for non-terminal component_primaryOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentPrimaryOpt {
    pub function_call_args: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal component_ref_part
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentRefPart {
    pub ident: crate::ir::ast::Token,
    pub component_ref_part_opt: Option<ComponentRefPartOpt>,
}

///
/// Type derived for non-terminal component_ref_partOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentRefPartOpt {
    pub array_subscripts: crate::modelica_grammar::ArraySubscripts,
}

///
/// Type derived for non-terminal component_reference
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReference {
    pub component_reference_opt: Option<ComponentReferenceOpt>,
    pub ident: crate::ir::ast::Token,
    pub component_reference_opt0: Option<Box<ComponentReferenceOpt0>>,
    pub component_reference_list: Vec<ComponentReferenceList>,
}

///
/// Type derived for non-terminal component_referenceList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceList {
    pub component_ref_part: crate::ir::ast::ComponentRefPart,
}

///
/// Type derived for non-terminal component_referenceOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceOpt {}

///
/// Type derived for non-terminal component_referenceOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentReferenceOpt0 {
    pub array_subscripts: crate::modelica_grammar::ArraySubscripts,
}

///
/// Type derived for non-terminal component_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ComponentStatement {
    pub component_reference: crate::ir::ast::ComponentReference,
    pub component_statement_group: ComponentStatementGroup,
}

///
/// Type derived for non-terminal component_statementGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ComponentStatementGroup {
    ColonEquExpression(ComponentStatementGroupColonEquExpression),
    FunctionCallArgs(ComponentStatementGroupFunctionCallArgs),
}

///
/// Type derived for non-terminal composition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Composition {
    pub element_list: crate::modelica_grammar::ElementList,
    pub composition_list: Vec<CompositionList>,
    pub composition_opt: Option<CompositionOpt>,
    pub composition_opt0: Option<CompositionOpt0>,
}

///
/// Type derived for non-terminal compositionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionList {
    pub composition_list_group: CompositionListGroup,
}

///
/// Type derived for non-terminal compositionListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CompositionListGroup {
    PublicElementList(CompositionListGroupPublicElementList),
    ProtectedElementList(CompositionListGroupProtectedElementList),
    EquationSection(CompositionListGroupEquationSection),
    AlgorithmSection(CompositionListGroupAlgorithmSection),
}

///
/// Type derived for non-terminal compositionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionOpt {
    pub composition_opt1: Option<CompositionOpt1>,
    pub composition_opt2: Option<CompositionOpt2>,
    pub composition_opt3: Option<CompositionOpt3>,
}

///
/// Type derived for non-terminal compositionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionOpt0 {
    pub annotation_clause: AnnotationClause,
}

///
/// Type derived for non-terminal compositionOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionOpt1 {
    pub language_specification: LanguageSpecification,
}

///
/// Type derived for non-terminal compositionOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionOpt2 {
    pub external_function_call: ExternalFunctionCall,
}

///
/// Type derived for non-terminal compositionOpt3
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CompositionOpt3 {
    pub annotation_clause: AnnotationClause,
}

///
/// Type derived for non-terminal condition_attribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConditionAttribute {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal connect
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Connect {
    pub connect: crate::ir::ast::Token, /* connect */
}

///
/// Type derived for non-terminal connect_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConnectEquation {
    pub component_reference: crate::ir::ast::ComponentReference,
    pub component_reference0: crate::ir::ast::ComponentReference,
}

///
/// Type derived for non-terminal connector
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Connector {
    pub connector: crate::ir::ast::Token, /* connector */
}

///
/// Type derived for non-terminal constant
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Constant {
    pub constant: crate::ir::ast::Token, /* constant */
}

///
/// Type derived for non-terminal constrainedby
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Constrainedby {
    pub constrainedby: crate::ir::ast::Token, /* constrainedby */
}

///
/// Type derived for non-terminal constraining_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstrainingClause {
    pub type_specifier: TypeSpecifier,
    pub constraining_clause_opt: Option<ConstrainingClauseOpt>,
}

///
/// Type derived for non-terminal constraining_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstrainingClauseOpt {
    pub class_modification: ClassModification,
}

///
/// Type derived for non-terminal declaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Declaration {
    pub ident: crate::ir::ast::Token,
    pub declaration_opt: Option<DeclarationOpt>,
    pub declaration_opt0: Option<DeclarationOpt0>,
}

///
/// Type derived for non-terminal declarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationOpt {
    pub array_subscripts: crate::modelica_grammar::ArraySubscripts,
}

///
/// Type derived for non-terminal declarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationOpt0 {
    pub modification: Modification,
}

///
/// Type derived for non-terminal der
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Der {
    pub der: crate::ir::ast::Token, /* der */
}

///
/// Type derived for non-terminal der_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DerClassSpecifier {
    pub ident: crate::ir::ast::Token,
    pub der: Der,
    pub type_specifier: TypeSpecifier,
    pub ident0: crate::ir::ast::Token,
    pub der_class_specifier_list: Vec<DerClassSpecifierList>,
    pub description: Description,
}

///
/// Type derived for non-terminal der_class_specifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DerClassSpecifierList {
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal description
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Description {
    pub description_string: crate::modelica_grammar::TokenList,
    pub description_opt: Option<DescriptionOpt>,
}

///
/// Type derived for non-terminal descriptionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionOpt {
    pub annotation_clause: AnnotationClause,
}

///
/// Type derived for non-terminal description_string
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionString {
    pub description_string_opt: Option<DescriptionStringOpt>,
}

///
/// Type derived for non-terminal description_stringOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionStringOpt {
    pub string: crate::ir::ast::Token,
    pub description_string_opt_list: Vec<DescriptionStringOptList>,
}

///
/// Type derived for non-terminal description_stringOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionStringOptList {
    pub string: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal discrete
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Discrete {
    pub discrete: crate::ir::ast::Token, /* discrete */
}

///
/// Type derived for non-terminal each
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Each {
    pub each: crate::ir::ast::Token, /* each */
}

///
/// Type derived for non-terminal element
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Element {
    ImportClause(ElementImportClause),
    ExtendsClause(ElementExtendsClause),
    ElementDefinition(ElementElementDefinition),
    ElementReplaceableDefinition(ElementElementReplaceableDefinition),
}

///
/// Type derived for non-terminal element_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinition {
    pub element_definition_opt: Option<ElementDefinitionOpt>,
    pub element_definition_opt0: Option<ElementDefinitionOpt0>,
    pub element_definition_opt1: Option<ElementDefinitionOpt1>,
    pub element_definition_opt2: Option<ElementDefinitionOpt2>,
    pub element_definition_group: ElementDefinitionGroup,
}

///
/// Type derived for non-terminal element_definitionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementDefinitionGroup {
    ClassDefinition(ElementDefinitionGroupClassDefinition),
    ComponentClause(ElementDefinitionGroupComponentClause),
}

///
/// Type derived for non-terminal element_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionOpt {
    pub redeclare: Redeclare,
}

///
/// Type derived for non-terminal element_definitionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal element_definitionOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionOpt1 {
    pub inner: Inner,
}

///
/// Type derived for non-terminal element_definitionOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementDefinitionOpt2 {
    pub outer: Outer,
}

///
/// Type derived for non-terminal element_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementList {
    pub element_list_list: Vec<ElementListList>,
}

///
/// Type derived for non-terminal element_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementListList {
    pub element: Element,
}

///
/// Type derived for non-terminal element_modification
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModification {
    pub name: crate::ir::ast::Name,
    pub element_modification_opt: Option<ElementModificationOpt>,
    pub description_string: crate::modelica_grammar::TokenList,
}

///
/// Type derived for non-terminal element_modificationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOpt {
    pub modification: Modification,
}

///
/// Type derived for non-terminal element_modification_or_replaceable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOrReplaceable {
    pub element_modification_or_replaceable_opt: Option<ElementModificationOrReplaceableOpt>,
    pub element_modification_or_replaceable_opt0: Option<ElementModificationOrReplaceableOpt0>,
    pub element_modification_or_replaceable_group: ElementModificationOrReplaceableGroup,
}

///
/// Type derived for non-terminal element_modification_or_replaceableGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementModificationOrReplaceableGroup {
    ElementModification(ElementModificationOrReplaceableGroupElementModification),
    ElementReplaceable(ElementModificationOrReplaceableGroupElementReplaceable),
}

///
/// Type derived for non-terminal element_modification_or_replaceableOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOrReplaceableOpt {
    pub each: Each,
}

///
/// Type derived for non-terminal element_modification_or_replaceableOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementModificationOrReplaceableOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal element_redeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclaration {
    pub redeclare: Redeclare,
    pub element_redeclaration_opt: Option<ElementRedeclarationOpt>,
    pub element_redeclaration_opt0: Option<ElementRedeclarationOpt0>,
    pub element_redeclaration_group: ElementRedeclarationGroup,
}

///
/// Type derived for non-terminal element_redeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementRedeclarationGroup {
    ShortClassDefinition(ElementRedeclarationGroupShortClassDefinition),
    ComponentClause1(ElementRedeclarationGroupComponentClause1),
    ElementReplaceable(ElementRedeclarationGroupElementReplaceable),
}

///
/// Type derived for non-terminal element_redeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclarationOpt {
    pub each: Each,
}

///
/// Type derived for non-terminal element_redeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementRedeclarationOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal element_replaceable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceable {
    pub replaceable: Replaceable,
    pub element_replaceable_group: ElementReplaceableGroup,
    pub element_replaceable_opt: Option<ElementReplaceableOpt>,
}

///
/// Type derived for non-terminal element_replaceableGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementReplaceableGroup {
    ShortClassDefinition(ElementReplaceableGroupShortClassDefinition),
    ComponentClause1(ElementReplaceableGroupComponentClause1),
}

///
/// Type derived for non-terminal element_replaceableOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableOpt {
    pub constraining_clause: ConstrainingClause,
}

///
/// Type derived for non-terminal element_replaceable_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableDefinition {
    pub replaceable: Replaceable,
    pub element_replaceable_definition_group: ElementReplaceableDefinitionGroup,
    pub element_replaceable_definition_opt: Option<ElementReplaceableDefinitionOpt>,
}

///
/// Type derived for non-terminal element_replaceable_definitionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ElementReplaceableDefinitionGroup {
    ClassDefinition(ElementReplaceableDefinitionGroupClassDefinition),
    ComponentClause(ElementReplaceableDefinitionGroupComponentClause),
}

///
/// Type derived for non-terminal element_replaceable_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementReplaceableDefinitionOpt {
    pub constraining_clause: ConstrainingClause,
    pub description: Description,
}

///
/// Type derived for non-terminal else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Else {
    pub r#else: crate::ir::ast::Token, /* else */
}

///
/// Type derived for non-terminal elseif
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Elseif {
    pub elseif: crate::ir::ast::Token, /* elseif */
}

///
/// Type derived for non-terminal elsewhen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Elsewhen {
    pub elsewhen: crate::ir::ast::Token, /* elsewhen */
}

///
/// Type derived for non-terminal encapsulated
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Encapsulated {
    pub encapsulated: crate::ir::ast::Token, /* encapsulated */
}

///
/// Type derived for non-terminal end
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct End {
    pub end: crate::ir::ast::Token, /* end */
}

///
/// Type derived for non-terminal enum_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumClassSpecifier {
    pub ident: crate::ir::ast::Token,
    pub enumeration: Enumeration,
    pub enum_class_specifier_group: EnumClassSpecifierGroup,
    pub description: Description,
}

///
/// Type derived for non-terminal enum_class_specifierGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EnumClassSpecifierGroup {
    EnumClassSpecifierOpt(EnumClassSpecifierGroupEnumClassSpecifierOpt),
    Colon(EnumClassSpecifierGroupColon),
}

///
/// Type derived for non-terminal enum_class_specifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumClassSpecifierOpt {
    pub enum_list: EnumList,
}

///
/// Type derived for non-terminal enum_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumList {
    pub enumeration_literal: EnumerationLiteral,
    pub enum_list_list: Vec<EnumListList>,
}

///
/// Type derived for non-terminal enum_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumListList {
    pub enumeration_literal: EnumerationLiteral,
}

///
/// Type derived for non-terminal enumeration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Enumeration {
    pub enumeration: crate::ir::ast::Token, /* enumeration */
}

///
/// Type derived for non-terminal enumeration_literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumerationLiteral {
    pub ident: crate::ir::ast::Token,
    pub description: Description,
}

///
/// Type derived for non-terminal equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equation {
    pub equation: crate::ir::ast::Token, /* equation */
}

///
/// Type derived for non-terminal equation_block
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationBlock {
    pub expression: crate::ir::ast::Expression,
    pub equation_block_list: Vec<EquationBlockList>,
}

///
/// Type derived for non-terminal equation_blockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationBlockList {
    pub some_equation: crate::ir::ast::Equation,
}

///
/// Type derived for non-terminal equation_section
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSection {
    pub equation_section_opt: Option<EquationSectionOpt>,
    pub equation_section_list: Vec<EquationSectionList>,
}

///
/// Type derived for non-terminal equation_sectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSectionList {
    pub some_equation: crate::ir::ast::Equation,
}

///
/// Type derived for non-terminal equation_sectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquationSectionOpt {}

///
/// Type derived for non-terminal expandable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expandable {
    pub expandable: crate::ir::ast::Token, /* expandable */
}

///
/// Type derived for non-terminal expression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression {
    SimpleExpression(Box<ExpressionSimpleExpression>),
    IfExpression(Box<ExpressionIfExpression>),
}

///
/// Type derived for non-terminal expression_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionList {
    pub expression: Box<crate::ir::ast::Expression>,
    pub expression_list_list: Vec<ExpressionListList>,
}

///
/// Type derived for non-terminal expression_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionListList {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal extends
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Extends {
    pub extends: crate::ir::ast::Token, /* extends */
}

///
/// Type derived for non-terminal extends_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtendsClassSpecifier {
    pub ident: crate::ir::ast::Token,
    pub extends_class_specifier_opt: Option<ExtendsClassSpecifierOpt>,
    pub description_string: crate::modelica_grammar::TokenList,
    pub composition: crate::modelica_grammar::Composition,
    pub ident0: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal extends_class_specifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtendsClassSpecifierOpt {
    pub class_modification: ClassModification,
}

///
/// Type derived for non-terminal extends_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtendsClause {
    pub type_specifier: TypeSpecifier,
    pub extends_clause_opt: Option<ExtendsClauseOpt>,
    pub extends_clause_opt0: Option<ExtendsClauseOpt0>,
}

///
/// Type derived for non-terminal extends_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtendsClauseOpt {
    pub class_or_inheritance_modification: ClassOrInheritanceModification,
}

///
/// Type derived for non-terminal extends_clauseOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtendsClauseOpt0 {
    pub annotation_clause: AnnotationClause,
}

///
/// Type derived for non-terminal external
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct External {
    pub external: crate::ir::ast::Token, /* external */
}

///
/// Type derived for non-terminal external_function_call
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExternalFunctionCall {
    pub external_function_call_opt: Option<ExternalFunctionCallOpt>,
    pub ident: crate::ir::ast::Token,
    pub external_function_call_opt0: Option<ExternalFunctionCallOpt0>,
}

///
/// Type derived for non-terminal external_function_callOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExternalFunctionCallOpt {
    pub component_reference: crate::ir::ast::ComponentReference,
}

///
/// Type derived for non-terminal external_function_callOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExternalFunctionCallOpt0 {
    pub expression_list: ExpressionList,
}

///
/// Type derived for non-terminal factor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Factor {
    pub primary: Box<crate::ir::ast::Expression>,
    pub factor_list: Vec<FactorList>,
}

///
/// Type derived for non-terminal factorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorList {
    pub factor_list_group: FactorListGroup,
    pub primary: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal factorListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FactorListGroup {
    Circumflex(FactorListGroupCircumflex),
    DotCircumflex(FactorListGroupDotCircumflex),
}

///
/// Type derived for non-terminal false
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct False {
    pub r#false: crate::ir::ast::Token, /* false */
}

///
/// Type derived for non-terminal final
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Final {
    pub r#final: crate::ir::ast::Token, /* final */
}

///
/// Type derived for non-terminal flow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Flow {
    pub flow: crate::ir::ast::Token, /* flow */
}

///
/// Type derived for non-terminal for
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct For {
    pub r#for: crate::ir::ast::Token, /* for */
}

///
/// Type derived for non-terminal for_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForEquation {
    pub for_indices: ForIndices,
    pub for_equation_list: Vec<ForEquationList>,
}

///
/// Type derived for non-terminal for_equationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForEquationList {
    pub some_equation: crate::ir::ast::Equation,
}

///
/// Type derived for non-terminal for_index
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForIndex {
    pub ident: crate::ir::ast::Token,
    pub for_index_opt: Option<ForIndexOpt>,
}

///
/// Type derived for non-terminal for_indexOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForIndexOpt {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal for_indices
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForIndices {
    pub for_index: ForIndex,
    pub for_indices_list: Vec<ForIndicesList>,
}

///
/// Type derived for non-terminal for_indicesList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForIndicesList {
    pub for_index: ForIndex,
}

///
/// Type derived for non-terminal for_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatement {
    pub for_indices: ForIndices,
    pub for_statement_list: Vec<ForStatementList>,
}

///
/// Type derived for non-terminal for_statementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatementList {
    pub statement: crate::ir::ast::Statement,
}

///
/// Type derived for non-terminal function
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Function {
    pub function: crate::ir::ast::Token, /* function */
}

///
/// Type derived for non-terminal function_argument
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionArgument {
    FunctionPartialApplication(FunctionArgumentFunctionPartialApplication),
    Expression(Box<FunctionArgumentExpression>),
}

///
/// Type derived for non-terminal function_arguments
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionArguments {
    ExpressionFunctionArgumentsOpt(Box<FunctionArgumentsExpressionFunctionArgumentsOpt>),
    FunctionPartialApplicationFunctionArgumentsOpt0(
        Box<FunctionArgumentsFunctionPartialApplicationFunctionArgumentsOpt0>,
    ),
    NamedArguments(Box<FunctionArgumentsNamedArguments>),
}

///
/// Type derived for non-terminal function_argumentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsOpt {
    pub function_arguments_opt_group: FunctionArgumentsOptGroup,
}

///
/// Type derived for non-terminal function_argumentsOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsOpt0 {
    pub function_arguments_non_first: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal function_argumentsOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionArgumentsOptGroup {
    CommaFunctionArgumentsNonFirst(FunctionArgumentsOptGroupCommaFunctionArgumentsNonFirst),
    ForForIndices(FunctionArgumentsOptGroupForForIndices),
}

///
/// Type derived for non-terminal function_arguments_non_first
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionArgumentsNonFirst {
    FunctionArgumentFunctionArgumentsNonFirstOpt(
        FunctionArgumentsNonFirstFunctionArgumentFunctionArgumentsNonFirstOpt,
    ),
    NamedArguments(FunctionArgumentsNonFirstNamedArguments),
}

///
/// Type derived for non-terminal function_arguments_non_firstOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionArgumentsNonFirstOpt {
    pub function_arguments_non_first: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal function_call_args
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallArgs {
    pub function_call_args_opt: Option<Box<FunctionCallArgsOpt>>,
}

///
/// Type derived for non-terminal function_call_argsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallArgsOpt {
    pub function_arguments: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal function_call_output_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallOutputStatement {
    pub output_expression_list: crate::modelica_grammar::ExpressionList,
    pub component_reference: crate::ir::ast::ComponentReference,
    pub function_call_args: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal function_partial_application
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionPartialApplication {
    pub function: Function,
    pub type_specifier: TypeSpecifier,
    pub function_partial_application_opt: Option<FunctionPartialApplicationOpt>,
}

///
/// Type derived for non-terminal function_partial_applicationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionPartialApplicationOpt {
    pub named_arguments: NamedArguments,
}

///
/// Type derived for non-terminal global_function_call
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GlobalFunctionCall {
    pub global_function_call_group: GlobalFunctionCallGroup,
    pub function_call_args: crate::modelica_grammar::ExpressionList,
}

///
/// Type derived for non-terminal global_function_callGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GlobalFunctionCallGroup {
    Der(GlobalFunctionCallGroupDer),
    Initial(GlobalFunctionCallGroupInitial),
    Pure(GlobalFunctionCallGroupPure),
}

///
/// Type derived for non-terminal ident
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Ident {
    BasicIdent(IdentBasicIdent),
    QIdent(IdentQIdent),
}

///
/// Type derived for non-terminal if
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct If {
    pub r#if: crate::ir::ast::Token, /* if */
}

///
/// Type derived for non-terminal if_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfEquation {
    pub r#if0: crate::ir::ast::EquationBlock,
    pub if_equation_list: Vec<IfEquationList>,
    pub if_equation_opt: Option<IfEquationOpt>,
}

///
/// Type derived for non-terminal if_equationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfEquationList {
    pub elseif0: crate::ir::ast::EquationBlock,
}

///
/// Type derived for non-terminal if_equationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfEquationOpt {
    pub if_equation_opt_list: Vec<IfEquationOptList>,
}

///
/// Type derived for non-terminal if_equationOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfEquationOptList {
    pub some_equation: crate::ir::ast::Equation,
}

///
/// Type derived for non-terminal if_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfExpression {
    pub expression: Box<crate::ir::ast::Expression>,
    pub expression0: crate::ir::ast::Expression,
    pub if_expression_list: Vec<IfExpressionList>,
    pub expression1: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal if_expressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfExpressionList {
    pub expression: crate::ir::ast::Expression,
    pub expression0: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal if_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatement {
    pub r#if0: crate::ir::ast::StatementBlock,
    pub if_statement_list: Vec<IfStatementList>,
    pub if_statement_opt: Option<IfStatementOpt>,
}

///
/// Type derived for non-terminal if_statementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList {
    pub elseif0: crate::ir::ast::StatementBlock,
}

///
/// Type derived for non-terminal if_statementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOpt {
    pub if_statement_opt_list: Vec<IfStatementOptList>,
}

///
/// Type derived for non-terminal if_statementOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOptList {
    pub r#else: crate::ir::ast::Statement,
}

///
/// Type derived for non-terminal import
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Import {
    pub import: crate::ir::ast::Token, /* import */
}

///
/// Type derived for non-terminal import_clause
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClause {
    pub import: Import,
    pub import_clause_group: ImportClauseGroup,
    pub description: Description,
}

///
/// Type derived for non-terminal import_clauseGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseGroup {
    IdentEquName(ImportClauseGroupIdentEquName),
    NameImportClauseOpt(ImportClauseGroupNameImportClauseOpt),
}

///
/// Type derived for non-terminal import_clauseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportClauseOpt {
    pub import_clause_opt_group: ImportClauseOptGroup,
}

///
/// Type derived for non-terminal import_clauseOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseOptGroup {
    DotStar(ImportClauseOptGroupDotStar),
    DotImportClauseOptGroupGroup(ImportClauseOptGroupDotImportClauseOptGroupGroup),
}

///
/// Type derived for non-terminal import_clauseOptGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportClauseOptGroupGroup {
    Star(ImportClauseOptGroupGroupStar),
    LBraceImportListRBrace(ImportClauseOptGroupGroupLBraceImportListRBrace),
}

///
/// Type derived for non-terminal import_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportList {
    pub ident: crate::ir::ast::Token,
    pub import_list_list: Vec<ImportListList>,
}

///
/// Type derived for non-terminal import_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportListList {
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal impure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Impure {
    pub impure: crate::ir::ast::Token, /* impure */
}

///
/// Type derived for non-terminal in
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct In {
    pub r#in: crate::ir::ast::Token, /* in */
}

///
/// Type derived for non-terminal inheritance_modification
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InheritanceModification {
    pub inheritance_modification_group: InheritanceModificationGroup,
}

///
/// Type derived for non-terminal inheritance_modificationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InheritanceModificationGroup {
    ConnectEquation(InheritanceModificationGroupConnectEquation),
    Ident(InheritanceModificationGroupIdent),
}

///
/// Type derived for non-terminal initial
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Initial {
    pub initial: crate::ir::ast::Token, /* initial */
}

///
/// Type derived for non-terminal inner
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inner {
    pub inner: crate::ir::ast::Token, /* inner */
}

///
/// Type derived for non-terminal input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Input {
    pub input: crate::ir::ast::Token, /* input */
}

///
/// Type derived for non-terminal language_specification
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LanguageSpecification {
    pub string: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal logical_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalExpression {
    pub logical_term: Box<crate::ir::ast::Expression>,
    pub logical_expression_list: Vec<LogicalExpressionList>,
}

///
/// Type derived for non-terminal logical_expressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalExpressionList {
    pub logical_term: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal logical_factor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalFactor {
    pub logical_factor_opt: Option<LogicalFactorOpt>,
    pub relation: Box<crate::ir::ast::Expression>,
}

///
/// Type derived for non-terminal logical_factorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalFactorOpt {
    pub not: Not,
}

///
/// Type derived for non-terminal logical_term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalTerm {
    pub logical_factor: Box<crate::ir::ast::Expression>,
    pub logical_term_list: Vec<LogicalTermList>,
}

///
/// Type derived for non-terminal logical_termList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalTermList {
    pub logical_factor: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal long_class_specifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LongClassSpecifier {
    StandardClassSpecifier(LongClassSpecifierStandardClassSpecifier),
    ExtendsClassSpecifier(LongClassSpecifierExtendsClassSpecifier),
}

///
/// Type derived for non-terminal loop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Loop {
    pub r#loop: crate::ir::ast::Token, /* loop */
}

///
/// Type derived for non-terminal model
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Model {
    pub model: crate::ir::ast::Token, /* model */
}

///
/// Type derived for non-terminal modification
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Modification {
    ClassModificationModificationOpt(ModificationClassModificationModificationOpt),
    EquModificationExpression(ModificationEquModificationExpression),
}

///
/// Type derived for non-terminal modificationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModificationOpt {
    pub modification_expression: ModificationExpression,
}

///
/// Type derived for non-terminal modification_expression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModificationExpression {
    Expression(ModificationExpressionExpression),
    Break(ModificationExpressionBreak),
}

///
/// Type derived for non-terminal mul_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MulOperator {
    Star(MulOperatorStar),
    Slash(MulOperatorSlash),
    DotStar(MulOperatorDotStar),
    DotSlash(MulOperatorDotSlash),
}

///
/// Type derived for non-terminal name
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Name {
    pub ident: crate::ir::ast::Token,
    pub name_list: Vec<NameList>,
}

///
/// Type derived for non-terminal nameList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NameList {
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal named_argument
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NamedArgument {
    pub ident: crate::ir::ast::Token,
    pub function_argument: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal named_arguments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NamedArguments {
    pub named_argument: NamedArgument,
    pub named_arguments_opt: Option<Box<NamedArgumentsOpt>>,
}

///
/// Type derived for non-terminal named_argumentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NamedArgumentsOpt {
    pub named_arguments: NamedArguments,
}

///
/// Type derived for non-terminal not
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Not {
    pub not: crate::ir::ast::Token, /* not */
}

///
/// Type derived for non-terminal operator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator {
    pub operator: crate::ir::ast::Token, /* operator */
}

///
/// Type derived for non-terminal or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Or {
    pub or: crate::ir::ast::Token, /* or */
}

///
/// Type derived for non-terminal outer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Outer {
    pub outer: crate::ir::ast::Token, /* outer */
}

///
/// Type derived for non-terminal output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Output {
    pub output: crate::ir::ast::Token, /* output */
}

///
/// Type derived for non-terminal output_expression_list
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputExpressionList {
    pub output_expression_list_opt: Option<Box<OutputExpressionListOpt>>,
    pub output_expression_list_list: Vec<OutputExpressionListList>,
}

///
/// Type derived for non-terminal output_expression_listList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputExpressionListList {
    pub output_expression_list_opt0: Option<OutputExpressionListOpt0>,
}

///
/// Type derived for non-terminal output_expression_listOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputExpressionListOpt {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal output_expression_listOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputExpressionListOpt0 {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal output_primary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputPrimary {
    pub output_expression_list: crate::modelica_grammar::ExpressionList,
    pub output_primary_opt: Option<Box<OutputPrimaryOpt>>,
}

///
/// Type derived for non-terminal output_primaryOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputPrimaryOpt {
    pub output_primary_opt_group: OutputPrimaryOptGroup,
}

///
/// Type derived for non-terminal output_primaryOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OutputPrimaryOptGroup {
    ArraySubscripts(OutputPrimaryOptGroupArraySubscripts),
    DotIdent(OutputPrimaryOptGroupDotIdent),
}

///
/// Type derived for non-terminal package
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Package {
    pub package: crate::ir::ast::Token, /* package */
}

///
/// Type derived for non-terminal parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parameter {
    pub parameter: crate::ir::ast::Token, /* parameter */
}

///
/// Type derived for non-terminal partial
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Partial {
    pub partial: crate::ir::ast::Token, /* partial */
}

///
/// Type derived for non-terminal primary
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Primary {
    UnsignedNumber(PrimaryUnsignedNumber),
    String(PrimaryString),
    False(PrimaryFalse),
    True(PrimaryTrue),
    GlobalFunctionCall(PrimaryGlobalFunctionCall),
    ComponentPrimary(PrimaryComponentPrimary),
    OutputPrimary(PrimaryOutputPrimary),
    RangePrimary(Box<PrimaryRangePrimary>),
    ArrayPrimary(PrimaryArrayPrimary),
    End(PrimaryEnd),
}

///
/// Type derived for non-terminal protected
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Protected {
    pub protected: crate::ir::ast::Token, /* protected */
}

///
/// Type derived for non-terminal public
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Public {
    pub public: crate::ir::ast::Token, /* public */
}

///
/// Type derived for non-terminal pure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Pure {
    pub pure: crate::ir::ast::Token, /* pure */
}

///
/// Type derived for non-terminal range_primary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangePrimary {
    pub expression_list: Box<ExpressionList>,
    pub range_primary_list: Vec<RangePrimaryList>,
}

///
/// Type derived for non-terminal range_primaryList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangePrimaryList {
    pub expression_list: ExpressionList,
}

///
/// Type derived for non-terminal record
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Record {
    pub record: crate::ir::ast::Token, /* record */
}

///
/// Type derived for non-terminal redeclare
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Redeclare {
    pub redeclare: crate::ir::ast::Token, /* redeclare */
}

///
/// Type derived for non-terminal relation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Relation {
    pub arithmetic_expression: Box<crate::ir::ast::Expression>,
    pub relation_opt: Option<RelationOpt>,
}

///
/// Type derived for non-terminal relationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOpt {
    pub relational_operator: RelationalOperator,
    pub arithmetic_expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal relational_operator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RelationalOperator {
    LT(RelationalOperatorLT),
    LTEqu(RelationalOperatorLTEqu),
    GT(RelationalOperatorGT),
    GTEqu(RelationalOperatorGTEqu),
    EquEqu(RelationalOperatorEquEqu),
    LTGT(RelationalOperatorLTGT),
}

///
/// Type derived for non-terminal replaceable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Replaceable {
    pub replaceable: crate::ir::ast::Token, /* replaceable */
}

///
/// Type derived for non-terminal return
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Return {
    pub r#return: crate::ir::ast::Token, /* return */
}

///
/// Type derived for non-terminal short_class_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ShortClassDefinition {
    pub class_prefixes: ClassPrefixes,
    pub short_class_specifier: ShortClassSpecifier,
}

///
/// Type derived for non-terminal short_class_specifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ShortClassSpecifier {
    TypeClassSpecifier(ShortClassSpecifierTypeClassSpecifier),
    EnumClassSpecifier(ShortClassSpecifierEnumClassSpecifier),
}

///
/// Type derived for non-terminal simple_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleEquation {
    pub simple_expression: crate::ir::ast::Expression,
    pub simple_equation_opt: Option<SimpleEquationOpt>,
}

///
/// Type derived for non-terminal simple_equationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleEquationOpt {
    pub expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal simple_expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpression {
    pub logical_expression: crate::ir::ast::Expression,
    pub simple_expression_opt: Option<SimpleExpressionOpt>,
}

///
/// Type derived for non-terminal simple_expressionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpressionOpt {
    pub logical_expression: crate::ir::ast::Expression,
    pub simple_expression_opt0: Option<SimpleExpressionOpt0>,
}

///
/// Type derived for non-terminal simple_expressionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpressionOpt0 {
    pub logical_expression: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal some_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SomeEquation {
    pub some_equation_option: SomeEquationOption,
    pub description: Description,
}

///
/// Type derived for non-terminal some_equation_option
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SomeEquationOption {
    SimpleEquation(SomeEquationOptionSimpleEquation),
    IfEquation(SomeEquationOptionIfEquation),
    ForEquation(SomeEquationOptionForEquation),
    ConnectEquation(SomeEquationOptionConnectEquation),
    WhenEquation(SomeEquationOptionWhenEquation),
}

///
/// Type derived for non-terminal standard_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StandardClassSpecifier {
    pub name: crate::ir::ast::Token,
    pub description_string: crate::modelica_grammar::TokenList,
    pub composition: crate::modelica_grammar::Composition,
    pub ident: crate::ir::ast::Token,
}

///
/// Type derived for non-terminal statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Statement {
    pub statement_option: StatementOption,
    pub description: Description,
}

///
/// Type derived for non-terminal statement_block
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementBlock {
    pub expression: crate::ir::ast::Expression,
    pub statement_block_list: Vec<StatementBlockList>,
}

///
/// Type derived for non-terminal statement_blockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementBlockList {
    pub statement: crate::ir::ast::Statement,
}

///
/// Type derived for non-terminal statement_option
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementOption {
    ComponentStatement(StatementOptionComponentStatement),
    FunctionCallOutputStatement(StatementOptionFunctionCallOutputStatement),
    Break(StatementOptionBreak),
    Return(StatementOptionReturn),
    IfStatement(StatementOptionIfStatement),
    ForStatement(StatementOptionForStatement),
    WhileStatement(StatementOptionWhileStatement),
    WhenStatement(StatementOptionWhenStatement),
}

///
/// Type derived for non-terminal stored_definition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinition {
    pub stored_definition_opt: Option<StoredDefinitionOpt>,
    pub stored_definition_list: Vec<StoredDefinitionList>,
}

///
/// Type derived for non-terminal stored_definitionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionList {
    pub stored_definition_opt0: Option<StoredDefinitionOpt0>,
    pub class_definition: crate::ir::ast::ClassDefinition,
}

///
/// Type derived for non-terminal stored_definitionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt {
    pub stored_definition_opt1: Option<StoredDefinitionOpt1>,
}

///
/// Type derived for non-terminal stored_definitionOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt0 {
    pub r#final: Final,
}

///
/// Type derived for non-terminal stored_definitionOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StoredDefinitionOpt1 {
    pub name: crate::ir::ast::Name,
}

///
/// Type derived for non-terminal stream
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Stream {
    pub stream: crate::ir::ast::Token, /* stream */
}

///
/// Type derived for non-terminal string
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String {
    pub string: crate::ir::ast::Token, /* "[' \w]*" */
}

///
/// Type derived for non-terminal subscript
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Subscript {
    Colon(SubscriptColon),
    Expression(SubscriptExpression),
}

///
/// Type derived for non-terminal term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Term {
    pub factor: crate::ir::ast::Expression,
    pub term_list: Vec<TermList>,
}

///
/// Type derived for non-terminal termList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermList {
    pub mul_operator: MulOperator,
    pub factor: crate::ir::ast::Expression,
}

///
/// Type derived for non-terminal then
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Then {
    pub then: crate::ir::ast::Token, /* then */
}

///
/// Type derived for non-terminal true
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct True {
    pub r#true: crate::ir::ast::Token, /* true */
}

///
/// Type derived for non-terminal type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Type {
    pub r#type: crate::ir::ast::Token, /* type */
}

///
/// Type derived for non-terminal type_class_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeClassSpecifier {
    pub ident: crate::ir::ast::Token,
    pub base_prefix: BasePrefix,
    pub type_specifier: TypeSpecifier,
    pub type_class_specifier_opt: Option<TypeClassSpecifierOpt>,
    pub type_class_specifier_opt0: Option<TypeClassSpecifierOpt0>,
    pub description: Description,
}

///
/// Type derived for non-terminal type_class_specifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeClassSpecifierOpt {
    pub array_subscripts: crate::modelica_grammar::ArraySubscripts,
}

///
/// Type derived for non-terminal type_class_specifierOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeClassSpecifierOpt0 {
    pub class_modification: ClassModification,
}

///
/// Type derived for non-terminal type_prefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefix {
    pub type_prefix_opt: Option<TypePrefixOpt>,
    pub type_prefix_opt0: Option<TypePrefixOpt0>,
    pub type_prefix_opt1: Option<TypePrefixOpt1>,
}

///
/// Type derived for non-terminal type_prefixOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt {
    pub type_prefix_opt_group: TypePrefixOptGroup,
}

///
/// Type derived for non-terminal type_prefixOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt0 {
    pub type_prefix_opt0_group: TypePrefixOpt0Group,
}

///
/// Type derived for non-terminal type_prefixOpt0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOpt0Group {
    Discrete(TypePrefixOpt0GroupDiscrete),
    Parameter(TypePrefixOpt0GroupParameter),
    Constant(TypePrefixOpt0GroupConstant),
}

///
/// Type derived for non-terminal type_prefixOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypePrefixOpt1 {
    pub type_prefix_opt1_group: TypePrefixOpt1Group,
}

///
/// Type derived for non-terminal type_prefixOpt1Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOpt1Group {
    Input(TypePrefixOpt1GroupInput),
    Output(TypePrefixOpt1GroupOutput),
}

///
/// Type derived for non-terminal type_prefixOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypePrefixOptGroup {
    Flow(TypePrefixOptGroupFlow),
    Stream(TypePrefixOptGroupStream),
}

///
/// Type derived for non-terminal type_specifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecifier {
    pub type_specifier_opt: Option<TypeSpecifierOpt>,
    pub name: crate::ir::ast::Name,
}

///
/// Type derived for non-terminal type_specifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecifierOpt {}

///
/// Type derived for non-terminal unsigned_integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedInteger {
    pub unsigned_integer: crate::ir::ast::Token, /* [0-9]+ */
}

///
/// Type derived for non-terminal unsigned_number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum UnsignedNumber {
    UnsignedInteger(UnsignedNumberUnsignedInteger),
    UnsignedReal(UnsignedNumberUnsignedReal),
}

///
/// Type derived for non-terminal unsigned_real
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum UnsignedReal {
    Decimal(UnsignedRealDecimal),
    Scientific(UnsignedRealScientific),
    Scientific2(UnsignedRealScientific2),
}

///
/// Type derived for non-terminal when
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct When {
    pub when: crate::ir::ast::Token, /* when */
}

///
/// Type derived for non-terminal when_equation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhenEquation {
    pub when0: crate::ir::ast::EquationBlock,
    pub when_equation_list: Vec<WhenEquationList>,
}

///
/// Type derived for non-terminal when_equationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhenEquationList {
    pub elsewhen0: crate::ir::ast::EquationBlock,
}

///
/// Type derived for non-terminal when_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhenStatement {
    pub when0: crate::ir::ast::StatementBlock,
    pub when_statement_list: Vec<WhenStatementList>,
}

///
/// Type derived for non-terminal when_statementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhenStatementList {
    pub elsewhen0: crate::ir::ast::StatementBlock,
}

///
/// Type derived for non-terminal while
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct While {
    pub r#while: crate::ir::ast::Token, /* while */
}

///
/// Type derived for non-terminal while_statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhileStatement {
    pub expression: crate::ir::ast::Expression,
    pub while_statement_list: Vec<WhileStatementList>,
}

///
/// Type derived for non-terminal while_statementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WhileStatementList {
    pub statement: crate::ir::ast::Statement,
}

///
/// Type derived for non-terminal within
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Within {
    pub within: crate::ir::ast::Token, /* within */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AddOperator(AddOperator),
    Algorithm(Algorithm),
    AlgorithmSection(AlgorithmSection),
    AlgorithmSectionList(Vec<AlgorithmSectionList>),
    AlgorithmSectionOpt(Option<AlgorithmSectionOpt>),
    And(And),
    Annotation(Annotation),
    AnnotationClause(AnnotationClause),
    Argument(Argument),
    ArgumentList(ArgumentList),
    ArgumentListList(Vec<ArgumentListList>),
    ArgumentOrInheritanceModificationList(ArgumentOrInheritanceModificationList),
    ArgumentOrInheritanceModificationListGroup(ArgumentOrInheritanceModificationListGroup),
    ArgumentOrInheritanceModificationListList(Vec<ArgumentOrInheritanceModificationListList>),
    ArgumentOrInheritanceModificationListListGroup(ArgumentOrInheritanceModificationListListGroup),
    ArithmeticExpression(ArithmeticExpression),
    ArithmeticExpressionList(Vec<ArithmeticExpressionList>),
    ArithmeticExpressionOpt(Option<ArithmeticExpressionOpt>),
    ArrayArguments(ArrayArguments),
    ArrayArgumentsOpt(Option<ArrayArgumentsOpt>),
    ArrayArgumentsOptGroup(ArrayArgumentsOptGroup),
    ArrayArgumentsNonFirst(ArrayArgumentsNonFirst),
    ArrayArgumentsNonFirstOpt(Option<ArrayArgumentsNonFirstOpt>),
    ArrayPrimary(ArrayPrimary),
    ArraySubscripts(ArraySubscripts),
    ArraySubscriptsList(Vec<ArraySubscriptsList>),
    BasePrefix(BasePrefix),
    BasePrefixOpt(Option<BasePrefixOpt>),
    BasePrefixOptGroup(BasePrefixOptGroup),
    Block(Block),
    Break(Break),
    Class(Class),
    ClassDefinition(ClassDefinition),
    ClassDefinitionOpt(Option<ClassDefinitionOpt>),
    ClassModification(ClassModification),
    ClassModificationOpt(Option<ClassModificationOpt>),
    ClassOrInheritanceModification(ClassOrInheritanceModification),
    ClassOrInheritanceModificationOpt(Option<ClassOrInheritanceModificationOpt>),
    ClassPrefixes(ClassPrefixes),
    ClassPrefixesOpt(Option<ClassPrefixesOpt>),
    ClassSpecifier(ClassSpecifier),
    ClassType(ClassType),
    ClassTypeOpt(Option<ClassTypeOpt>),
    ClassTypeOpt0(Option<ClassTypeOpt0>),
    ClassTypeOpt1(Option<ClassTypeOpt1>),
    ClassTypeOpt1Group(ClassTypeOpt1Group),
    ClassTypeOpt2(Option<ClassTypeOpt2>),
    ComponentClause(ComponentClause),
    ComponentClause1(ComponentClause1),
    ComponentClauseOpt(Option<ComponentClauseOpt>),
    ComponentDeclaration(ComponentDeclaration),
    ComponentDeclaration1(ComponentDeclaration1),
    ComponentDeclarationOpt(Option<ComponentDeclarationOpt>),
    ComponentList(ComponentList),
    ComponentListList(Vec<ComponentListList>),
    ComponentPrimary(ComponentPrimary),
    ComponentPrimaryOpt(Option<ComponentPrimaryOpt>),
    ComponentRefPart(ComponentRefPart),
    ComponentRefPartOpt(Option<ComponentRefPartOpt>),
    ComponentReference(ComponentReference),
    ComponentReferenceList(Vec<ComponentReferenceList>),
    ComponentReferenceOpt(Option<ComponentReferenceOpt>),
    ComponentReferenceOpt0(Option<ComponentReferenceOpt0>),
    ComponentStatement(ComponentStatement),
    ComponentStatementGroup(ComponentStatementGroup),
    Composition(Composition),
    CompositionList(Vec<CompositionList>),
    CompositionListGroup(CompositionListGroup),
    CompositionOpt(Option<CompositionOpt>),
    CompositionOpt0(Option<CompositionOpt0>),
    CompositionOpt1(Option<CompositionOpt1>),
    CompositionOpt2(Option<CompositionOpt2>),
    CompositionOpt3(Option<CompositionOpt3>),
    ConditionAttribute(ConditionAttribute),
    Connect(Connect),
    ConnectEquation(ConnectEquation),
    Connector(Connector),
    Constant(Constant),
    Constrainedby(Constrainedby),
    ConstrainingClause(ConstrainingClause),
    ConstrainingClauseOpt(Option<ConstrainingClauseOpt>),
    Declaration(Declaration),
    DeclarationOpt(Option<DeclarationOpt>),
    DeclarationOpt0(Option<DeclarationOpt0>),
    Der(Der),
    DerClassSpecifier(DerClassSpecifier),
    DerClassSpecifierList(Vec<DerClassSpecifierList>),
    Description(Description),
    DescriptionOpt(Option<DescriptionOpt>),
    DescriptionString(DescriptionString),
    DescriptionStringOpt(Option<DescriptionStringOpt>),
    DescriptionStringOptList(Vec<DescriptionStringOptList>),
    Discrete(Discrete),
    Each(Each),
    Element(Element),
    ElementDefinition(ElementDefinition),
    ElementDefinitionGroup(ElementDefinitionGroup),
    ElementDefinitionOpt(Option<ElementDefinitionOpt>),
    ElementDefinitionOpt0(Option<ElementDefinitionOpt0>),
    ElementDefinitionOpt1(Option<ElementDefinitionOpt1>),
    ElementDefinitionOpt2(Option<ElementDefinitionOpt2>),
    ElementList(ElementList),
    ElementListList(Vec<ElementListList>),
    ElementModification(ElementModification),
    ElementModificationOpt(Option<ElementModificationOpt>),
    ElementModificationOrReplaceable(ElementModificationOrReplaceable),
    ElementModificationOrReplaceableGroup(ElementModificationOrReplaceableGroup),
    ElementModificationOrReplaceableOpt(Option<ElementModificationOrReplaceableOpt>),
    ElementModificationOrReplaceableOpt0(Option<ElementModificationOrReplaceableOpt0>),
    ElementRedeclaration(ElementRedeclaration),
    ElementRedeclarationGroup(ElementRedeclarationGroup),
    ElementRedeclarationOpt(Option<ElementRedeclarationOpt>),
    ElementRedeclarationOpt0(Option<ElementRedeclarationOpt0>),
    ElementReplaceable(ElementReplaceable),
    ElementReplaceableGroup(ElementReplaceableGroup),
    ElementReplaceableOpt(Option<ElementReplaceableOpt>),
    ElementReplaceableDefinition(ElementReplaceableDefinition),
    ElementReplaceableDefinitionGroup(ElementReplaceableDefinitionGroup),
    ElementReplaceableDefinitionOpt(Option<ElementReplaceableDefinitionOpt>),
    Else(Else),
    Elseif(Elseif),
    Elsewhen(Elsewhen),
    Encapsulated(Encapsulated),
    End(End),
    EnumClassSpecifier(EnumClassSpecifier),
    EnumClassSpecifierGroup(EnumClassSpecifierGroup),
    EnumClassSpecifierOpt(Option<EnumClassSpecifierOpt>),
    EnumList(EnumList),
    EnumListList(Vec<EnumListList>),
    Enumeration(Enumeration),
    EnumerationLiteral(EnumerationLiteral),
    Equation(Equation),
    EquationBlock(EquationBlock),
    EquationBlockList(Vec<EquationBlockList>),
    EquationSection(EquationSection),
    EquationSectionList(Vec<EquationSectionList>),
    EquationSectionOpt(Option<EquationSectionOpt>),
    Expandable(Expandable),
    Expression(Expression),
    ExpressionList(ExpressionList),
    ExpressionListList(Vec<ExpressionListList>),
    Extends(Extends),
    ExtendsClassSpecifier(ExtendsClassSpecifier),
    ExtendsClassSpecifierOpt(Option<ExtendsClassSpecifierOpt>),
    ExtendsClause(ExtendsClause),
    ExtendsClauseOpt(Option<ExtendsClauseOpt>),
    ExtendsClauseOpt0(Option<ExtendsClauseOpt0>),
    External(External),
    ExternalFunctionCall(ExternalFunctionCall),
    ExternalFunctionCallOpt(Option<ExternalFunctionCallOpt>),
    ExternalFunctionCallOpt0(Option<ExternalFunctionCallOpt0>),
    Factor(Factor),
    FactorList(Vec<FactorList>),
    FactorListGroup(FactorListGroup),
    False(False),
    Final(Final),
    Flow(Flow),
    For(For),
    ForEquation(ForEquation),
    ForEquationList(Vec<ForEquationList>),
    ForIndex(ForIndex),
    ForIndexOpt(Option<ForIndexOpt>),
    ForIndices(ForIndices),
    ForIndicesList(Vec<ForIndicesList>),
    ForStatement(ForStatement),
    ForStatementList(Vec<ForStatementList>),
    Function(Function),
    FunctionArgument(FunctionArgument),
    FunctionArguments(FunctionArguments),
    FunctionArgumentsOpt(Option<FunctionArgumentsOpt>),
    FunctionArgumentsOpt0(Option<FunctionArgumentsOpt0>),
    FunctionArgumentsOptGroup(FunctionArgumentsOptGroup),
    FunctionArgumentsNonFirst(FunctionArgumentsNonFirst),
    FunctionArgumentsNonFirstOpt(Option<FunctionArgumentsNonFirstOpt>),
    FunctionCallArgs(FunctionCallArgs),
    FunctionCallArgsOpt(Option<FunctionCallArgsOpt>),
    FunctionCallOutputStatement(FunctionCallOutputStatement),
    FunctionPartialApplication(FunctionPartialApplication),
    FunctionPartialApplicationOpt(Option<FunctionPartialApplicationOpt>),
    GlobalFunctionCall(GlobalFunctionCall),
    GlobalFunctionCallGroup(GlobalFunctionCallGroup),
    Ident(Ident),
    If(If),
    IfEquation(IfEquation),
    IfEquationList(Vec<IfEquationList>),
    IfEquationOpt(Option<IfEquationOpt>),
    IfEquationOptList(Vec<IfEquationOptList>),
    IfExpression(IfExpression),
    IfExpressionList(Vec<IfExpressionList>),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementOpt(Option<IfStatementOpt>),
    IfStatementOptList(Vec<IfStatementOptList>),
    Import(Import),
    ImportClause(ImportClause),
    ImportClauseGroup(ImportClauseGroup),
    ImportClauseOpt(Option<ImportClauseOpt>),
    ImportClauseOptGroup(ImportClauseOptGroup),
    ImportClauseOptGroupGroup(ImportClauseOptGroupGroup),
    ImportList(ImportList),
    ImportListList(Vec<ImportListList>),
    Impure(Impure),
    In(In),
    InheritanceModification(InheritanceModification),
    InheritanceModificationGroup(InheritanceModificationGroup),
    Initial(Initial),
    Inner(Inner),
    Input(Input),
    LanguageSpecification(LanguageSpecification),
    LogicalExpression(LogicalExpression),
    LogicalExpressionList(Vec<LogicalExpressionList>),
    LogicalFactor(LogicalFactor),
    LogicalFactorOpt(Option<LogicalFactorOpt>),
    LogicalTerm(LogicalTerm),
    LogicalTermList(Vec<LogicalTermList>),
    LongClassSpecifier(LongClassSpecifier),
    Loop(Loop),
    Model(Model),
    Modification(Modification),
    ModificationOpt(Option<ModificationOpt>),
    ModificationExpression(ModificationExpression),
    MulOperator(MulOperator),
    Name(Name),
    NameList(Vec<NameList>),
    NamedArgument(NamedArgument),
    NamedArguments(NamedArguments),
    NamedArgumentsOpt(Option<NamedArgumentsOpt>),
    Not(Not),
    Operator(Operator),
    Or(Or),
    Outer(Outer),
    Output(Output),
    OutputExpressionList(OutputExpressionList),
    OutputExpressionListList(Vec<OutputExpressionListList>),
    OutputExpressionListOpt(Option<OutputExpressionListOpt>),
    OutputExpressionListOpt0(Option<OutputExpressionListOpt0>),
    OutputPrimary(OutputPrimary),
    OutputPrimaryOpt(Option<OutputPrimaryOpt>),
    OutputPrimaryOptGroup(OutputPrimaryOptGroup),
    Package(Package),
    Parameter(Parameter),
    Partial(Partial),
    Primary(Primary),
    Protected(Protected),
    Public(Public),
    Pure(Pure),
    RangePrimary(RangePrimary),
    RangePrimaryList(Vec<RangePrimaryList>),
    Record(Record),
    Redeclare(Redeclare),
    Relation(Relation),
    RelationOpt(Option<RelationOpt>),
    RelationalOperator(RelationalOperator),
    Replaceable(Replaceable),
    Return(Return),
    ShortClassDefinition(ShortClassDefinition),
    ShortClassSpecifier(ShortClassSpecifier),
    SimpleEquation(SimpleEquation),
    SimpleEquationOpt(Option<SimpleEquationOpt>),
    SimpleExpression(SimpleExpression),
    SimpleExpressionOpt(Option<SimpleExpressionOpt>),
    SimpleExpressionOpt0(Option<SimpleExpressionOpt0>),
    SomeEquation(SomeEquation),
    SomeEquationOption(SomeEquationOption),
    StandardClassSpecifier(StandardClassSpecifier),
    Statement(Statement),
    StatementBlock(StatementBlock),
    StatementBlockList(Vec<StatementBlockList>),
    StatementOption(StatementOption),
    StoredDefinition(StoredDefinition),
    StoredDefinitionList(Vec<StoredDefinitionList>),
    StoredDefinitionOpt(Option<StoredDefinitionOpt>),
    StoredDefinitionOpt0(Option<StoredDefinitionOpt0>),
    StoredDefinitionOpt1(Option<StoredDefinitionOpt1>),
    Stream(Stream),
    String(String),
    Subscript(Subscript),
    Term(Term),
    TermList(Vec<TermList>),
    Then(Then),
    True(True),
    Type(Type),
    TypeClassSpecifier(TypeClassSpecifier),
    TypeClassSpecifierOpt(Option<TypeClassSpecifierOpt>),
    TypeClassSpecifierOpt0(Option<TypeClassSpecifierOpt0>),
    TypePrefix(TypePrefix),
    TypePrefixOpt(Option<TypePrefixOpt>),
    TypePrefixOpt0(Option<TypePrefixOpt0>),
    TypePrefixOpt0Group(TypePrefixOpt0Group),
    TypePrefixOpt1(Option<TypePrefixOpt1>),
    TypePrefixOpt1Group(TypePrefixOpt1Group),
    TypePrefixOptGroup(TypePrefixOptGroup),
    TypeSpecifier(TypeSpecifier),
    TypeSpecifierOpt(Option<TypeSpecifierOpt>),
    UnsignedInteger(UnsignedInteger),
    UnsignedNumber(UnsignedNumber),
    UnsignedReal(UnsignedReal),
    When(When),
    WhenEquation(WhenEquation),
    WhenEquationList(Vec<WhenEquationList>),
    WhenStatement(WhenStatement),
    WhenStatementList(Vec<WhenStatementList>),
    While(While),
    WhileStatement(WhileStatement),
    WhileStatementList(Vec<WhileStatementList>),
    Within(Within),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ModelicaGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ModelicaGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `ModelicaGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ModelicaGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ModelicaGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData,
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `algorithm: 'algorithm';`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm(&mut self, algorithm: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm = algorithm
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let algorithm_built = Algorithm { algorithm };
        // Calling user action here
        self.user_grammar.algorithm(&algorithm_built)?;
        self.push(ASTType::Algorithm(algorithm_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `and: 'and';`
    ///
    #[parol_runtime::function_name::named]
    fn and(&mut self, and: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let and_built = And { and };
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `annotation: 'annotation';`
    ///
    #[parol_runtime::function_name::named]
    fn annotation(&mut self, annotation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation = annotation
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let annotation_built = Annotation { annotation };
        // Calling user action here
        self.user_grammar.annotation(&annotation_built)?;
        self.push(ASTType::Annotation(annotation_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `block: 'block';`
    ///
    #[parol_runtime::function_name::named]
    fn block(&mut self, block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = block
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let block_built = Block { block };
        // Calling user action here
        self.user_grammar.block(&block_built)?;
        self.push(ASTType::Block(block_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `break: 'break';`
    ///
    #[parol_runtime::function_name::named]
    fn r#break(&mut self, r#break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#break = r#break
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#break_built = Break { r#break };
        // Calling user action here
        self.user_grammar.r#break(&r#break_built)?;
        self.push(ASTType::Break(r#break_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `class: 'class';`
    ///
    #[parol_runtime::function_name::named]
    fn class(&mut self, class: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class = class
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let class_built = Class { class };
        // Calling user action here
        self.user_grammar.class(&class_built)?;
        self.push(ASTType::Class(class_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `connect: 'connect';`
    ///
    #[parol_runtime::function_name::named]
    fn connect(&mut self, connect: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect = connect
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let connect_built = Connect { connect };
        // Calling user action here
        self.user_grammar.connect(&connect_built)?;
        self.push(ASTType::Connect(connect_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `connector: 'connector';`
    ///
    #[parol_runtime::function_name::named]
    fn connector(&mut self, connector: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connector = connector
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let connector_built = Connector { connector };
        // Calling user action here
        self.user_grammar.connector(&connector_built)?;
        self.push(ASTType::Connector(connector_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `constant: 'constant';`
    ///
    #[parol_runtime::function_name::named]
    fn constant(&mut self, constant: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constant = constant
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let constant_built = Constant { constant };
        // Calling user action here
        self.user_grammar.constant(&constant_built)?;
        self.push(ASTType::Constant(constant_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `constrainedby: 'constrainedby';`
    ///
    #[parol_runtime::function_name::named]
    fn constrainedby(&mut self, constrainedby: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constrainedby = constrainedby
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let constrainedby_built = Constrainedby { constrainedby };
        // Calling user action here
        self.user_grammar.constrainedby(&constrainedby_built)?;
        self.push(ASTType::Constrainedby(constrainedby_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `der: 'der';`
    ///
    #[parol_runtime::function_name::named]
    fn der(&mut self, der: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let der = der
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let der_built = Der { der };
        // Calling user action here
        self.user_grammar.der(&der_built)?;
        self.push(ASTType::Der(der_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `discrete: 'discrete';`
    ///
    #[parol_runtime::function_name::named]
    fn discrete(&mut self, discrete: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let discrete = discrete
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let discrete_built = Discrete { discrete };
        // Calling user action here
        self.user_grammar.discrete(&discrete_built)?;
        self.push(ASTType::Discrete(discrete_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `each: 'each';`
    ///
    #[parol_runtime::function_name::named]
    fn each(&mut self, each: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = each
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let each_built = Each { each };
        // Calling user action here
        self.user_grammar.each(&each_built)?;
        self.push(ASTType::Each(each_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `else: 'else';`
    ///
    #[parol_runtime::function_name::named]
    fn r#else(&mut self, r#else: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#else = r#else
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#else_built = Else { r#else };
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `elseif: 'elseif';`
    ///
    #[parol_runtime::function_name::named]
    fn elseif(&mut self, elseif: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let elseif = elseif
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let elseif_built = Elseif { elseif };
        // Calling user action here
        self.user_grammar.elseif(&elseif_built)?;
        self.push(ASTType::Elseif(elseif_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `elsewhen: 'elsewhen';`
    ///
    #[parol_runtime::function_name::named]
    fn elsewhen(&mut self, elsewhen: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let elsewhen = elsewhen
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let elsewhen_built = Elsewhen { elsewhen };
        // Calling user action here
        self.user_grammar.elsewhen(&elsewhen_built)?;
        self.push(ASTType::Elsewhen(elsewhen_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `encapsulated: 'encapsulated';`
    ///
    #[parol_runtime::function_name::named]
    fn encapsulated(&mut self, encapsulated: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let encapsulated = encapsulated
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let encapsulated_built = Encapsulated { encapsulated };
        // Calling user action here
        self.user_grammar.encapsulated(&encapsulated_built)?;
        self.push(ASTType::Encapsulated(encapsulated_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `end: 'end';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `enumeration: 'enumeration';`
    ///
    #[parol_runtime::function_name::named]
    fn enumeration(&mut self, enumeration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enumeration = enumeration
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let enumeration_built = Enumeration { enumeration };
        // Calling user action here
        self.user_grammar.enumeration(&enumeration_built)?;
        self.push(ASTType::Enumeration(enumeration_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `equation: 'equation';`
    ///
    #[parol_runtime::function_name::named]
    fn equation(&mut self, equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation = equation
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let equation_built = Equation { equation };
        // Calling user action here
        self.user_grammar.equation(&equation_built)?;
        self.push(ASTType::Equation(equation_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `expandable: 'expandable';`
    ///
    #[parol_runtime::function_name::named]
    fn expandable(&mut self, expandable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expandable = expandable
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let expandable_built = Expandable { expandable };
        // Calling user action here
        self.user_grammar.expandable(&expandable_built)?;
        self.push(ASTType::Expandable(expandable_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `extends: 'extends';`
    ///
    #[parol_runtime::function_name::named]
    fn extends(&mut self, extends: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extends = extends
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let extends_built = Extends { extends };
        // Calling user action here
        self.user_grammar.extends(&extends_built)?;
        self.push(ASTType::Extends(extends_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `external: 'external';`
    ///
    #[parol_runtime::function_name::named]
    fn external(&mut self, external: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let external = external
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let external_built = External { external };
        // Calling user action here
        self.user_grammar.external(&external_built)?;
        self.push(ASTType::External(external_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `false: 'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `final: 'final';`
    ///
    #[parol_runtime::function_name::named]
    fn r#final(&mut self, r#final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = r#final
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#final_built = Final { r#final };
        // Calling user action here
        self.user_grammar.r#final(&r#final_built)?;
        self.push(ASTType::Final(r#final_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `flow: 'flow';`
    ///
    #[parol_runtime::function_name::named]
    fn flow(&mut self, flow: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let flow = flow
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let flow_built = Flow { flow };
        // Calling user action here
        self.user_grammar.flow(&flow_built)?;
        self.push(ASTType::Flow(flow_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `for: 'for';`
    ///
    #[parol_runtime::function_name::named]
    fn r#for(&mut self, r#for: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#for = r#for
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#for_built = For { r#for };
        // Calling user action here
        self.user_grammar.r#for(&r#for_built)?;
        self.push(ASTType::For(r#for_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `function: 'function';`
    ///
    #[parol_runtime::function_name::named]
    fn function(&mut self, function: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function = function
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let function_built = Function { function };
        // Calling user action here
        self.user_grammar.function(&function_built)?;
        self.push(ASTType::Function(function_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `if: 'if';`
    ///
    #[parol_runtime::function_name::named]
    fn r#if(&mut self, r#if: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if = r#if
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#if_built = If { r#if };
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `import: 'import';`
    ///
    #[parol_runtime::function_name::named]
    fn import(&mut self, import: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import = import
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_built = Import { import };
        // Calling user action here
        self.user_grammar.import(&import_built)?;
        self.push(ASTType::Import(import_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `impure: 'impure';`
    ///
    #[parol_runtime::function_name::named]
    fn impure(&mut self, impure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let impure = impure
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let impure_built = Impure { impure };
        // Calling user action here
        self.user_grammar.impure(&impure_built)?;
        self.push(ASTType::Impure(impure_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `in: 'in';`
    ///
    #[parol_runtime::function_name::named]
    fn r#in(&mut self, r#in: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#in = r#in
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#in_built = In { r#in };
        // Calling user action here
        self.user_grammar.r#in(&r#in_built)?;
        self.push(ASTType::In(r#in_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `initial: 'initial';`
    ///
    #[parol_runtime::function_name::named]
    fn initial(&mut self, initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial = initial
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let initial_built = Initial { initial };
        // Calling user action here
        self.user_grammar.initial(&initial_built)?;
        self.push(ASTType::Initial(initial_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `inner: 'inner';`
    ///
    #[parol_runtime::function_name::named]
    fn inner(&mut self, inner: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inner = inner
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inner_built = Inner { inner };
        // Calling user action here
        self.user_grammar.inner(&inner_built)?;
        self.push(ASTType::Inner(inner_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `input: 'input';`
    ///
    #[parol_runtime::function_name::named]
    fn input(&mut self, input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = input
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let input_built = Input { input };
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `loop: 'loop';`
    ///
    #[parol_runtime::function_name::named]
    fn r#loop(&mut self, r#loop: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#loop = r#loop
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#loop_built = Loop { r#loop };
        // Calling user action here
        self.user_grammar.r#loop(&r#loop_built)?;
        self.push(ASTType::Loop(r#loop_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `model: 'model';`
    ///
    #[parol_runtime::function_name::named]
    fn model(&mut self, model: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let model = model
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let model_built = Model { model };
        // Calling user action here
        self.user_grammar.model(&model_built)?;
        self.push(ASTType::Model(model_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `not: 'not';`
    ///
    #[parol_runtime::function_name::named]
    fn not(&mut self, not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = not
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let not_built = Not { not };
        // Calling user action here
        self.user_grammar.not(&not_built)?;
        self.push(ASTType::Not(not_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `operator: 'operator';`
    ///
    #[parol_runtime::function_name::named]
    fn operator(&mut self, operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = operator
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator_built = Operator { operator };
        // Calling user action here
        self.user_grammar.operator(&operator_built)?;
        self.push(ASTType::Operator(operator_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `or: 'or';`
    ///
    #[parol_runtime::function_name::named]
    fn or(&mut self, or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let or_built = Or { or };
        // Calling user action here
        self.user_grammar.or(&or_built)?;
        self.push(ASTType::Or(or_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `outer: 'outer';`
    ///
    #[parol_runtime::function_name::named]
    fn outer(&mut self, outer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outer = outer
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let outer_built = Outer { outer };
        // Calling user action here
        self.user_grammar.outer(&outer_built)?;
        self.push(ASTType::Outer(outer_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `output: 'output';`
    ///
    #[parol_runtime::function_name::named]
    fn output(&mut self, output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = output
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let output_built = Output { output };
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `package: 'package';`
    ///
    #[parol_runtime::function_name::named]
    fn package(&mut self, package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = package
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let package_built = Package { package };
        // Calling user action here
        self.user_grammar.package(&package_built)?;
        self.push(ASTType::Package(package_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `parameter: 'parameter';`
    ///
    #[parol_runtime::function_name::named]
    fn parameter(&mut self, parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = parameter
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let parameter_built = Parameter { parameter };
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `partial: 'partial';`
    ///
    #[parol_runtime::function_name::named]
    fn partial(&mut self, partial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let partial = partial
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let partial_built = Partial { partial };
        // Calling user action here
        self.user_grammar.partial(&partial_built)?;
        self.push(ASTType::Partial(partial_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `protected: 'protected';`
    ///
    #[parol_runtime::function_name::named]
    fn protected(&mut self, protected: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let protected = protected
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let protected_built = Protected { protected };
        // Calling user action here
        self.user_grammar.protected(&protected_built)?;
        self.push(ASTType::Protected(protected_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `public: 'public';`
    ///
    #[parol_runtime::function_name::named]
    fn public(&mut self, public: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let public = public
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let public_built = Public { public };
        // Calling user action here
        self.user_grammar.public(&public_built)?;
        self.push(ASTType::Public(public_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `pure: 'pure';`
    ///
    #[parol_runtime::function_name::named]
    fn pure(&mut self, pure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pure = pure
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let pure_built = Pure { pure };
        // Calling user action here
        self.user_grammar.pure(&pure_built)?;
        self.push(ASTType::Pure(pure_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `record: 'record';`
    ///
    #[parol_runtime::function_name::named]
    fn record(&mut self, record: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let record = record
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let record_built = Record { record };
        // Calling user action here
        self.user_grammar.record(&record_built)?;
        self.push(ASTType::Record(record_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `redeclare: 'redeclare';`
    ///
    #[parol_runtime::function_name::named]
    fn redeclare(&mut self, redeclare: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let redeclare = redeclare
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let redeclare_built = Redeclare { redeclare };
        // Calling user action here
        self.user_grammar.redeclare(&redeclare_built)?;
        self.push(ASTType::Redeclare(redeclare_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `replaceable: 'replaceable';`
    ///
    #[parol_runtime::function_name::named]
    fn replaceable(&mut self, replaceable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let replaceable = replaceable
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let replaceable_built = Replaceable { replaceable };
        // Calling user action here
        self.user_grammar.replaceable(&replaceable_built)?;
        self.push(ASTType::Replaceable(replaceable_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `return: 'return';`
    ///
    #[parol_runtime::function_name::named]
    fn r#return(&mut self, r#return: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#return = r#return
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#return_built = Return { r#return };
        // Calling user action here
        self.user_grammar.r#return(&r#return_built)?;
        self.push(ASTType::Return(r#return_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `stream: 'stream';`
    ///
    #[parol_runtime::function_name::named]
    fn stream(&mut self, stream: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stream = stream
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let stream_built = Stream { stream };
        // Calling user action here
        self.user_grammar.stream(&stream_built)?;
        self.push(ASTType::Stream(stream_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `then: 'then';`
    ///
    #[parol_runtime::function_name::named]
    fn then(&mut self, then: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then = then
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let then_built = Then { then };
        // Calling user action here
        self.user_grammar.then(&then_built)?;
        self.push(ASTType::Then(then_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `true: 'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `type: 'type';`
    ///
    #[parol_runtime::function_name::named]
    fn r#type(&mut self, r#type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = r#type
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#type_built = Type { r#type };
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `when: 'when';`
    ///
    #[parol_runtime::function_name::named]
    fn when(&mut self, when: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let when = when
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let when_built = When { when };
        // Calling user action here
        self.user_grammar.when(&when_built)?;
        self.push(ASTType::When(when_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `while: 'while';`
    ///
    #[parol_runtime::function_name::named]
    fn r#while(&mut self, r#while: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#while = r#while
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r#while_built = While { r#while };
        // Calling user action here
        self.user_grammar.r#while(&r#while_built)?;
        self.push(ASTType::While(r#while_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `within: 'within';`
    ///
    #[parol_runtime::function_name::named]
    fn within(&mut self, within: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let within = within
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let within_built = Within { within };
        // Calling user action here
        self.user_grammar.within(&within_built)?;
        self.push(ASTType::Within(within_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `ident: /[_a-zA-Z][_a-zA-Z0-9]*/@basic_ident;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_0(&mut self, basic_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_ident = basic_ident
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let ident_0_built = IdentBasicIdent { basic_ident };
        let ident_0_built = Ident::BasicIdent(ident_0_built);
        // Calling user action here
        self.user_grammar.ident(&ident_0_built)?;
        self.push(ASTType::Ident(ident_0_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `ident: /\'[_a-zA-Z0-9!#\$%&\(\)\*\+,-\.\/:;<>=\?@\[\]\^\{\}\|~ \"]*\'/@q_ident;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_1(&mut self, q_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = q_ident
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let ident_1_built = IdentQIdent { q_ident };
        let ident_1_built = Ident::QIdent(ident_1_built);
        // Calling user action here
        self.user_grammar.ident(&ident_1_built)?;
        self.push(ASTType::Ident(ident_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `string: /"[' \w]*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn string(&mut self, string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_built = String { string };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `unsigned_integer: /[0-9]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_integer(&mut self, unsigned_integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_integer = unsigned_integer
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_integer_built = UnsignedInteger { unsigned_integer };
        // Calling user action here
        self.user_grammar
            .unsigned_integer(&unsigned_integer_built)?;
        self.push(ASTType::UnsignedInteger(unsigned_integer_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `unsigned_real: /[0-9]+\.[0-9]+/@decimal;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_0(&mut self, decimal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decimal = decimal
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_0_built = UnsignedRealDecimal { decimal };
        let unsigned_real_0_built = UnsignedReal::Decimal(unsigned_real_0_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_0_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_0_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `unsigned_real: /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_1(&mut self, scientific: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scientific = scientific
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_1_built = UnsignedRealScientific { scientific };
        let unsigned_real_1_built = UnsignedReal::Scientific(unsigned_real_1_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_1_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_1_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `unsigned_real: /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_real_2(&mut self, scientific2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scientific2 = scientific2
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsigned_real_2_built = UnsignedRealScientific2 { scientific2 };
        let unsigned_real_2_built = UnsignedReal::Scientific2(unsigned_real_2_built);
        // Calling user action here
        self.user_grammar.unsigned_real(&unsigned_real_2_built)?;
        self.push(ASTType::UnsignedReal(unsigned_real_2_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `stored_definition: stored_definitionOpt /* Option */ stored_definitionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition(
        &mut self,
        _stored_definition_opt: &ParseTreeType<'t>,
        _stored_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_list =
            pop_and_reverse_item!(self, stored_definition_list, StoredDefinitionList, context);
        let stored_definition_opt =
            pop_item!(self, stored_definition_opt, StoredDefinitionOpt, context);
        let stored_definition_built = StoredDefinition {
            stored_definition_opt,
            stored_definition_list,
        };
        // Calling user action here
        self.user_grammar
            .stored_definition(&stored_definition_built)?;
        self.push(ASTType::StoredDefinition(stored_definition_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `stored_definitionList /* Vec<T>::Push */: stored_definitionOpt0 /* Option */ class_definition ';'^ /* Clipped */ stored_definitionList;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_list_0(
        &mut self,
        _stored_definition_opt0: &ParseTreeType<'t>,
        _class_definition: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _stored_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut stored_definition_list =
            pop_item!(self, stored_definition_list, StoredDefinitionList, context);
        let class_definition = pop_item!(self, class_definition, ClassDefinition, context);
        let stored_definition_opt0 =
            pop_item!(self, stored_definition_opt0, StoredDefinitionOpt0, context);
        let stored_definition_list_0_built = StoredDefinitionList {
            class_definition: (&class_definition)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            stored_definition_opt0,
        };
        // Add an element to the vector
        stored_definition_list.push(stored_definition_list_0_built);
        self.push(
            ASTType::StoredDefinitionList(stored_definition_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `stored_definitionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_list_1_built = Vec::new();
        self.push(
            ASTType::StoredDefinitionList(stored_definition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `stored_definitionOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt0_0(&mut self, _final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let stored_definition_opt0_0_built = StoredDefinitionOpt0 { r#final };
        self.push(
            ASTType::StoredDefinitionOpt0(Some(stored_definition_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `stored_definitionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `stored_definitionOpt /* Option<T>::Some */: within^ /* Clipped */ stored_definitionOpt1 /* Option */ ';'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt_0(
        &mut self,
        _within: &ParseTreeType<'t>,
        _stored_definition_opt1: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stored_definition_opt1 =
            pop_item!(self, stored_definition_opt1, StoredDefinitionOpt1, context);
        self.pop(context);
        let stored_definition_opt_0_built = StoredDefinitionOpt {
            stored_definition_opt1,
        };
        self.push(
            ASTType::StoredDefinitionOpt(Some(stored_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `stored_definitionOpt1 /* Option<T>::Some */: name;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt1_0(&mut self, _name: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let stored_definition_opt1_0_built = StoredDefinitionOpt1 {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::StoredDefinitionOpt1(Some(stored_definition_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `stored_definitionOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `stored_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn stored_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StoredDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `class_definition: class_definitionOpt /* Option */ class_prefixes class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition(
        &mut self,
        _class_definition_opt: &ParseTreeType<'t>,
        _class_prefixes: &ParseTreeType<'t>,
        _class_specifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_specifier = pop_item!(self, class_specifier, ClassSpecifier, context);
        let class_prefixes = pop_item!(self, class_prefixes, ClassPrefixes, context);
        let class_definition_opt =
            pop_item!(self, class_definition_opt, ClassDefinitionOpt, context);
        let class_definition_built = ClassDefinition {
            class_definition_opt,
            class_prefixes,
            class_specifier,
        };
        // Calling user action here
        self.user_grammar
            .class_definition(&class_definition_built)?;
        self.push(ASTType::ClassDefinition(class_definition_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `class_definitionOpt /* Option<T>::Some */: encapsulated;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition_opt_0(&mut self, _encapsulated: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let encapsulated = pop_item!(self, encapsulated, Encapsulated, context);
        let class_definition_opt_0_built = ClassDefinitionOpt { encapsulated };
        self.push(
            ASTType::ClassDefinitionOpt(Some(class_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `class_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `class_type: class;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_0(&mut self, _class: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class = pop_item!(self, class, Class, context);
        let class_type_0_built = ClassTypeClass { class };
        let class_type_0_built = ClassType::Class(class_type_0_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_0_built)?;
        self.push(ASTType::ClassType(class_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `class_type: model;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_1(&mut self, _model: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let model = pop_item!(self, model, Model, context);
        let class_type_1_built = ClassTypeModel { model };
        let class_type_1_built = ClassType::Model(class_type_1_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_1_built)?;
        self.push(ASTType::ClassType(class_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `class_type: class_typeOpt /* Option */ record;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_2(
        &mut self,
        _class_type_opt: &ParseTreeType<'t>,
        _record: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let record = pop_item!(self, record, Record, context);
        let class_type_opt = pop_item!(self, class_type_opt, ClassTypeOpt, context);
        let class_type_2_built = ClassTypeClassTypeOptRecord {
            class_type_opt,
            record,
        };
        let class_type_2_built = ClassType::ClassTypeOptRecord(class_type_2_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_2_built)?;
        self.push(ASTType::ClassType(class_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `class_type: block;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_3(&mut self, _block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = pop_item!(self, block, Block, context);
        let class_type_3_built = ClassTypeBlock { block };
        let class_type_3_built = ClassType::Block(class_type_3_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_3_built)?;
        self.push(ASTType::ClassType(class_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `class_type: class_typeOpt0 /* Option */ connector;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_4(
        &mut self,
        _class_type_opt0: &ParseTreeType<'t>,
        _connector: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connector = pop_item!(self, connector, Connector, context);
        let class_type_opt0 = pop_item!(self, class_type_opt0, ClassTypeOpt0, context);
        let class_type_4_built = ClassTypeClassTypeOpt0Connector {
            class_type_opt0,
            connector,
        };
        let class_type_4_built = ClassType::ClassTypeOpt0Connector(class_type_4_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_4_built)?;
        self.push(ASTType::ClassType(class_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `class_type: type;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_5(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let class_type_5_built = ClassTypeType { r#type };
        let class_type_5_built = ClassType::Type(class_type_5_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_5_built)?;
        self.push(ASTType::ClassType(class_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `class_type: package;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_6(&mut self, _package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = pop_item!(self, package, Package, context);
        let class_type_6_built = ClassTypePackage { package };
        let class_type_6_built = ClassType::Package(class_type_6_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_6_built)?;
        self.push(ASTType::ClassType(class_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `class_type: class_typeOpt1 /* Option */ class_typeOpt2 /* Option */ function;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_7(
        &mut self,
        _class_type_opt1: &ParseTreeType<'t>,
        _class_type_opt2: &ParseTreeType<'t>,
        _function: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function = pop_item!(self, function, Function, context);
        let class_type_opt2 = pop_item!(self, class_type_opt2, ClassTypeOpt2, context);
        let class_type_opt1 = pop_item!(self, class_type_opt1, ClassTypeOpt1, context);
        let class_type_7_built = ClassTypeClassTypeOpt1ClassTypeOpt2Function {
            class_type_opt1,
            class_type_opt2,
            function,
        };
        let class_type_7_built = ClassType::ClassTypeOpt1ClassTypeOpt2Function(class_type_7_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_7_built)?;
        self.push(ASTType::ClassType(class_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `class_type: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_8(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_type_8_built = ClassTypeOperator { operator };
        let class_type_8_built = ClassType::Operator(class_type_8_built);
        // Calling user action here
        self.user_grammar.class_type(&class_type_8_built)?;
        self.push(ASTType::ClassType(class_type_8_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `class_typeOpt2 /* Option<T>::Some */: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt2_0(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_type_opt2_0_built = ClassTypeOpt2 { operator };
        self.push(
            ASTType::ClassTypeOpt2(Some(class_type_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `class_typeOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassTypeOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `class_typeOpt1 /* Option<T>::Some */: class_typeOpt1Group;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt1_0(&mut self, _class_type_opt1_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_type_opt1_group =
            pop_item!(self, class_type_opt1_group, ClassTypeOpt1Group, context);
        let class_type_opt1_0_built = ClassTypeOpt1 {
            class_type_opt1_group,
        };
        self.push(
            ASTType::ClassTypeOpt1(Some(class_type_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `class_typeOpt1Group: pure;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt1_group_0(&mut self, _pure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pure = pop_item!(self, pure, Pure, context);
        let class_type_opt1_group_0_built = ClassTypeOpt1GroupPure { pure };
        let class_type_opt1_group_0_built = ClassTypeOpt1Group::Pure(class_type_opt1_group_0_built);
        self.push(
            ASTType::ClassTypeOpt1Group(class_type_opt1_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `class_typeOpt1Group: impure;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt1_group_1(&mut self, _impure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let impure = pop_item!(self, impure, Impure, context);
        let class_type_opt1_group_1_built = ClassTypeOpt1GroupImpure { impure };
        let class_type_opt1_group_1_built =
            ClassTypeOpt1Group::Impure(class_type_opt1_group_1_built);
        self.push(
            ASTType::ClassTypeOpt1Group(class_type_opt1_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `class_typeOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassTypeOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `class_typeOpt0 /* Option<T>::Some */: expandable;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt0_0(&mut self, _expandable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expandable = pop_item!(self, expandable, Expandable, context);
        let class_type_opt0_0_built = ClassTypeOpt0 { expandable };
        self.push(
            ASTType::ClassTypeOpt0(Some(class_type_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `class_typeOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassTypeOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `class_typeOpt /* Option<T>::Some */: operator;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt_0(&mut self, _operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator = pop_item!(self, operator, Operator, context);
        let class_type_opt_0_built = ClassTypeOpt { operator };
        self.push(ASTType::ClassTypeOpt(Some(class_type_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `class_typeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `class_prefixes: class_prefixesOpt /* Option */ class_type;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes(
        &mut self,
        _class_prefixes_opt: &ParseTreeType<'t>,
        _class_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_type = pop_item!(self, class_type, ClassType, context);
        let class_prefixes_opt = pop_item!(self, class_prefixes_opt, ClassPrefixesOpt, context);
        let class_prefixes_built = ClassPrefixes {
            class_prefixes_opt,
            class_type,
        };
        // Calling user action here
        self.user_grammar.class_prefixes(&class_prefixes_built)?;
        self.push(ASTType::ClassPrefixes(class_prefixes_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `class_prefixesOpt /* Option<T>::Some */: partial;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt_0(&mut self, _partial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let partial = pop_item!(self, partial, Partial, context);
        let class_prefixes_opt_0_built = ClassPrefixesOpt { partial };
        self.push(
            ASTType::ClassPrefixesOpt(Some(class_prefixes_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `class_prefixesOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_prefixes_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassPrefixesOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `class_specifier: long_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_specifier_0(&mut self, _long_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let long_class_specifier =
            pop_item!(self, long_class_specifier, LongClassSpecifier, context);
        let class_specifier_0_built = ClassSpecifierLongClassSpecifier {
            long_class_specifier,
        };
        let class_specifier_0_built = ClassSpecifier::LongClassSpecifier(class_specifier_0_built);
        // Calling user action here
        self.user_grammar
            .class_specifier(&class_specifier_0_built)?;
        self.push(ASTType::ClassSpecifier(class_specifier_0_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `class_specifier: short_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_specifier_1(&mut self, _short_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let short_class_specifier =
            pop_item!(self, short_class_specifier, ShortClassSpecifier, context);
        let class_specifier_1_built = ClassSpecifierShortClassSpecifier {
            short_class_specifier,
        };
        let class_specifier_1_built = ClassSpecifier::ShortClassSpecifier(class_specifier_1_built);
        // Calling user action here
        self.user_grammar
            .class_specifier(&class_specifier_1_built)?;
        self.push(ASTType::ClassSpecifier(class_specifier_1_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `class_specifier: der_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn class_specifier_2(&mut self, _der_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let der_class_specifier = pop_item!(self, der_class_specifier, DerClassSpecifier, context);
        let class_specifier_2_built = ClassSpecifierDerClassSpecifier {
            der_class_specifier,
        };
        let class_specifier_2_built = ClassSpecifier::DerClassSpecifier(class_specifier_2_built);
        // Calling user action here
        self.user_grammar
            .class_specifier(&class_specifier_2_built)?;
        self.push(ASTType::ClassSpecifier(class_specifier_2_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `long_class_specifier: standard_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn long_class_specifier_0(
        &mut self,
        _standard_class_specifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let standard_class_specifier = pop_item!(
            self,
            standard_class_specifier,
            StandardClassSpecifier,
            context
        );
        let long_class_specifier_0_built = LongClassSpecifierStandardClassSpecifier {
            standard_class_specifier,
        };
        let long_class_specifier_0_built =
            LongClassSpecifier::StandardClassSpecifier(long_class_specifier_0_built);
        // Calling user action here
        self.user_grammar
            .long_class_specifier(&long_class_specifier_0_built)?;
        self.push(
            ASTType::LongClassSpecifier(long_class_specifier_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `long_class_specifier: extends_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn long_class_specifier_1(
        &mut self,
        _extends_class_specifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extends_class_specifier = pop_item!(
            self,
            extends_class_specifier,
            ExtendsClassSpecifier,
            context
        );
        let long_class_specifier_1_built = LongClassSpecifierExtendsClassSpecifier {
            extends_class_specifier,
        };
        let long_class_specifier_1_built =
            LongClassSpecifier::ExtendsClassSpecifier(long_class_specifier_1_built);
        // Calling user action here
        self.user_grammar
            .long_class_specifier(&long_class_specifier_1_built)?;
        self.push(
            ASTType::LongClassSpecifier(long_class_specifier_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `standard_class_specifier: ident@name description_string composition end^ /* Clipped */ ident;`
    ///
    #[parol_runtime::function_name::named]
    fn standard_class_specifier(
        &mut self,
        _name: &ParseTreeType<'t>,
        _description_string: &ParseTreeType<'t>,
        _composition: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        self.pop(context);
        let composition = pop_item!(self, composition, Composition, context);
        let description_string = pop_item!(self, description_string, DescriptionString, context);
        let name = pop_item!(self, name, Ident, context);
        let standard_class_specifier_built = StandardClassSpecifier {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description_string: (&description_string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            composition: (&composition)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .standard_class_specifier(&standard_class_specifier_built)?;
        self.push(
            ASTType::StandardClassSpecifier(standard_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `extends_class_specifier: extends^ /* Clipped */ ident extends_class_specifierOpt /* Option */ description_string composition end^ /* Clipped */ ident;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_class_specifier(
        &mut self,
        _extends: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _extends_class_specifier_opt: &ParseTreeType<'t>,
        _description_string: &ParseTreeType<'t>,
        _composition: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _ident0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident0 = pop_item!(self, ident0, Ident, context);
        self.pop(context);
        let composition = pop_item!(self, composition, Composition, context);
        let description_string = pop_item!(self, description_string, DescriptionString, context);
        let extends_class_specifier_opt = pop_item!(
            self,
            extends_class_specifier_opt,
            ExtendsClassSpecifierOpt,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        self.pop(context);
        let extends_class_specifier_built = ExtendsClassSpecifier {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            extends_class_specifier_opt,
            description_string: (&description_string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            composition: (&composition)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            ident0: (&ident0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .extends_class_specifier(&extends_class_specifier_built)?;
        self.push(
            ASTType::ExtendsClassSpecifier(extends_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `extends_class_specifierOpt /* Option<T>::Some */: class_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_class_specifier_opt_0(
        &mut self,
        _class_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_modification = pop_item!(self, class_modification, ClassModification, context);
        let extends_class_specifier_opt_0_built = ExtendsClassSpecifierOpt { class_modification };
        self.push(
            ASTType::ExtendsClassSpecifierOpt(Some(extends_class_specifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `extends_class_specifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_class_specifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExtendsClassSpecifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `short_class_specifier: type_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn short_class_specifier_0(&mut self, _type_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_class_specifier =
            pop_item!(self, type_class_specifier, TypeClassSpecifier, context);
        let short_class_specifier_0_built = ShortClassSpecifierTypeClassSpecifier {
            type_class_specifier: Box::new(type_class_specifier),
        };
        let short_class_specifier_0_built =
            ShortClassSpecifier::TypeClassSpecifier(short_class_specifier_0_built);
        // Calling user action here
        self.user_grammar
            .short_class_specifier(&short_class_specifier_0_built)?;
        self.push(
            ASTType::ShortClassSpecifier(short_class_specifier_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `short_class_specifier: enum_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn short_class_specifier_1(&mut self, _enum_class_specifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_class_specifier =
            pop_item!(self, enum_class_specifier, EnumClassSpecifier, context);
        let short_class_specifier_1_built = ShortClassSpecifierEnumClassSpecifier {
            enum_class_specifier: Box::new(enum_class_specifier),
        };
        let short_class_specifier_1_built =
            ShortClassSpecifier::EnumClassSpecifier(short_class_specifier_1_built);
        // Calling user action here
        self.user_grammar
            .short_class_specifier(&short_class_specifier_1_built)?;
        self.push(
            ASTType::ShortClassSpecifier(short_class_specifier_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `type_class_specifier: ident '='^ /* Clipped */ base_prefix type_specifier type_class_specifierOpt /* Option */ type_class_specifierOpt0 /* Option */ description;`
    ///
    #[parol_runtime::function_name::named]
    fn type_class_specifier(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _base_prefix: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _type_class_specifier_opt: &ParseTreeType<'t>,
        _type_class_specifier_opt0: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let type_class_specifier_opt0 = pop_item!(
            self,
            type_class_specifier_opt0,
            TypeClassSpecifierOpt0,
            context
        );
        let type_class_specifier_opt = pop_item!(
            self,
            type_class_specifier_opt,
            TypeClassSpecifierOpt,
            context
        );
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let base_prefix = pop_item!(self, base_prefix, BasePrefix, context);
        let ident = pop_item!(self, ident, Ident, context);
        let type_class_specifier_built = TypeClassSpecifier {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            base_prefix,
            type_specifier,
            type_class_specifier_opt,
            type_class_specifier_opt0,
            description,
        };
        // Calling user action here
        self.user_grammar
            .type_class_specifier(&type_class_specifier_built)?;
        self.push(
            ASTType::TypeClassSpecifier(type_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `type_class_specifierOpt0 /* Option<T>::Some */: class_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn type_class_specifier_opt0_0(
        &mut self,
        _class_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_modification = pop_item!(self, class_modification, ClassModification, context);
        let type_class_specifier_opt0_0_built = TypeClassSpecifierOpt0 { class_modification };
        self.push(
            ASTType::TypeClassSpecifierOpt0(Some(type_class_specifier_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `type_class_specifierOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_class_specifier_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeClassSpecifierOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `type_class_specifierOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn type_class_specifier_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let type_class_specifier_opt_0_built = TypeClassSpecifierOpt {
            array_subscripts: (&array_subscripts)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::TypeClassSpecifierOpt(Some(type_class_specifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `type_class_specifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_class_specifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeClassSpecifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `enum_class_specifier: ident '='^ /* Clipped */ enumeration '('^ /* Clipped */ enum_class_specifierGroup ')'^ /* Clipped */ description;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_class_specifier(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _enumeration: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _enum_class_specifier_group: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let enum_class_specifier_group = pop_item!(
            self,
            enum_class_specifier_group,
            EnumClassSpecifierGroup,
            context
        );
        let enumeration = pop_item!(self, enumeration, Enumeration, context);
        let ident = pop_item!(self, ident, Ident, context);
        let enum_class_specifier_built = EnumClassSpecifier {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            enumeration,
            enum_class_specifier_group,
            description,
        };
        // Calling user action here
        self.user_grammar
            .enum_class_specifier(&enum_class_specifier_built)?;
        self.push(
            ASTType::EnumClassSpecifier(enum_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `enum_class_specifierGroup: enum_class_specifierOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_class_specifier_group_0(
        &mut self,
        _enum_class_specifier_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_class_specifier_opt = pop_item!(
            self,
            enum_class_specifier_opt,
            EnumClassSpecifierOpt,
            context
        );
        let enum_class_specifier_group_0_built = EnumClassSpecifierGroupEnumClassSpecifierOpt {
            enum_class_specifier_opt: enum_class_specifier_opt.map(Box::new),
        };
        let enum_class_specifier_group_0_built =
            EnumClassSpecifierGroup::EnumClassSpecifierOpt(enum_class_specifier_group_0_built);
        self.push(
            ASTType::EnumClassSpecifierGroup(enum_class_specifier_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `enum_class_specifierGroup: ':'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_class_specifier_group_1(&mut self, _colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_class_specifier_group_1_built = EnumClassSpecifierGroupColon {};
        let enum_class_specifier_group_1_built =
            EnumClassSpecifierGroup::Colon(enum_class_specifier_group_1_built);
        self.push(
            ASTType::EnumClassSpecifierGroup(enum_class_specifier_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `enum_class_specifierOpt /* Option<T>::Some */: enum_list;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_class_specifier_opt_0(&mut self, _enum_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let enum_class_specifier_opt_0_built = EnumClassSpecifierOpt { enum_list };
        self.push(
            ASTType::EnumClassSpecifierOpt(Some(enum_class_specifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `enum_class_specifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_class_specifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumClassSpecifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `der_class_specifier: ident '='^ /* Clipped */ der '('^ /* Clipped */ type_specifier ','^ /* Clipped */ ident der_class_specifierList /* Vec */ ')'^ /* Clipped */ description;`
    ///
    #[parol_runtime::function_name::named]
    fn der_class_specifier(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _der: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _ident0: &ParseTreeType<'t>,
        _der_class_specifier_list: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let der_class_specifier_list = pop_and_reverse_item!(
            self,
            der_class_specifier_list,
            DerClassSpecifierList,
            context
        );
        let ident0 = pop_item!(self, ident0, Ident, context);
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let der = pop_item!(self, der, Der, context);
        let ident = pop_item!(self, ident, Ident, context);
        let der_class_specifier_built = DerClassSpecifier {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            der,
            type_specifier,
            ident0: (&ident0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            der_class_specifier_list,
            description,
        };
        // Calling user action here
        self.user_grammar
            .der_class_specifier(&der_class_specifier_built)?;
        self.push(
            ASTType::DerClassSpecifier(der_class_specifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `der_class_specifierList /* Vec<T>::Push */: ','^ /* Clipped */ ident der_class_specifierList;`
    ///
    #[parol_runtime::function_name::named]
    fn der_class_specifier_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _der_class_specifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut der_class_specifier_list = pop_item!(
            self,
            der_class_specifier_list,
            DerClassSpecifierList,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        let der_class_specifier_list_0_built = DerClassSpecifierList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        der_class_specifier_list.push(der_class_specifier_list_0_built);
        self.push(
            ASTType::DerClassSpecifierList(der_class_specifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `der_class_specifierList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn der_class_specifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let der_class_specifier_list_1_built = Vec::new();
        self.push(
            ASTType::DerClassSpecifierList(der_class_specifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `base_prefix: base_prefixOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn base_prefix(&mut self, _base_prefix_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_prefix_opt = pop_item!(self, base_prefix_opt, BasePrefixOpt, context);
        let base_prefix_built = BasePrefix { base_prefix_opt };
        // Calling user action here
        self.user_grammar.base_prefix(&base_prefix_built)?;
        self.push(ASTType::BasePrefix(base_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `base_prefixOpt /* Option<T>::Some */: base_prefixOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn base_prefix_opt_0(&mut self, _base_prefix_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_prefix_opt_group =
            pop_item!(self, base_prefix_opt_group, BasePrefixOptGroup, context);
        let base_prefix_opt_0_built = BasePrefixOpt {
            base_prefix_opt_group,
        };
        self.push(
            ASTType::BasePrefixOpt(Some(base_prefix_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `base_prefixOptGroup: input;`
    ///
    #[parol_runtime::function_name::named]
    fn base_prefix_opt_group_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let base_prefix_opt_group_0_built = BasePrefixOptGroupInput { input };
        let base_prefix_opt_group_0_built =
            BasePrefixOptGroup::Input(base_prefix_opt_group_0_built);
        self.push(
            ASTType::BasePrefixOptGroup(base_prefix_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `base_prefixOptGroup: output;`
    ///
    #[parol_runtime::function_name::named]
    fn base_prefix_opt_group_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let base_prefix_opt_group_1_built = BasePrefixOptGroupOutput { output };
        let base_prefix_opt_group_1_built =
            BasePrefixOptGroup::Output(base_prefix_opt_group_1_built);
        self.push(
            ASTType::BasePrefixOptGroup(base_prefix_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `base_prefixOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn base_prefix_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BasePrefixOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `enum_list: enumeration_literal enum_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list(
        &mut self,
        _enumeration_literal: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_list = pop_and_reverse_item!(self, enum_list_list, EnumListList, context);
        let enumeration_literal = pop_item!(self, enumeration_literal, EnumerationLiteral, context);
        let enum_list_built = EnumList {
            enumeration_literal,
            enum_list_list,
        };
        // Calling user action here
        self.user_grammar.enum_list(&enum_list_built)?;
        self.push(ASTType::EnumList(enum_list_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `enum_listList /* Vec<T>::Push */: ','^ /* Clipped */ enumeration_literal enum_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _enumeration_literal: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_list_list = pop_item!(self, enum_list_list, EnumListList, context);
        let enumeration_literal = pop_item!(self, enumeration_literal, EnumerationLiteral, context);
        let enum_list_list_0_built = EnumListList {
            enumeration_literal,
        };
        // Add an element to the vector
        enum_list_list.push(enum_list_list_0_built);
        self.push(ASTType::EnumListList(enum_list_list), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `enum_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_list_1_built = Vec::new();
        self.push(ASTType::EnumListList(enum_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `enumeration_literal: ident description;`
    ///
    #[parol_runtime::function_name::named]
    fn enumeration_literal(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let ident = pop_item!(self, ident, Ident, context);
        let enumeration_literal_built = EnumerationLiteral {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description,
        };
        // Calling user action here
        self.user_grammar
            .enumeration_literal(&enumeration_literal_built)?;
        self.push(
            ASTType::EnumerationLiteral(enumeration_literal_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `composition: element_list compositionList /* Vec */ compositionOpt /* Option */ compositionOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn composition(
        &mut self,
        _element_list: &ParseTreeType<'t>,
        _composition_list: &ParseTreeType<'t>,
        _composition_opt: &ParseTreeType<'t>,
        _composition_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let composition_opt0 = pop_item!(self, composition_opt0, CompositionOpt0, context);
        let composition_opt = pop_item!(self, composition_opt, CompositionOpt, context);
        let composition_list =
            pop_and_reverse_item!(self, composition_list, CompositionList, context);
        let element_list = pop_item!(self, element_list, ElementList, context);
        let composition_built = Composition {
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            composition_list,
            composition_opt,
            composition_opt0,
        };
        // Calling user action here
        self.user_grammar.composition(&composition_built)?;
        self.push(ASTType::Composition(composition_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `compositionList /* Vec<T>::Push */: compositionListGroup compositionList;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_0(
        &mut self,
        _composition_list_group: &ParseTreeType<'t>,
        _composition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut composition_list = pop_item!(self, composition_list, CompositionList, context);
        let composition_list_group =
            pop_item!(self, composition_list_group, CompositionListGroup, context);
        let composition_list_0_built = CompositionList {
            composition_list_group,
        };
        // Add an element to the vector
        composition_list.push(composition_list_0_built);
        self.push(ASTType::CompositionList(composition_list), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `compositionListGroup: public element_list;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_0(
        &mut self,
        _public: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list = pop_item!(self, element_list, ElementList, context);
        let public = pop_item!(self, public, Public, context);
        let composition_list_group_0_built = CompositionListGroupPublicElementList {
            public,
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_0_built =
            CompositionListGroup::PublicElementList(composition_list_group_0_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `compositionListGroup: protected element_list;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_1(
        &mut self,
        _protected: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list = pop_item!(self, element_list, ElementList, context);
        let protected = pop_item!(self, protected, Protected, context);
        let composition_list_group_1_built = CompositionListGroupProtectedElementList {
            protected,
            element_list: (&element_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_1_built =
            CompositionListGroup::ProtectedElementList(composition_list_group_1_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `compositionListGroup: equation_section;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_2(&mut self, _equation_section: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section = pop_item!(self, equation_section, EquationSection, context);
        let composition_list_group_2_built = CompositionListGroupEquationSection {
            equation_section: (&equation_section)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_2_built =
            CompositionListGroup::EquationSection(composition_list_group_2_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `compositionListGroup: algorithm_section;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_group_3(&mut self, _algorithm_section: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section = pop_item!(self, algorithm_section, AlgorithmSection, context);
        let composition_list_group_3_built = CompositionListGroupAlgorithmSection {
            algorithm_section: (&algorithm_section)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let composition_list_group_3_built =
            CompositionListGroup::AlgorithmSection(composition_list_group_3_built);
        self.push(
            ASTType::CompositionListGroup(composition_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `compositionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let composition_list_1_built = Vec::new();
        self.push(ASTType::CompositionList(composition_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `compositionOpt0 /* Option<T>::Some */: annotation_clause ';'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt0_0(
        &mut self,
        _annotation_clause: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation_clause = pop_item!(self, annotation_clause, AnnotationClause, context);
        let composition_opt0_0_built = CompositionOpt0 { annotation_clause };
        self.push(
            ASTType::CompositionOpt0(Some(composition_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `compositionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CompositionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `compositionOpt /* Option<T>::Some */: external^ /* Clipped */ compositionOpt1 /* Option */ compositionOpt2 /* Option */ compositionOpt3 /* Option */ ';'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt_0(
        &mut self,
        _external: &ParseTreeType<'t>,
        _composition_opt1: &ParseTreeType<'t>,
        _composition_opt2: &ParseTreeType<'t>,
        _composition_opt3: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let composition_opt3 = pop_item!(self, composition_opt3, CompositionOpt3, context);
        let composition_opt2 = pop_item!(self, composition_opt2, CompositionOpt2, context);
        let composition_opt1 = pop_item!(self, composition_opt1, CompositionOpt1, context);
        self.pop(context);
        let composition_opt_0_built = CompositionOpt {
            composition_opt1,
            composition_opt2,
            composition_opt3,
        };
        self.push(
            ASTType::CompositionOpt(Some(composition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `compositionOpt3 /* Option<T>::Some */: annotation_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt3_0(&mut self, _annotation_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation_clause = pop_item!(self, annotation_clause, AnnotationClause, context);
        let composition_opt3_0_built = CompositionOpt3 { annotation_clause };
        self.push(
            ASTType::CompositionOpt3(Some(composition_opt3_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `compositionOpt3 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt3_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CompositionOpt3(None), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `compositionOpt2 /* Option<T>::Some */: external_function_call;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt2_0(&mut self, _external_function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let external_function_call =
            pop_item!(self, external_function_call, ExternalFunctionCall, context);
        let composition_opt2_0_built = CompositionOpt2 {
            external_function_call,
        };
        self.push(
            ASTType::CompositionOpt2(Some(composition_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `compositionOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CompositionOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `compositionOpt1 /* Option<T>::Some */: language_specification;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt1_0(&mut self, _language_specification: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let language_specification =
            pop_item!(self, language_specification, LanguageSpecification, context);
        let composition_opt1_0_built = CompositionOpt1 {
            language_specification,
        };
        self.push(
            ASTType::CompositionOpt1(Some(composition_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `compositionOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CompositionOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `compositionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn composition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CompositionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `language_specification: string;`
    ///
    #[parol_runtime::function_name::named]
    fn language_specification(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let language_specification_built = LanguageSpecification {
            string: (&string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .language_specification(&language_specification_built)?;
        self.push(
            ASTType::LanguageSpecification(language_specification_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `external_function_call: external_function_callOpt /* Option */ ident '('^ /* Clipped */ external_function_callOpt0 /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn external_function_call(
        &mut self,
        _external_function_call_opt: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _external_function_call_opt0: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let external_function_call_opt0 = pop_item!(
            self,
            external_function_call_opt0,
            ExternalFunctionCallOpt0,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        let external_function_call_opt = pop_item!(
            self,
            external_function_call_opt,
            ExternalFunctionCallOpt,
            context
        );
        let external_function_call_built = ExternalFunctionCall {
            external_function_call_opt,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            external_function_call_opt0,
        };
        // Calling user action here
        self.user_grammar
            .external_function_call(&external_function_call_built)?;
        self.push(
            ASTType::ExternalFunctionCall(external_function_call_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `external_function_callOpt0 /* Option<T>::Some */: expression_list;`
    ///
    #[parol_runtime::function_name::named]
    fn external_function_call_opt0_0(
        &mut self,
        _expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list = pop_item!(self, expression_list, ExpressionList, context);
        let external_function_call_opt0_0_built = ExternalFunctionCallOpt0 { expression_list };
        self.push(
            ASTType::ExternalFunctionCallOpt0(Some(external_function_call_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `external_function_callOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn external_function_call_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExternalFunctionCallOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `external_function_callOpt /* Option<T>::Some */: component_reference '='^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn external_function_call_opt_0(
        &mut self,
        _component_reference: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let external_function_call_opt_0_built = ExternalFunctionCallOpt {
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ExternalFunctionCallOpt(Some(external_function_call_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `external_function_callOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn external_function_call_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExternalFunctionCallOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `element_list: element_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list(&mut self, _element_list_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list_list =
            pop_and_reverse_item!(self, element_list_list, ElementListList, context);
        let element_list_built = ElementList { element_list_list };
        // Calling user action here
        self.user_grammar.element_list(&element_list_built)?;
        self.push(ASTType::ElementList(element_list_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `element_listList /* Vec<T>::Push */: element ';'^ /* Clipped */ element_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list_list_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _element_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut element_list_list = pop_item!(self, element_list_list, ElementListList, context);
        let element = pop_item!(self, element, Element, context);
        let element_list_list_0_built = ElementListList { element };
        // Add an element to the vector
        element_list_list.push(element_list_list_0_built);
        self.push(ASTType::ElementListList(element_list_list), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// `element_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list_list_1_built = Vec::new();
        self.push(ASTType::ElementListList(element_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// `element: import_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_0(&mut self, _import_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause = pop_item!(self, import_clause, ImportClause, context);
        let element_0_built = ElementImportClause { import_clause };
        let element_0_built = Element::ImportClause(element_0_built);
        // Calling user action here
        self.user_grammar.element(&element_0_built)?;
        self.push(ASTType::Element(element_0_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// `element: extends_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_1(&mut self, _extends_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extends_clause = pop_item!(self, extends_clause, ExtendsClause, context);
        let element_1_built = ElementExtendsClause { extends_clause };
        let element_1_built = Element::ExtendsClause(element_1_built);
        // Calling user action here
        self.user_grammar.element(&element_1_built)?;
        self.push(ASTType::Element(element_1_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// `element: element_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_2(&mut self, _element_definition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_definition = pop_item!(self, element_definition, ElementDefinition, context);
        let element_2_built = ElementElementDefinition { element_definition };
        let element_2_built = Element::ElementDefinition(element_2_built);
        // Calling user action here
        self.user_grammar.element(&element_2_built)?;
        self.push(ASTType::Element(element_2_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// `element: element_replaceable_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_3(&mut self, _element_replaceable_definition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_replaceable_definition = pop_item!(
            self,
            element_replaceable_definition,
            ElementReplaceableDefinition,
            context
        );
        let element_3_built = ElementElementReplaceableDefinition {
            element_replaceable_definition,
        };
        let element_3_built = Element::ElementReplaceableDefinition(element_3_built);
        // Calling user action here
        self.user_grammar.element(&element_3_built)?;
        self.push(ASTType::Element(element_3_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// `element_definition: element_definitionOpt /* Option */ element_definitionOpt0 /* Option */ element_definitionOpt1 /* Option */ element_definitionOpt2 /* Option */ element_definitionGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition(
        &mut self,
        _element_definition_opt: &ParseTreeType<'t>,
        _element_definition_opt0: &ParseTreeType<'t>,
        _element_definition_opt1: &ParseTreeType<'t>,
        _element_definition_opt2: &ParseTreeType<'t>,
        _element_definition_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_definition_group = pop_item!(
            self,
            element_definition_group,
            ElementDefinitionGroup,
            context
        );
        let element_definition_opt2 = pop_item!(
            self,
            element_definition_opt2,
            ElementDefinitionOpt2,
            context
        );
        let element_definition_opt1 = pop_item!(
            self,
            element_definition_opt1,
            ElementDefinitionOpt1,
            context
        );
        let element_definition_opt0 = pop_item!(
            self,
            element_definition_opt0,
            ElementDefinitionOpt0,
            context
        );
        let element_definition_opt =
            pop_item!(self, element_definition_opt, ElementDefinitionOpt, context);
        let element_definition_built = ElementDefinition {
            element_definition_opt,
            element_definition_opt0,
            element_definition_opt1,
            element_definition_opt2,
            element_definition_group,
        };
        // Calling user action here
        self.user_grammar
            .element_definition(&element_definition_built)?;
        self.push(
            ASTType::ElementDefinition(element_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// `element_definitionGroup: class_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_group_0(&mut self, _class_definition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_definition = pop_item!(self, class_definition, ClassDefinition, context);
        let element_definition_group_0_built = ElementDefinitionGroupClassDefinition {
            class_definition: (&class_definition)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let element_definition_group_0_built =
            ElementDefinitionGroup::ClassDefinition(element_definition_group_0_built);
        self.push(
            ASTType::ElementDefinitionGroup(element_definition_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// `element_definitionGroup: component_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_group_1(&mut self, _component_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_clause = pop_item!(self, component_clause, ComponentClause, context);
        let element_definition_group_1_built =
            ElementDefinitionGroupComponentClause { component_clause };
        let element_definition_group_1_built =
            ElementDefinitionGroup::ComponentClause(element_definition_group_1_built);
        self.push(
            ASTType::ElementDefinitionGroup(element_definition_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// `element_definitionOpt2 /* Option<T>::Some */: outer;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt2_0(&mut self, _outer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outer = pop_item!(self, outer, Outer, context);
        let element_definition_opt2_0_built = ElementDefinitionOpt2 { outer };
        self.push(
            ASTType::ElementDefinitionOpt2(Some(element_definition_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// `element_definitionOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementDefinitionOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// `element_definitionOpt1 /* Option<T>::Some */: inner;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt1_0(&mut self, _inner: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inner = pop_item!(self, inner, Inner, context);
        let element_definition_opt1_0_built = ElementDefinitionOpt1 { inner };
        self.push(
            ASTType::ElementDefinitionOpt1(Some(element_definition_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// `element_definitionOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementDefinitionOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// `element_definitionOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt0_0(&mut self, _final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let element_definition_opt0_0_built = ElementDefinitionOpt0 { r#final };
        self.push(
            ASTType::ElementDefinitionOpt0(Some(element_definition_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// `element_definitionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementDefinitionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// `element_definitionOpt /* Option<T>::Some */: redeclare;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt_0(&mut self, _redeclare: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let redeclare = pop_item!(self, redeclare, Redeclare, context);
        let element_definition_opt_0_built = ElementDefinitionOpt { redeclare };
        self.push(
            ASTType::ElementDefinitionOpt(Some(element_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// `element_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// `element_replaceable_definition: replaceable element_replaceable_definitionGroup element_replaceable_definitionOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_definition(
        &mut self,
        _replaceable: &ParseTreeType<'t>,
        _element_replaceable_definition_group: &ParseTreeType<'t>,
        _element_replaceable_definition_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_replaceable_definition_opt = pop_item!(
            self,
            element_replaceable_definition_opt,
            ElementReplaceableDefinitionOpt,
            context
        );
        let element_replaceable_definition_group = pop_item!(
            self,
            element_replaceable_definition_group,
            ElementReplaceableDefinitionGroup,
            context
        );
        let replaceable = pop_item!(self, replaceable, Replaceable, context);
        let element_replaceable_definition_built = ElementReplaceableDefinition {
            replaceable,
            element_replaceable_definition_group,
            element_replaceable_definition_opt,
        };
        // Calling user action here
        self.user_grammar
            .element_replaceable_definition(&element_replaceable_definition_built)?;
        self.push(
            ASTType::ElementReplaceableDefinition(element_replaceable_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// `element_replaceable_definitionGroup: class_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_definition_group_0(
        &mut self,
        _class_definition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_definition = pop_item!(self, class_definition, ClassDefinition, context);
        let element_replaceable_definition_group_0_built =
            ElementReplaceableDefinitionGroupClassDefinition {
                class_definition: (&class_definition)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            };
        let element_replaceable_definition_group_0_built =
            ElementReplaceableDefinitionGroup::ClassDefinition(
                element_replaceable_definition_group_0_built,
            );
        self.push(
            ASTType::ElementReplaceableDefinitionGroup(
                element_replaceable_definition_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// `element_replaceable_definitionGroup: component_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_definition_group_1(
        &mut self,
        _component_clause: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_clause = pop_item!(self, component_clause, ComponentClause, context);
        let element_replaceable_definition_group_1_built =
            ElementReplaceableDefinitionGroupComponentClause { component_clause };
        let element_replaceable_definition_group_1_built =
            ElementReplaceableDefinitionGroup::ComponentClause(
                element_replaceable_definition_group_1_built,
            );
        self.push(
            ASTType::ElementReplaceableDefinitionGroup(
                element_replaceable_definition_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// `element_replaceable_definitionOpt /* Option<T>::Some */: constraining_clause description;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_definition_opt_0(
        &mut self,
        _constraining_clause: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let constraining_clause = pop_item!(self, constraining_clause, ConstrainingClause, context);
        let element_replaceable_definition_opt_0_built = ElementReplaceableDefinitionOpt {
            constraining_clause,
            description,
        };
        self.push(
            ASTType::ElementReplaceableDefinitionOpt(Some(
                element_replaceable_definition_opt_0_built,
            )),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// `element_replaceable_definitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementReplaceableDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// `import_clause: import import_clauseGroup description;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause(
        &mut self,
        _import: &ParseTreeType<'t>,
        _import_clause_group: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let import_clause_group = pop_item!(self, import_clause_group, ImportClauseGroup, context);
        let import = pop_item!(self, import, Import, context);
        let import_clause_built = ImportClause {
            import,
            import_clause_group,
            description,
        };
        // Calling user action here
        self.user_grammar.import_clause(&import_clause_built)?;
        self.push(ASTType::ImportClause(import_clause_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// `import_clauseGroup: ident '='^ /* Clipped */ name;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_group_0(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_clause_group_0_built = ImportClauseGroupIdentEquName {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let import_clause_group_0_built =
            ImportClauseGroup::IdentEquName(import_clause_group_0_built);
        self.push(
            ASTType::ImportClauseGroup(import_clause_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// `import_clauseGroup: name import_clauseOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_group_1(
        &mut self,
        _name: &ParseTreeType<'t>,
        _import_clause_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause_opt = pop_item!(self, import_clause_opt, ImportClauseOpt, context);
        let name = pop_item!(self, name, Name, context);
        let import_clause_group_1_built = ImportClauseGroupNameImportClauseOpt {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            import_clause_opt,
        };
        let import_clause_group_1_built =
            ImportClauseGroup::NameImportClauseOpt(import_clause_group_1_built);
        self.push(
            ASTType::ImportClauseGroup(import_clause_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// `import_clauseOpt /* Option<T>::Some */: import_clauseOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_0(&mut self, _import_clause_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_clause_opt_group =
            pop_item!(self, import_clause_opt_group, ImportClauseOptGroup, context);
        let import_clause_opt_0_built = ImportClauseOpt {
            import_clause_opt_group,
        };
        self.push(
            ASTType::ImportClauseOpt(Some(import_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// `import_clauseOptGroup: '.*';`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_0(&mut self, dot_star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_star = dot_star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_clause_opt_group_0_built = ImportClauseOptGroupDotStar { dot_star };
        let import_clause_opt_group_0_built =
            ImportClauseOptGroup::DotStar(import_clause_opt_group_0_built);
        self.push(
            ASTType::ImportClauseOptGroup(import_clause_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// `import_clauseOptGroup: '.' import_clauseOptGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_1(
        &mut self,
        dot: &ParseTreeType<'t>,
        _import_clause_opt_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot = dot
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_clause_opt_group_group = pop_item!(
            self,
            import_clause_opt_group_group,
            ImportClauseOptGroupGroup,
            context
        );
        let import_clause_opt_group_1_built = ImportClauseOptGroupDotImportClauseOptGroupGroup {
            dot,
            import_clause_opt_group_group,
        };
        let import_clause_opt_group_1_built =
            ImportClauseOptGroup::DotImportClauseOptGroupGroup(import_clause_opt_group_1_built);
        self.push(
            ASTType::ImportClauseOptGroup(import_clause_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// `import_clauseOptGroupGroup: '*';`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_group_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_clause_opt_group_group_0_built = ImportClauseOptGroupGroupStar { star };
        let import_clause_opt_group_group_0_built =
            ImportClauseOptGroupGroup::Star(import_clause_opt_group_group_0_built);
        self.push(
            ASTType::ImportClauseOptGroupGroup(import_clause_opt_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// `import_clauseOptGroupGroup: '{'^ /* Clipped */ import_list '}'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_group_group_1(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _import_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list = pop_item!(self, import_list, ImportList, context);
        let import_clause_opt_group_group_1_built =
            ImportClauseOptGroupGroupLBraceImportListRBrace { import_list };
        let import_clause_opt_group_group_1_built =
            ImportClauseOptGroupGroup::LBraceImportListRBrace(
                import_clause_opt_group_group_1_built,
            );
        self.push(
            ASTType::ImportClauseOptGroupGroup(import_clause_opt_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// `import_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// `import_list: ident import_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list =
            pop_and_reverse_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_built = ImportList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            import_list_list,
        };
        // Calling user action here
        self.user_grammar.import_list(&import_list_built)?;
        self.push(ASTType::ImportList(import_list_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// `import_listList /* Vec<T>::Push */: ','^ /* Clipped */ ident import_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut import_list_list = pop_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_list_0_built = ImportListList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        import_list_list.push(import_list_list_0_built);
        self.push(ASTType::ImportListList(import_list_list), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// `import_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list_1_built = Vec::new();
        self.push(ASTType::ImportListList(import_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// `extends_clause: extends^ /* Clipped */ type_specifier extends_clauseOpt /* Option */ extends_clauseOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_clause(
        &mut self,
        _extends: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _extends_clause_opt: &ParseTreeType<'t>,
        _extends_clause_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extends_clause_opt0 = pop_item!(self, extends_clause_opt0, ExtendsClauseOpt0, context);
        let extends_clause_opt = pop_item!(self, extends_clause_opt, ExtendsClauseOpt, context);
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        self.pop(context);
        let extends_clause_built = ExtendsClause {
            type_specifier,
            extends_clause_opt,
            extends_clause_opt0,
        };
        // Calling user action here
        self.user_grammar.extends_clause(&extends_clause_built)?;
        self.push(ASTType::ExtendsClause(extends_clause_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// `extends_clauseOpt0 /* Option<T>::Some */: annotation_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_clause_opt0_0(&mut self, _annotation_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation_clause = pop_item!(self, annotation_clause, AnnotationClause, context);
        let extends_clause_opt0_0_built = ExtendsClauseOpt0 { annotation_clause };
        self.push(
            ASTType::ExtendsClauseOpt0(Some(extends_clause_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// `extends_clauseOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_clause_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExtendsClauseOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// `extends_clauseOpt /* Option<T>::Some */: class_or_inheritance_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_clause_opt_0(
        &mut self,
        _class_or_inheritance_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_or_inheritance_modification = pop_item!(
            self,
            class_or_inheritance_modification,
            ClassOrInheritanceModification,
            context
        );
        let extends_clause_opt_0_built = ExtendsClauseOpt {
            class_or_inheritance_modification,
        };
        self.push(
            ASTType::ExtendsClauseOpt(Some(extends_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// `extends_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn extends_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExtendsClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// `constraining_clause: constrainedby^ /* Clipped */ type_specifier constraining_clauseOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn constraining_clause(
        &mut self,
        _constrainedby: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _constraining_clause_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constraining_clause_opt = pop_item!(
            self,
            constraining_clause_opt,
            ConstrainingClauseOpt,
            context
        );
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        self.pop(context);
        let constraining_clause_built = ConstrainingClause {
            type_specifier,
            constraining_clause_opt,
        };
        // Calling user action here
        self.user_grammar
            .constraining_clause(&constraining_clause_built)?;
        self.push(
            ASTType::ConstrainingClause(constraining_clause_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// `constraining_clauseOpt /* Option<T>::Some */: class_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn constraining_clause_opt_0(&mut self, _class_modification: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_modification = pop_item!(self, class_modification, ClassModification, context);
        let constraining_clause_opt_0_built = ConstrainingClauseOpt { class_modification };
        self.push(
            ASTType::ConstrainingClauseOpt(Some(constraining_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// `constraining_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn constraining_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConstrainingClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// `class_or_inheritance_modification: '('^ /* Clipped */ class_or_inheritance_modificationOpt /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn class_or_inheritance_modification(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _class_or_inheritance_modification_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_or_inheritance_modification_opt = pop_item!(
            self,
            class_or_inheritance_modification_opt,
            ClassOrInheritanceModificationOpt,
            context
        );
        let class_or_inheritance_modification_built = ClassOrInheritanceModification {
            class_or_inheritance_modification_opt,
        };
        // Calling user action here
        self.user_grammar
            .class_or_inheritance_modification(&class_or_inheritance_modification_built)?;
        self.push(
            ASTType::ClassOrInheritanceModification(class_or_inheritance_modification_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// `class_or_inheritance_modificationOpt /* Option<T>::Some */: argument_or_inheritance_modification_list;`
    ///
    #[parol_runtime::function_name::named]
    fn class_or_inheritance_modification_opt_0(
        &mut self,
        _argument_or_inheritance_modification_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_or_inheritance_modification_list = pop_item!(
            self,
            argument_or_inheritance_modification_list,
            ArgumentOrInheritanceModificationList,
            context
        );
        let class_or_inheritance_modification_opt_0_built = ClassOrInheritanceModificationOpt {
            argument_or_inheritance_modification_list,
        };
        self.push(
            ASTType::ClassOrInheritanceModificationOpt(Some(
                class_or_inheritance_modification_opt_0_built,
            )),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// `class_or_inheritance_modificationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_or_inheritance_modification_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassOrInheritanceModificationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// `argument_or_inheritance_modification_list: argument_or_inheritance_modification_listGroup argument_or_inheritance_modification_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list(
        &mut self,
        _argument_or_inheritance_modification_list_group: &ParseTreeType<'t>,
        _argument_or_inheritance_modification_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_or_inheritance_modification_list_list = pop_and_reverse_item!(
            self,
            argument_or_inheritance_modification_list_list,
            ArgumentOrInheritanceModificationListList,
            context
        );
        let argument_or_inheritance_modification_list_group = pop_item!(
            self,
            argument_or_inheritance_modification_list_group,
            ArgumentOrInheritanceModificationListGroup,
            context
        );
        let argument_or_inheritance_modification_list_built =
            ArgumentOrInheritanceModificationList {
                argument_or_inheritance_modification_list_group,
                argument_or_inheritance_modification_list_list,
            };
        // Calling user action here
        self.user_grammar
            .argument_or_inheritance_modification_list(
                &argument_or_inheritance_modification_list_built,
            )?;
        self.push(
            ASTType::ArgumentOrInheritanceModificationList(
                argument_or_inheritance_modification_list_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// `argument_or_inheritance_modification_listGroup: argument;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_group_0(
        &mut self,
        _argument: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument = pop_item!(self, argument, Argument, context);
        let argument_or_inheritance_modification_list_group_0_built =
            ArgumentOrInheritanceModificationListGroupArgument {
                argument: (&argument)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            };
        let argument_or_inheritance_modification_list_group_0_built =
            ArgumentOrInheritanceModificationListGroup::Argument(
                argument_or_inheritance_modification_list_group_0_built,
            );
        self.push(
            ASTType::ArgumentOrInheritanceModificationListGroup(
                argument_or_inheritance_modification_list_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// `argument_or_inheritance_modification_listGroup: inheritance_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_group_1(
        &mut self,
        _inheritance_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inheritance_modification = pop_item!(
            self,
            inheritance_modification,
            InheritanceModification,
            context
        );
        let argument_or_inheritance_modification_list_group_1_built =
            ArgumentOrInheritanceModificationListGroupInheritanceModification {
                inheritance_modification,
            };
        let argument_or_inheritance_modification_list_group_1_built =
            ArgumentOrInheritanceModificationListGroup::InheritanceModification(
                argument_or_inheritance_modification_list_group_1_built,
            );
        self.push(
            ASTType::ArgumentOrInheritanceModificationListGroup(
                argument_or_inheritance_modification_list_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// `argument_or_inheritance_modification_listList /* Vec<T>::Push */: ','^ /* Clipped */ argument_or_inheritance_modification_listListGroup argument_or_inheritance_modification_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _argument_or_inheritance_modification_list_list_group: &ParseTreeType<'t>,
        _argument_or_inheritance_modification_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut argument_or_inheritance_modification_list_list = pop_item!(
            self,
            argument_or_inheritance_modification_list_list,
            ArgumentOrInheritanceModificationListList,
            context
        );
        let argument_or_inheritance_modification_list_list_group = pop_item!(
            self,
            argument_or_inheritance_modification_list_list_group,
            ArgumentOrInheritanceModificationListListGroup,
            context
        );
        let argument_or_inheritance_modification_list_list_0_built =
            ArgumentOrInheritanceModificationListList {
                argument_or_inheritance_modification_list_list_group,
            };
        // Add an element to the vector
        argument_or_inheritance_modification_list_list
            .push(argument_or_inheritance_modification_list_list_0_built);
        self.push(
            ASTType::ArgumentOrInheritanceModificationListList(
                argument_or_inheritance_modification_list_list,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// `argument_or_inheritance_modification_listListGroup: argument;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_list_group_0(
        &mut self,
        _argument: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument = pop_item!(self, argument, Argument, context);
        let argument_or_inheritance_modification_list_list_group_0_built =
            ArgumentOrInheritanceModificationListListGroupArgument {
                argument: (&argument)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            };
        let argument_or_inheritance_modification_list_list_group_0_built =
            ArgumentOrInheritanceModificationListListGroup::Argument(
                argument_or_inheritance_modification_list_list_group_0_built,
            );
        self.push(
            ASTType::ArgumentOrInheritanceModificationListListGroup(
                argument_or_inheritance_modification_list_list_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// `argument_or_inheritance_modification_listListGroup: inheritance_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_list_group_1(
        &mut self,
        _inheritance_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inheritance_modification = pop_item!(
            self,
            inheritance_modification,
            InheritanceModification,
            context
        );
        let argument_or_inheritance_modification_list_list_group_1_built =
            ArgumentOrInheritanceModificationListListGroupInheritanceModification {
                inheritance_modification,
            };
        let argument_or_inheritance_modification_list_list_group_1_built =
            ArgumentOrInheritanceModificationListListGroup::InheritanceModification(
                argument_or_inheritance_modification_list_list_group_1_built,
            );
        self.push(
            ASTType::ArgumentOrInheritanceModificationListListGroup(
                argument_or_inheritance_modification_list_list_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// `argument_or_inheritance_modification_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_or_inheritance_modification_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_or_inheritance_modification_list_list_1_built = Vec::new();
        self.push(
            ASTType::ArgumentOrInheritanceModificationListList(
                argument_or_inheritance_modification_list_list_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// `inheritance_modification: break^ /* Clipped */ inheritance_modificationGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn inheritance_modification(
        &mut self,
        _break: &ParseTreeType<'t>,
        _inheritance_modification_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inheritance_modification_group = pop_item!(
            self,
            inheritance_modification_group,
            InheritanceModificationGroup,
            context
        );
        self.pop(context);
        let inheritance_modification_built = InheritanceModification {
            inheritance_modification_group,
        };
        // Calling user action here
        self.user_grammar
            .inheritance_modification(&inheritance_modification_built)?;
        self.push(
            ASTType::InheritanceModification(inheritance_modification_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// `inheritance_modificationGroup: connect_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn inheritance_modification_group_0(
        &mut self,
        _connect_equation: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect_equation = pop_item!(self, connect_equation, ConnectEquation, context);
        let inheritance_modification_group_0_built =
            InheritanceModificationGroupConnectEquation { connect_equation };
        let inheritance_modification_group_0_built =
            InheritanceModificationGroup::ConnectEquation(inheritance_modification_group_0_built);
        self.push(
            ASTType::InheritanceModificationGroup(inheritance_modification_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// `inheritance_modificationGroup: ident;`
    ///
    #[parol_runtime::function_name::named]
    fn inheritance_modification_group_1(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let inheritance_modification_group_1_built = InheritanceModificationGroupIdent {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let inheritance_modification_group_1_built =
            InheritanceModificationGroup::Ident(inheritance_modification_group_1_built);
        self.push(
            ASTType::InheritanceModificationGroup(inheritance_modification_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// `component_clause: type_prefix type_specifier component_clauseOpt /* Option */ component_list;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause(
        &mut self,
        _type_prefix: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _component_clause_opt: &ParseTreeType<'t>,
        _component_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list = pop_item!(self, component_list, ComponentList, context);
        let component_clause_opt =
            pop_item!(self, component_clause_opt, ComponentClauseOpt, context);
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let type_prefix = pop_item!(self, type_prefix, TypePrefix, context);
        let component_clause_built = ComponentClause {
            type_prefix,
            type_specifier,
            component_clause_opt,
            component_list: (&component_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .component_clause(&component_clause_built)?;
        self.push(ASTType::ComponentClause(component_clause_built), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// `component_clauseOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let component_clause_opt_0_built = ComponentClauseOpt {
            array_subscripts: (&array_subscripts)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ComponentClauseOpt(Some(component_clause_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// `component_clauseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentClauseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// `type_prefix: type_prefixOpt /* Option */ type_prefixOpt0 /* Option */ type_prefixOpt1 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix(
        &mut self,
        _type_prefix_opt: &ParseTreeType<'t>,
        _type_prefix_opt0: &ParseTreeType<'t>,
        _type_prefix_opt1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt1 = pop_item!(self, type_prefix_opt1, TypePrefixOpt1, context);
        let type_prefix_opt0 = pop_item!(self, type_prefix_opt0, TypePrefixOpt0, context);
        let type_prefix_opt = pop_item!(self, type_prefix_opt, TypePrefixOpt, context);
        let type_prefix_built = TypePrefix {
            type_prefix_opt,
            type_prefix_opt0,
            type_prefix_opt1,
        };
        // Calling user action here
        self.user_grammar.type_prefix(&type_prefix_built)?;
        self.push(ASTType::TypePrefix(type_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// `type_prefixOpt1 /* Option<T>::Some */: type_prefixOpt1Group;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_0(&mut self, _type_prefix_opt1_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt1_group =
            pop_item!(self, type_prefix_opt1_group, TypePrefixOpt1Group, context);
        let type_prefix_opt1_0_built = TypePrefixOpt1 {
            type_prefix_opt1_group,
        };
        self.push(
            ASTType::TypePrefixOpt1(Some(type_prefix_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// `type_prefixOpt1Group: input;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_group_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let type_prefix_opt1_group_0_built = TypePrefixOpt1GroupInput { input };
        let type_prefix_opt1_group_0_built =
            TypePrefixOpt1Group::Input(type_prefix_opt1_group_0_built);
        self.push(
            ASTType::TypePrefixOpt1Group(type_prefix_opt1_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// `type_prefixOpt1Group: output;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_group_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let type_prefix_opt1_group_1_built = TypePrefixOpt1GroupOutput { output };
        let type_prefix_opt1_group_1_built =
            TypePrefixOpt1Group::Output(type_prefix_opt1_group_1_built);
        self.push(
            ASTType::TypePrefixOpt1Group(type_prefix_opt1_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// `type_prefixOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// `type_prefixOpt0 /* Option<T>::Some */: type_prefixOpt0Group;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_0(&mut self, _type_prefix_opt0_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt0_group =
            pop_item!(self, type_prefix_opt0_group, TypePrefixOpt0Group, context);
        let type_prefix_opt0_0_built = TypePrefixOpt0 {
            type_prefix_opt0_group,
        };
        self.push(
            ASTType::TypePrefixOpt0(Some(type_prefix_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// `type_prefixOpt0Group: discrete;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_0(&mut self, _discrete: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let discrete = pop_item!(self, discrete, Discrete, context);
        let type_prefix_opt0_group_0_built = TypePrefixOpt0GroupDiscrete { discrete };
        let type_prefix_opt0_group_0_built =
            TypePrefixOpt0Group::Discrete(type_prefix_opt0_group_0_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// `type_prefixOpt0Group: parameter;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_1(&mut self, _parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let type_prefix_opt0_group_1_built = TypePrefixOpt0GroupParameter { parameter };
        let type_prefix_opt0_group_1_built =
            TypePrefixOpt0Group::Parameter(type_prefix_opt0_group_1_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// `type_prefixOpt0Group: constant;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_group_2(&mut self, _constant: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constant = pop_item!(self, constant, Constant, context);
        let type_prefix_opt0_group_2_built = TypePrefixOpt0GroupConstant { constant };
        let type_prefix_opt0_group_2_built =
            TypePrefixOpt0Group::Constant(type_prefix_opt0_group_2_built);
        self.push(
            ASTType::TypePrefixOpt0Group(type_prefix_opt0_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// `type_prefixOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// `type_prefixOpt /* Option<T>::Some */: type_prefixOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_0(&mut self, _type_prefix_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_prefix_opt_group =
            pop_item!(self, type_prefix_opt_group, TypePrefixOptGroup, context);
        let type_prefix_opt_0_built = TypePrefixOpt {
            type_prefix_opt_group,
        };
        self.push(
            ASTType::TypePrefixOpt(Some(type_prefix_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// `type_prefixOptGroup: flow;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_group_0(&mut self, _flow: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let flow = pop_item!(self, flow, Flow, context);
        let type_prefix_opt_group_0_built = TypePrefixOptGroupFlow { flow };
        let type_prefix_opt_group_0_built = TypePrefixOptGroup::Flow(type_prefix_opt_group_0_built);
        self.push(
            ASTType::TypePrefixOptGroup(type_prefix_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// `type_prefixOptGroup: stream;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_group_1(&mut self, _stream: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let stream = pop_item!(self, stream, Stream, context);
        let type_prefix_opt_group_1_built = TypePrefixOptGroupStream { stream };
        let type_prefix_opt_group_1_built =
            TypePrefixOptGroup::Stream(type_prefix_opt_group_1_built);
        self.push(
            ASTType::TypePrefixOptGroup(type_prefix_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// `type_prefixOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_prefix_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypePrefixOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// `component_list: component_declaration component_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list(
        &mut self,
        _component_declaration: &ParseTreeType<'t>,
        _component_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list_list =
            pop_and_reverse_item!(self, component_list_list, ComponentListList, context);
        let component_declaration =
            pop_item!(self, component_declaration, ComponentDeclaration, context);
        let component_list_built = ComponentList {
            component_declaration,
            component_list_list,
        };
        // Calling user action here
        self.user_grammar.component_list(&component_list_built)?;
        self.push(ASTType::ComponentList(component_list_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// `component_listList /* Vec<T>::Push */: ','^ /* Clipped */ component_declaration component_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _component_declaration: &ParseTreeType<'t>,
        _component_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut component_list_list =
            pop_item!(self, component_list_list, ComponentListList, context);
        let component_declaration =
            pop_item!(self, component_declaration, ComponentDeclaration, context);
        let component_list_list_0_built = ComponentListList {
            component_declaration,
        };
        // Add an element to the vector
        component_list_list.push(component_list_list_0_built);
        self.push(ASTType::ComponentListList(component_list_list), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// `component_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_list_list_1_built = Vec::new();
        self.push(
            ASTType::ComponentListList(component_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// `component_declaration: declaration component_declarationOpt /* Option */ description;`
    ///
    #[parol_runtime::function_name::named]
    fn component_declaration(
        &mut self,
        _declaration: &ParseTreeType<'t>,
        _component_declaration_opt: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let component_declaration_opt = pop_item!(
            self,
            component_declaration_opt,
            ComponentDeclarationOpt,
            context
        );
        let declaration = pop_item!(self, declaration, Declaration, context);
        let component_declaration_built = ComponentDeclaration {
            declaration,
            component_declaration_opt,
            description,
        };
        // Calling user action here
        self.user_grammar
            .component_declaration(&component_declaration_built)?;
        self.push(
            ASTType::ComponentDeclaration(component_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// `component_declarationOpt /* Option<T>::Some */: condition_attribute;`
    ///
    #[parol_runtime::function_name::named]
    fn component_declaration_opt_0(
        &mut self,
        _condition_attribute: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let condition_attribute = pop_item!(self, condition_attribute, ConditionAttribute, context);
        let component_declaration_opt_0_built = ComponentDeclarationOpt {
            condition_attribute,
        };
        self.push(
            ASTType::ComponentDeclarationOpt(Some(component_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// `component_declarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// `condition_attribute: if^ /* Clipped */ expression;`
    ///
    #[parol_runtime::function_name::named]
    fn condition_attribute(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        self.pop(context);
        let condition_attribute_built = ConditionAttribute {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .condition_attribute(&condition_attribute_built)?;
        self.push(
            ASTType::ConditionAttribute(condition_attribute_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// `declaration: ident declarationOpt /* Option */ declarationOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _declaration_opt: &ParseTreeType<'t>,
        _declaration_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let declaration_opt0 = pop_item!(self, declaration_opt0, DeclarationOpt0, context);
        let declaration_opt = pop_item!(self, declaration_opt, DeclarationOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let declaration_built = Declaration {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            declaration_opt,
            declaration_opt0,
        };
        // Calling user action here
        self.user_grammar.declaration(&declaration_built)?;
        self.push(ASTType::Declaration(declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// `declarationOpt0 /* Option<T>::Some */: modification;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt0_0(&mut self, _modification: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modification = pop_item!(self, modification, Modification, context);
        let declaration_opt0_0_built = DeclarationOpt0 { modification };
        self.push(
            ASTType::DeclarationOpt0(Some(declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// `declarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// `declarationOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let declaration_opt_0_built = DeclarationOpt {
            array_subscripts: (&array_subscripts)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::DeclarationOpt(Some(declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// `declarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// `modification: class_modification modificationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_0(
        &mut self,
        _class_modification: &ParseTreeType<'t>,
        _modification_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modification_opt = pop_item!(self, modification_opt, ModificationOpt, context);
        let class_modification = pop_item!(self, class_modification, ClassModification, context);
        let modification_0_built = ModificationClassModificationModificationOpt {
            class_modification: Box::new(class_modification),
            modification_opt,
        };
        let modification_0_built =
            Modification::ClassModificationModificationOpt(modification_0_built);
        // Calling user action here
        self.user_grammar.modification(&modification_0_built)?;
        self.push(ASTType::Modification(modification_0_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// `modification: '='^ /* Clipped */ modification_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_1(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _modification_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modification_expression = pop_item!(
            self,
            modification_expression,
            ModificationExpression,
            context
        );
        let modification_1_built = ModificationEquModificationExpression {
            modification_expression,
        };
        let modification_1_built = Modification::EquModificationExpression(modification_1_built);
        // Calling user action here
        self.user_grammar.modification(&modification_1_built)?;
        self.push(ASTType::Modification(modification_1_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// `modificationOpt /* Option<T>::Some */: '='^ /* Clipped */ modification_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _modification_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modification_expression = pop_item!(
            self,
            modification_expression,
            ModificationExpression,
            context
        );
        let modification_opt_0_built = ModificationOpt {
            modification_expression,
        };
        self.push(
            ASTType::ModificationOpt(Some(modification_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// `modificationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModificationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// `modification_expression: expression;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_expression_0(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let modification_expression_0_built = ModificationExpressionExpression {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let modification_expression_0_built =
            ModificationExpression::Expression(modification_expression_0_built);
        // Calling user action here
        self.user_grammar
            .modification_expression(&modification_expression_0_built)?;
        self.push(
            ASTType::ModificationExpression(modification_expression_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// `modification_expression: break;`
    ///
    #[parol_runtime::function_name::named]
    fn modification_expression_1(&mut self, _break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#break = pop_item!(self, r#break, Break, context);
        let modification_expression_1_built = ModificationExpressionBreak { r#break };
        let modification_expression_1_built =
            ModificationExpression::Break(modification_expression_1_built);
        // Calling user action here
        self.user_grammar
            .modification_expression(&modification_expression_1_built)?;
        self.push(
            ASTType::ModificationExpression(modification_expression_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// `class_modification: '('^ /* Clipped */ class_modificationOpt /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn class_modification(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _class_modification_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_modification_opt =
            pop_item!(self, class_modification_opt, ClassModificationOpt, context);
        let class_modification_built = ClassModification {
            class_modification_opt: class_modification_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .class_modification(&class_modification_built)?;
        self.push(
            ASTType::ClassModification(class_modification_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// `class_modificationOpt /* Option<T>::Some */: argument_list;`
    ///
    #[parol_runtime::function_name::named]
    fn class_modification_opt_0(&mut self, _argument_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list = pop_item!(self, argument_list, ArgumentList, context);
        let class_modification_opt_0_built = ClassModificationOpt {
            argument_list: (&argument_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ClassModificationOpt(Some(class_modification_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// `class_modificationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn class_modification_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ClassModificationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// `argument_list: argument argument_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list(
        &mut self,
        _argument: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_list =
            pop_and_reverse_item!(self, argument_list_list, ArgumentListList, context);
        let argument = pop_item!(self, argument, Argument, context);
        let argument_list_built = ArgumentList {
            argument: Box::new(
                (&argument)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            argument_list_list,
        };
        // Calling user action here
        self.user_grammar.argument_list(&argument_list_built)?;
        self.push(ASTType::ArgumentList(argument_list_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// `argument_listList /* Vec<T>::Push */: ','^ /* Clipped */ argument argument_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _argument: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut argument_list_list = pop_item!(self, argument_list_list, ArgumentListList, context);
        let argument = pop_item!(self, argument, Argument, context);
        let argument_list_list_0_built = ArgumentListList {
            argument: (&argument)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        argument_list_list.push(argument_list_list_0_built);
        self.push(ASTType::ArgumentListList(argument_list_list), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// `argument_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_list_1_built = Vec::new();
        self.push(
            ASTType::ArgumentListList(argument_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// `argument: element_modification_or_replaceable;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_0(
        &mut self,
        _element_modification_or_replaceable: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_modification_or_replaceable = pop_item!(
            self,
            element_modification_or_replaceable,
            ElementModificationOrReplaceable,
            context
        );
        let argument_0_built = ArgumentElementModificationOrReplaceable {
            element_modification_or_replaceable: Box::new(element_modification_or_replaceable),
        };
        let argument_0_built =
            Argument::ElementModificationOrReplaceable(Box::new(argument_0_built));
        // Calling user action here
        self.user_grammar.argument(&argument_0_built)?;
        self.push(ASTType::Argument(argument_0_built), context);
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// `argument: element_redeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_1(&mut self, _element_redeclaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_redeclaration =
            pop_item!(self, element_redeclaration, ElementRedeclaration, context);
        let argument_1_built = ArgumentElementRedeclaration {
            element_redeclaration: Box::new(element_redeclaration),
        };
        let argument_1_built = Argument::ElementRedeclaration(Box::new(argument_1_built));
        // Calling user action here
        self.user_grammar.argument(&argument_1_built)?;
        self.push(ASTType::Argument(argument_1_built), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// `element_modification_or_replaceable: element_modification_or_replaceableOpt /* Option */ element_modification_or_replaceableOpt0 /* Option */ element_modification_or_replaceableGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable(
        &mut self,
        _element_modification_or_replaceable_opt: &ParseTreeType<'t>,
        _element_modification_or_replaceable_opt0: &ParseTreeType<'t>,
        _element_modification_or_replaceable_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_modification_or_replaceable_group = pop_item!(
            self,
            element_modification_or_replaceable_group,
            ElementModificationOrReplaceableGroup,
            context
        );
        let element_modification_or_replaceable_opt0 = pop_item!(
            self,
            element_modification_or_replaceable_opt0,
            ElementModificationOrReplaceableOpt0,
            context
        );
        let element_modification_or_replaceable_opt = pop_item!(
            self,
            element_modification_or_replaceable_opt,
            ElementModificationOrReplaceableOpt,
            context
        );
        let element_modification_or_replaceable_built = ElementModificationOrReplaceable {
            element_modification_or_replaceable_opt,
            element_modification_or_replaceable_opt0,
            element_modification_or_replaceable_group,
        };
        // Calling user action here
        self.user_grammar
            .element_modification_or_replaceable(&element_modification_or_replaceable_built)?;
        self.push(
            ASTType::ElementModificationOrReplaceable(element_modification_or_replaceable_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// `element_modification_or_replaceableGroup: element_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_group_0(
        &mut self,
        _element_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_modification =
            pop_item!(self, element_modification, ElementModification, context);
        let element_modification_or_replaceable_group_0_built =
            ElementModificationOrReplaceableGroupElementModification {
                element_modification: Box::new(element_modification),
            };
        let element_modification_or_replaceable_group_0_built =
            ElementModificationOrReplaceableGroup::ElementModification(
                element_modification_or_replaceable_group_0_built,
            );
        self.push(
            ASTType::ElementModificationOrReplaceableGroup(
                element_modification_or_replaceable_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// `element_modification_or_replaceableGroup: element_replaceable;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_group_1(
        &mut self,
        _element_replaceable: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_replaceable = pop_item!(self, element_replaceable, ElementReplaceable, context);
        let element_modification_or_replaceable_group_1_built =
            ElementModificationOrReplaceableGroupElementReplaceable {
                element_replaceable: Box::new(element_replaceable),
            };
        let element_modification_or_replaceable_group_1_built =
            ElementModificationOrReplaceableGroup::ElementReplaceable(
                element_modification_or_replaceable_group_1_built,
            );
        self.push(
            ASTType::ElementModificationOrReplaceableGroup(
                element_modification_or_replaceable_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// `element_modification_or_replaceableOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_opt0_0(
        &mut self,
        _final: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let element_modification_or_replaceable_opt0_0_built =
            ElementModificationOrReplaceableOpt0 { r#final };
        self.push(
            ASTType::ElementModificationOrReplaceableOpt0(Some(
                element_modification_or_replaceable_opt0_0_built,
            )),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// `element_modification_or_replaceableOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementModificationOrReplaceableOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// `element_modification_or_replaceableOpt /* Option<T>::Some */: each;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_opt_0(
        &mut self,
        _each: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = pop_item!(self, each, Each, context);
        let element_modification_or_replaceable_opt_0_built =
            ElementModificationOrReplaceableOpt { each };
        self.push(
            ASTType::ElementModificationOrReplaceableOpt(Some(
                element_modification_or_replaceable_opt_0_built,
            )),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// `element_modification_or_replaceableOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_or_replaceable_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementModificationOrReplaceableOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// `element_modification: name element_modificationOpt /* Option */ description_string;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification(
        &mut self,
        _name: &ParseTreeType<'t>,
        _element_modification_opt: &ParseTreeType<'t>,
        _description_string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string = pop_item!(self, description_string, DescriptionString, context);
        let element_modification_opt = pop_item!(
            self,
            element_modification_opt,
            ElementModificationOpt,
            context
        );
        let name = pop_item!(self, name, Name, context);
        let element_modification_built = ElementModification {
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            element_modification_opt,
            description_string: (&description_string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .element_modification(&element_modification_built)?;
        self.push(
            ASTType::ElementModification(element_modification_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// `element_modificationOpt /* Option<T>::Some */: modification;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_opt_0(&mut self, _modification: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modification = pop_item!(self, modification, Modification, context);
        let element_modification_opt_0_built = ElementModificationOpt { modification };
        self.push(
            ASTType::ElementModificationOpt(Some(element_modification_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// `element_modificationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_modification_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementModificationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// `element_redeclaration: redeclare element_redeclarationOpt /* Option */ element_redeclarationOpt0 /* Option */ element_redeclarationGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration(
        &mut self,
        _redeclare: &ParseTreeType<'t>,
        _element_redeclaration_opt: &ParseTreeType<'t>,
        _element_redeclaration_opt0: &ParseTreeType<'t>,
        _element_redeclaration_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_redeclaration_group = pop_item!(
            self,
            element_redeclaration_group,
            ElementRedeclarationGroup,
            context
        );
        let element_redeclaration_opt0 = pop_item!(
            self,
            element_redeclaration_opt0,
            ElementRedeclarationOpt0,
            context
        );
        let element_redeclaration_opt = pop_item!(
            self,
            element_redeclaration_opt,
            ElementRedeclarationOpt,
            context
        );
        let redeclare = pop_item!(self, redeclare, Redeclare, context);
        let element_redeclaration_built = ElementRedeclaration {
            redeclare,
            element_redeclaration_opt,
            element_redeclaration_opt0,
            element_redeclaration_group,
        };
        // Calling user action here
        self.user_grammar
            .element_redeclaration(&element_redeclaration_built)?;
        self.push(
            ASTType::ElementRedeclaration(element_redeclaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// `element_redeclarationGroup: short_class_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_group_0(
        &mut self,
        _short_class_definition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let short_class_definition =
            pop_item!(self, short_class_definition, ShortClassDefinition, context);
        let element_redeclaration_group_0_built = ElementRedeclarationGroupShortClassDefinition {
            short_class_definition: Box::new(short_class_definition),
        };
        let element_redeclaration_group_0_built =
            ElementRedeclarationGroup::ShortClassDefinition(element_redeclaration_group_0_built);
        self.push(
            ASTType::ElementRedeclarationGroup(element_redeclaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// `element_redeclarationGroup: component_clause1;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_group_1(
        &mut self,
        _component_clause1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_clause1 = pop_item!(self, component_clause1, ComponentClause1, context);
        let element_redeclaration_group_1_built = ElementRedeclarationGroupComponentClause1 {
            component_clause1: Box::new(component_clause1),
        };
        let element_redeclaration_group_1_built =
            ElementRedeclarationGroup::ComponentClause1(element_redeclaration_group_1_built);
        self.push(
            ASTType::ElementRedeclarationGroup(element_redeclaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// `element_redeclarationGroup: element_replaceable;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_group_2(
        &mut self,
        _element_replaceable: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_replaceable = pop_item!(self, element_replaceable, ElementReplaceable, context);
        let element_redeclaration_group_2_built = ElementRedeclarationGroupElementReplaceable {
            element_replaceable: Box::new(element_replaceable),
        };
        let element_redeclaration_group_2_built =
            ElementRedeclarationGroup::ElementReplaceable(element_redeclaration_group_2_built);
        self.push(
            ASTType::ElementRedeclarationGroup(element_redeclaration_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// `element_redeclarationOpt0 /* Option<T>::Some */: final;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_opt0_0(&mut self, _final: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#final = pop_item!(self, r#final, Final, context);
        let element_redeclaration_opt0_0_built = ElementRedeclarationOpt0 { r#final };
        self.push(
            ASTType::ElementRedeclarationOpt0(Some(element_redeclaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// `element_redeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementRedeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// `element_redeclarationOpt /* Option<T>::Some */: each;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_opt_0(&mut self, _each: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = pop_item!(self, each, Each, context);
        let element_redeclaration_opt_0_built = ElementRedeclarationOpt { each };
        self.push(
            ASTType::ElementRedeclarationOpt(Some(element_redeclaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// `element_redeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_redeclaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementRedeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// `element_replaceable: replaceable element_replaceableGroup element_replaceableOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable(
        &mut self,
        _replaceable: &ParseTreeType<'t>,
        _element_replaceable_group: &ParseTreeType<'t>,
        _element_replaceable_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_replaceable_opt = pop_item!(
            self,
            element_replaceable_opt,
            ElementReplaceableOpt,
            context
        );
        let element_replaceable_group = pop_item!(
            self,
            element_replaceable_group,
            ElementReplaceableGroup,
            context
        );
        let replaceable = pop_item!(self, replaceable, Replaceable, context);
        let element_replaceable_built = ElementReplaceable {
            replaceable,
            element_replaceable_group,
            element_replaceable_opt,
        };
        // Calling user action here
        self.user_grammar
            .element_replaceable(&element_replaceable_built)?;
        self.push(
            ASTType::ElementReplaceable(element_replaceable_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// `element_replaceableGroup: short_class_definition;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_group_0(
        &mut self,
        _short_class_definition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let short_class_definition =
            pop_item!(self, short_class_definition, ShortClassDefinition, context);
        let element_replaceable_group_0_built = ElementReplaceableGroupShortClassDefinition {
            short_class_definition: Box::new(short_class_definition),
        };
        let element_replaceable_group_0_built =
            ElementReplaceableGroup::ShortClassDefinition(element_replaceable_group_0_built);
        self.push(
            ASTType::ElementReplaceableGroup(element_replaceable_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// `element_replaceableGroup: component_clause1;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_group_1(
        &mut self,
        _component_clause1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_clause1 = pop_item!(self, component_clause1, ComponentClause1, context);
        let element_replaceable_group_1_built = ElementReplaceableGroupComponentClause1 {
            component_clause1: Box::new(component_clause1),
        };
        let element_replaceable_group_1_built =
            ElementReplaceableGroup::ComponentClause1(element_replaceable_group_1_built);
        self.push(
            ASTType::ElementReplaceableGroup(element_replaceable_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// `element_replaceableOpt /* Option<T>::Some */: constraining_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_opt_0(
        &mut self,
        _constraining_clause: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let constraining_clause = pop_item!(self, constraining_clause, ConstrainingClause, context);
        let element_replaceable_opt_0_built = ElementReplaceableOpt {
            constraining_clause,
        };
        self.push(
            ASTType::ElementReplaceableOpt(Some(element_replaceable_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// `element_replaceableOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_replaceable_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementReplaceableOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// `component_clause1: type_prefix type_specifier component_declaration1;`
    ///
    #[parol_runtime::function_name::named]
    fn component_clause1(
        &mut self,
        _type_prefix: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _component_declaration1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_declaration1 =
            pop_item!(self, component_declaration1, ComponentDeclaration1, context);
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let type_prefix = pop_item!(self, type_prefix, TypePrefix, context);
        let component_clause1_built = ComponentClause1 {
            type_prefix,
            type_specifier,
            component_declaration1,
        };
        // Calling user action here
        self.user_grammar
            .component_clause1(&component_clause1_built)?;
        self.push(ASTType::ComponentClause1(component_clause1_built), context);
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// `component_declaration1: declaration description;`
    ///
    #[parol_runtime::function_name::named]
    fn component_declaration1(
        &mut self,
        _declaration: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let declaration = pop_item!(self, declaration, Declaration, context);
        let component_declaration1_built = ComponentDeclaration1 {
            declaration,
            description,
        };
        // Calling user action here
        self.user_grammar
            .component_declaration1(&component_declaration1_built)?;
        self.push(
            ASTType::ComponentDeclaration1(component_declaration1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// `short_class_definition: class_prefixes short_class_specifier;`
    ///
    #[parol_runtime::function_name::named]
    fn short_class_definition(
        &mut self,
        _class_prefixes: &ParseTreeType<'t>,
        _short_class_specifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let short_class_specifier =
            pop_item!(self, short_class_specifier, ShortClassSpecifier, context);
        let class_prefixes = pop_item!(self, class_prefixes, ClassPrefixes, context);
        let short_class_definition_built = ShortClassDefinition {
            class_prefixes,
            short_class_specifier,
        };
        // Calling user action here
        self.user_grammar
            .short_class_definition(&short_class_definition_built)?;
        self.push(
            ASTType::ShortClassDefinition(short_class_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// `equation_section: equation_sectionOpt /* Option */ equation^ /* Clipped */ equation_sectionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section(
        &mut self,
        _equation_section_opt: &ParseTreeType<'t>,
        _equation: &ParseTreeType<'t>,
        _equation_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section_list =
            pop_and_reverse_item!(self, equation_section_list, EquationSectionList, context);
        self.pop(context);
        let equation_section_opt =
            pop_item!(self, equation_section_opt, EquationSectionOpt, context);
        let equation_section_built = EquationSection {
            equation_section_opt,
            equation_section_list,
        };
        // Calling user action here
        self.user_grammar
            .equation_section(&equation_section_built)?;
        self.push(ASTType::EquationSection(equation_section_built), context);
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// `equation_sectionList /* Vec<T>::Push */: some_equation ';'^ /* Clipped */ equation_sectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_list_0(
        &mut self,
        _some_equation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _equation_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut equation_section_list =
            pop_item!(self, equation_section_list, EquationSectionList, context);
        let some_equation = pop_item!(self, some_equation, SomeEquation, context);
        let equation_section_list_0_built = EquationSectionList {
            some_equation: (&some_equation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        equation_section_list.push(equation_section_list_0_built);
        self.push(ASTType::EquationSectionList(equation_section_list), context);
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// `equation_sectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_section_list_1_built = Vec::new();
        self.push(
            ASTType::EquationSectionList(equation_section_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// `equation_sectionOpt /* Option<T>::Some */: initial^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_opt_0(&mut self, _initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let equation_section_opt_0_built = EquationSectionOpt {};
        self.push(
            ASTType::EquationSectionOpt(Some(equation_section_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// `equation_sectionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_section_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EquationSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// `algorithm_section: algorithm_sectionOpt /* Option */ algorithm^ /* Clipped */ algorithm_sectionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section(
        &mut self,
        _algorithm_section_opt: &ParseTreeType<'t>,
        _algorithm: &ParseTreeType<'t>,
        _algorithm_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section_list =
            pop_and_reverse_item!(self, algorithm_section_list, AlgorithmSectionList, context);
        self.pop(context);
        let algorithm_section_opt =
            pop_item!(self, algorithm_section_opt, AlgorithmSectionOpt, context);
        let algorithm_section_built = AlgorithmSection {
            algorithm_section_opt,
            algorithm_section_list,
        };
        // Calling user action here
        self.user_grammar
            .algorithm_section(&algorithm_section_built)?;
        self.push(ASTType::AlgorithmSection(algorithm_section_built), context);
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// `algorithm_sectionList /* Vec<T>::Push */: statement ';'^ /* Clipped */ algorithm_sectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _algorithm_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut algorithm_section_list =
            pop_item!(self, algorithm_section_list, AlgorithmSectionList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let algorithm_section_list_0_built = AlgorithmSectionList {
            statement: (&statement)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        algorithm_section_list.push(algorithm_section_list_0_built);
        self.push(
            ASTType::AlgorithmSectionList(algorithm_section_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// `algorithm_sectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let algorithm_section_list_1_built = Vec::new();
        self.push(
            ASTType::AlgorithmSectionList(algorithm_section_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// `algorithm_sectionOpt /* Option<T>::Some */: initial^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_opt_0(&mut self, _initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let algorithm_section_opt_0_built = AlgorithmSectionOpt {};
        self.push(
            ASTType::AlgorithmSectionOpt(Some(algorithm_section_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// `algorithm_sectionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn algorithm_section_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlgorithmSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// `some_equation_option: simple_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation_option_0(&mut self, _simple_equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_equation = pop_item!(self, simple_equation, SimpleEquation, context);
        let some_equation_option_0_built = SomeEquationOptionSimpleEquation { simple_equation };
        let some_equation_option_0_built =
            SomeEquationOption::SimpleEquation(some_equation_option_0_built);
        // Calling user action here
        self.user_grammar
            .some_equation_option(&some_equation_option_0_built)?;
        self.push(
            ASTType::SomeEquationOption(some_equation_option_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// `some_equation_option: if_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation_option_1(&mut self, _if_equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_equation = pop_item!(self, if_equation, IfEquation, context);
        let some_equation_option_1_built = SomeEquationOptionIfEquation { if_equation };
        let some_equation_option_1_built =
            SomeEquationOption::IfEquation(some_equation_option_1_built);
        // Calling user action here
        self.user_grammar
            .some_equation_option(&some_equation_option_1_built)?;
        self.push(
            ASTType::SomeEquationOption(some_equation_option_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// `some_equation_option: for_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation_option_2(&mut self, _for_equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_equation = pop_item!(self, for_equation, ForEquation, context);
        let some_equation_option_2_built = SomeEquationOptionForEquation { for_equation };
        let some_equation_option_2_built =
            SomeEquationOption::ForEquation(some_equation_option_2_built);
        // Calling user action here
        self.user_grammar
            .some_equation_option(&some_equation_option_2_built)?;
        self.push(
            ASTType::SomeEquationOption(some_equation_option_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// `some_equation_option: connect_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation_option_3(&mut self, _connect_equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect_equation = pop_item!(self, connect_equation, ConnectEquation, context);
        let some_equation_option_3_built = SomeEquationOptionConnectEquation { connect_equation };
        let some_equation_option_3_built =
            SomeEquationOption::ConnectEquation(some_equation_option_3_built);
        // Calling user action here
        self.user_grammar
            .some_equation_option(&some_equation_option_3_built)?;
        self.push(
            ASTType::SomeEquationOption(some_equation_option_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// `some_equation_option: when_equation;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation_option_4(&mut self, _when_equation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let when_equation = pop_item!(self, when_equation, WhenEquation, context);
        let some_equation_option_4_built = SomeEquationOptionWhenEquation { when_equation };
        let some_equation_option_4_built =
            SomeEquationOption::WhenEquation(some_equation_option_4_built);
        // Calling user action here
        self.user_grammar
            .some_equation_option(&some_equation_option_4_built)?;
        self.push(
            ASTType::SomeEquationOption(some_equation_option_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// `simple_equation: simple_expression simple_equationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_equation(
        &mut self,
        _simple_expression: &ParseTreeType<'t>,
        _simple_equation_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_equation_opt = pop_item!(self, simple_equation_opt, SimpleEquationOpt, context);
        let simple_expression = pop_item!(self, simple_expression, SimpleExpression, context);
        let simple_equation_built = SimpleEquation {
            simple_expression: (&simple_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            simple_equation_opt,
        };
        // Calling user action here
        self.user_grammar.simple_equation(&simple_equation_built)?;
        self.push(ASTType::SimpleEquation(simple_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// `simple_equationOpt /* Option<T>::Some */: '='^ /* Clipped */ expression;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_equation_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let simple_equation_opt_0_built = SimpleEquationOpt {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::SimpleEquationOpt(Some(simple_equation_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// `simple_equationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_equation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleEquationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// `some_equation: some_equation_option description;`
    ///
    #[parol_runtime::function_name::named]
    fn some_equation(
        &mut self,
        _some_equation_option: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let some_equation_option =
            pop_item!(self, some_equation_option, SomeEquationOption, context);
        let some_equation_built = SomeEquation {
            some_equation_option,
            description,
        };
        // Calling user action here
        self.user_grammar.some_equation(&some_equation_built)?;
        self.push(ASTType::SomeEquation(some_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// `statement_option: component_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_0(&mut self, _component_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_statement = pop_item!(self, component_statement, ComponentStatement, context);
        let statement_option_0_built = StatementOptionComponentStatement {
            component_statement,
        };
        let statement_option_0_built =
            StatementOption::ComponentStatement(statement_option_0_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_0_built)?;
        self.push(ASTType::StatementOption(statement_option_0_built), context);
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// `statement_option: function_call_output_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_1(
        &mut self,
        _function_call_output_statement: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_output_statement = pop_item!(
            self,
            function_call_output_statement,
            FunctionCallOutputStatement,
            context
        );
        let statement_option_1_built = StatementOptionFunctionCallOutputStatement {
            function_call_output_statement,
        };
        let statement_option_1_built =
            StatementOption::FunctionCallOutputStatement(statement_option_1_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_1_built)?;
        self.push(ASTType::StatementOption(statement_option_1_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// `statement_option: break;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_2(&mut self, _break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#break = pop_item!(self, r#break, Break, context);
        let statement_option_2_built = StatementOptionBreak { r#break };
        let statement_option_2_built = StatementOption::Break(statement_option_2_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_2_built)?;
        self.push(ASTType::StatementOption(statement_option_2_built), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// `statement_option: return;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_3(&mut self, _return: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#return = pop_item!(self, r#return, Return, context);
        let statement_option_3_built = StatementOptionReturn { r#return };
        let statement_option_3_built = StatementOption::Return(statement_option_3_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_3_built)?;
        self.push(ASTType::StatementOption(statement_option_3_built), context);
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// `statement_option: if_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_4(&mut self, _if_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_option_4_built = StatementOptionIfStatement { if_statement };
        let statement_option_4_built = StatementOption::IfStatement(statement_option_4_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_4_built)?;
        self.push(ASTType::StatementOption(statement_option_4_built), context);
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// `statement_option: for_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_5(&mut self, _for_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement = pop_item!(self, for_statement, ForStatement, context);
        let statement_option_5_built = StatementOptionForStatement { for_statement };
        let statement_option_5_built = StatementOption::ForStatement(statement_option_5_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_5_built)?;
        self.push(ASTType::StatementOption(statement_option_5_built), context);
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// `statement_option: while_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_6(&mut self, _while_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let while_statement = pop_item!(self, while_statement, WhileStatement, context);
        let statement_option_6_built = StatementOptionWhileStatement { while_statement };
        let statement_option_6_built = StatementOption::WhileStatement(statement_option_6_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_6_built)?;
        self.push(ASTType::StatementOption(statement_option_6_built), context);
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// `statement_option: when_statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_option_7(&mut self, _when_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let when_statement = pop_item!(self, when_statement, WhenStatement, context);
        let statement_option_7_built = StatementOptionWhenStatement { when_statement };
        let statement_option_7_built = StatementOption::WhenStatement(statement_option_7_built);
        // Calling user action here
        self.user_grammar
            .statement_option(&statement_option_7_built)?;
        self.push(ASTType::StatementOption(statement_option_7_built), context);
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// `component_statement: component_reference component_statementGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn component_statement(
        &mut self,
        _component_reference: &ParseTreeType<'t>,
        _component_statement_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_statement_group = pop_item!(
            self,
            component_statement_group,
            ComponentStatementGroup,
            context
        );
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let component_statement_built = ComponentStatement {
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_statement_group,
        };
        // Calling user action here
        self.user_grammar
            .component_statement(&component_statement_built)?;
        self.push(
            ASTType::ComponentStatement(component_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// `component_statementGroup: ':='^ /* Clipped */ expression;`
    ///
    #[parol_runtime::function_name::named]
    fn component_statement_group_0(
        &mut self,
        _colon_equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let component_statement_group_0_built = ComponentStatementGroupColonEquExpression {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let component_statement_group_0_built =
            ComponentStatementGroup::ColonEquExpression(component_statement_group_0_built);
        self.push(
            ASTType::ComponentStatementGroup(component_statement_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// `component_statementGroup: function_call_args;`
    ///
    #[parol_runtime::function_name::named]
    fn component_statement_group_1(
        &mut self,
        _function_call_args: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_args = pop_item!(self, function_call_args, FunctionCallArgs, context);
        let component_statement_group_1_built = ComponentStatementGroupFunctionCallArgs {
            function_call_args: (&function_call_args)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let component_statement_group_1_built =
            ComponentStatementGroup::FunctionCallArgs(component_statement_group_1_built);
        self.push(
            ASTType::ComponentStatementGroup(component_statement_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// `function_call_output_statement: '('^ /* Clipped */ output_expression_list ')'^ /* Clipped */ ':='^ /* Clipped */ component_reference function_call_args;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_output_statement(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _output_expression_list: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _colon_equ: &ParseTreeType<'t>,
        _component_reference: &ParseTreeType<'t>,
        _function_call_args: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_args = pop_item!(self, function_call_args, FunctionCallArgs, context);
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let output_expression_list =
            pop_item!(self, output_expression_list, OutputExpressionList, context);
        let function_call_output_statement_built = FunctionCallOutputStatement {
            output_expression_list: (&output_expression_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            function_call_args: (&function_call_args)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .function_call_output_statement(&function_call_output_statement_built)?;
        self.push(
            ASTType::FunctionCallOutputStatement(function_call_output_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// `statement: statement_option description;`
    ///
    #[parol_runtime::function_name::named]
    fn statement(
        &mut self,
        _statement_option: &ParseTreeType<'t>,
        _description: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description = pop_item!(self, description, Description, context);
        let statement_option = pop_item!(self, statement_option, StatementOption, context);
        let statement_built = Statement {
            statement_option,
            description,
        };
        // Calling user action here
        self.user_grammar.statement(&statement_built)?;
        self.push(ASTType::Statement(statement_built), context);
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// `equation_block: expression then^ /* Clipped */ equation_blockList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_block(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _then: &ParseTreeType<'t>,
        _equation_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_block_list =
            pop_and_reverse_item!(self, equation_block_list, EquationBlockList, context);
        self.pop(context);
        let expression = pop_item!(self, expression, Expression, context);
        let equation_block_built = EquationBlock {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            equation_block_list,
        };
        // Calling user action here
        self.user_grammar.equation_block(&equation_block_built)?;
        self.push(ASTType::EquationBlock(equation_block_built), context);
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// `equation_blockList /* Vec<T>::Push */: some_equation ';'^ /* Clipped */ equation_blockList;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_block_list_0(
        &mut self,
        _some_equation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _equation_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut equation_block_list =
            pop_item!(self, equation_block_list, EquationBlockList, context);
        let some_equation = pop_item!(self, some_equation, SomeEquation, context);
        let equation_block_list_0_built = EquationBlockList {
            some_equation: (&some_equation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        equation_block_list.push(equation_block_list_0_built);
        self.push(ASTType::EquationBlockList(equation_block_list), context);
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// `equation_blockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equation_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equation_block_list_1_built = Vec::new();
        self.push(
            ASTType::EquationBlockList(equation_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// `if_equation: if^ /* Clipped */ equation_block@if if_equationList /* Vec */ if_equationOpt /* Option */ end^ /* Clipped */ if^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation(
        &mut self,
        _if: &ParseTreeType<'t>,
        _if0: &ParseTreeType<'t>,
        _if_equation_list: &ParseTreeType<'t>,
        _if_equation_opt: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _if1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let if_equation_opt = pop_item!(self, if_equation_opt, IfEquationOpt, context);
        let if_equation_list =
            pop_and_reverse_item!(self, if_equation_list, IfEquationList, context);
        let r#if0 = pop_item!(self, r#if0, EquationBlock, context);
        self.pop(context);
        let if_equation_built = IfEquation {
            r#if0: (&r#if0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            if_equation_list,
            if_equation_opt,
        };
        // Calling user action here
        self.user_grammar.if_equation(&if_equation_built)?;
        self.push(ASTType::IfEquation(if_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// `if_equationList /* Vec<T>::Push */: elseif^ /* Clipped */ equation_block@elseif if_equationList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_list_0(
        &mut self,
        _elseif: &ParseTreeType<'t>,
        _elseif0: &ParseTreeType<'t>,
        _if_equation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_equation_list = pop_item!(self, if_equation_list, IfEquationList, context);
        let elseif0 = pop_item!(self, elseif0, EquationBlock, context);
        self.pop(context);
        let if_equation_list_0_built = IfEquationList {
            elseif0: (&elseif0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        if_equation_list.push(if_equation_list_0_built);
        self.push(ASTType::IfEquationList(if_equation_list), context);
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// `if_equationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_equation_list_1_built = Vec::new();
        self.push(ASTType::IfEquationList(if_equation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// `if_equationOpt /* Option<T>::Some */: else^ /* Clipped */ if_equationOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if_equation_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_equation_opt_list =
            pop_and_reverse_item!(self, if_equation_opt_list, IfEquationOptList, context);
        self.pop(context);
        let if_equation_opt_0_built = IfEquationOpt {
            if_equation_opt_list,
        };
        self.push(
            ASTType::IfEquationOpt(Some(if_equation_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// `if_equationOptList /* Vec<T>::Push */: some_equation ';'^ /* Clipped */ if_equationOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_opt_list_0(
        &mut self,
        _some_equation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _if_equation_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_equation_opt_list =
            pop_item!(self, if_equation_opt_list, IfEquationOptList, context);
        let some_equation = pop_item!(self, some_equation, SomeEquation, context);
        let if_equation_opt_list_0_built = IfEquationOptList {
            some_equation: (&some_equation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        if_equation_opt_list.push(if_equation_opt_list_0_built);
        self.push(ASTType::IfEquationOptList(if_equation_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// `if_equationOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_equation_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfEquationOptList(if_equation_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// `if_equationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_equation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfEquationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// `statement_block: expression then^ /* Clipped */ statement_blockList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _then: &ParseTreeType<'t>,
        _statement_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_list =
            pop_and_reverse_item!(self, statement_block_list, StatementBlockList, context);
        self.pop(context);
        let expression = pop_item!(self, expression, Expression, context);
        let statement_block_built = StatementBlock {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            statement_block_list,
        };
        // Calling user action here
        self.user_grammar.statement_block(&statement_block_built)?;
        self.push(ASTType::StatementBlock(statement_block_built), context);
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// `statement_blockList /* Vec<T>::Push */: statement ';'^ /* Clipped */ statement_blockList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _statement_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_block_list =
            pop_item!(self, statement_block_list, StatementBlockList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let statement_block_list_0_built = StatementBlockList {
            statement: (&statement)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        statement_block_list.push(statement_block_list_0_built);
        self.push(ASTType::StatementBlockList(statement_block_list), context);
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// `statement_blockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_list_1_built = Vec::new();
        self.push(
            ASTType::StatementBlockList(statement_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// `if_statement: if^ /* Clipped */ statement_block@if if_statementList /* Vec */ if_statementOpt /* Option */ end^ /* Clipped */ if^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeType<'t>,
        _if0: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
        _if_statement_opt: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _if1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let r#if0 = pop_item!(self, r#if0, StatementBlock, context);
        self.pop(context);
        let if_statement_built = IfStatement {
            r#if0: (&r#if0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            if_statement_list,
            if_statement_opt,
        };
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// `if_statementList /* Vec<T>::Push */: elseif^ /* Clipped */ statement_block@elseif if_statementList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _elseif: &ParseTreeType<'t>,
        _elseif0: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let elseif0 = pop_item!(self, elseif0, StatementBlock, context);
        self.pop(context);
        let if_statement_list_0_built = IfStatementList {
            elseif0: (&elseif0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// `if_statementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// `if_statementOpt /* Option<T>::Some */: else^ /* Clipped */ if_statementOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if_statement_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt_list =
            pop_and_reverse_item!(self, if_statement_opt_list, IfStatementOptList, context);
        self.pop(context);
        let if_statement_opt_0_built = IfStatementOpt {
            if_statement_opt_list,
        };
        self.push(
            ASTType::IfStatementOpt(Some(if_statement_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// `if_statementOptList /* Vec<T>::Push */: statement@else ';'^ /* Clipped */ if_statementOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _if_statement_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_opt_list =
            pop_item!(self, if_statement_opt_list, IfStatementOptList, context);
        let r#else = pop_item!(self, r#else, Statement, context);
        let if_statement_opt_list_0_built = IfStatementOptList {
            r#else: (&r#else)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        if_statement_opt_list.push(if_statement_opt_list_0_built);
        self.push(ASTType::IfStatementOptList(if_statement_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// `if_statementOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfStatementOptList(if_statement_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// `if_statementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// `for_equation: for^ /* Clipped */ for_indices loop^ /* Clipped */ for_equationList /* Vec */ end^ /* Clipped */ for^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn for_equation(
        &mut self,
        _for: &ParseTreeType<'t>,
        _for_indices: &ParseTreeType<'t>,
        _loop: &ParseTreeType<'t>,
        _for_equation_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _for0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let for_equation_list =
            pop_and_reverse_item!(self, for_equation_list, ForEquationList, context);
        self.pop(context);
        let for_indices = pop_item!(self, for_indices, ForIndices, context);
        self.pop(context);
        let for_equation_built = ForEquation {
            for_indices,
            for_equation_list,
        };
        // Calling user action here
        self.user_grammar.for_equation(&for_equation_built)?;
        self.push(ASTType::ForEquation(for_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// `for_equationList /* Vec<T>::Push */: some_equation ';'^ /* Clipped */ for_equationList;`
    ///
    #[parol_runtime::function_name::named]
    fn for_equation_list_0(
        &mut self,
        _some_equation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _for_equation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut for_equation_list = pop_item!(self, for_equation_list, ForEquationList, context);
        let some_equation = pop_item!(self, some_equation, SomeEquation, context);
        let for_equation_list_0_built = ForEquationList {
            some_equation: (&some_equation)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        for_equation_list.push(for_equation_list_0_built);
        self.push(ASTType::ForEquationList(for_equation_list), context);
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// `for_equationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_equation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_equation_list_1_built = Vec::new();
        self.push(ASTType::ForEquationList(for_equation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// `for_statement: for^ /* Clipped */ for_indices loop^ /* Clipped */ for_statementList /* Vec */ end^ /* Clipped */ for^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement(
        &mut self,
        _for: &ParseTreeType<'t>,
        _for_indices: &ParseTreeType<'t>,
        _loop: &ParseTreeType<'t>,
        _for_statement_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _for0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let for_statement_list =
            pop_and_reverse_item!(self, for_statement_list, ForStatementList, context);
        self.pop(context);
        let for_indices = pop_item!(self, for_indices, ForIndices, context);
        self.pop(context);
        let for_statement_built = ForStatement {
            for_indices,
            for_statement_list,
        };
        // Calling user action here
        self.user_grammar.for_statement(&for_statement_built)?;
        self.push(ASTType::ForStatement(for_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// `for_statementList /* Vec<T>::Push */: statement ';'^ /* Clipped */ for_statementList;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _for_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut for_statement_list = pop_item!(self, for_statement_list, ForStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let for_statement_list_0_built = ForStatementList {
            statement: (&statement)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        for_statement_list.push(for_statement_list_0_built);
        self.push(ASTType::ForStatementList(for_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// `for_statementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement_list_1_built = Vec::new();
        self.push(
            ASTType::ForStatementList(for_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// `for_indices: for_index for_indicesList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn for_indices(
        &mut self,
        _for_index: &ParseTreeType<'t>,
        _for_indices_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_indices_list =
            pop_and_reverse_item!(self, for_indices_list, ForIndicesList, context);
        let for_index = pop_item!(self, for_index, ForIndex, context);
        let for_indices_built = ForIndices {
            for_index,
            for_indices_list,
        };
        // Calling user action here
        self.user_grammar.for_indices(&for_indices_built)?;
        self.push(ASTType::ForIndices(for_indices_built), context);
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// `for_indicesList /* Vec<T>::Push */: ','^ /* Clipped */ for_index for_indicesList;`
    ///
    #[parol_runtime::function_name::named]
    fn for_indices_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _for_index: &ParseTreeType<'t>,
        _for_indices_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut for_indices_list = pop_item!(self, for_indices_list, ForIndicesList, context);
        let for_index = pop_item!(self, for_index, ForIndex, context);
        let for_indices_list_0_built = ForIndicesList { for_index };
        // Add an element to the vector
        for_indices_list.push(for_indices_list_0_built);
        self.push(ASTType::ForIndicesList(for_indices_list), context);
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// `for_indicesList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_indices_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_indices_list_1_built = Vec::new();
        self.push(ASTType::ForIndicesList(for_indices_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// `for_index: ident for_indexOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn for_index(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _for_index_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_index_opt = pop_item!(self, for_index_opt, ForIndexOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let for_index_built = ForIndex {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            for_index_opt,
        };
        // Calling user action here
        self.user_grammar.for_index(&for_index_built)?;
        self.push(ASTType::ForIndex(for_index_built), context);
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// `for_indexOpt /* Option<T>::Some */: in^ /* Clipped */ expression;`
    ///
    #[parol_runtime::function_name::named]
    fn for_index_opt_0(
        &mut self,
        _in: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        self.pop(context);
        let for_index_opt_0_built = ForIndexOpt {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(ASTType::ForIndexOpt(Some(for_index_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// `for_indexOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_index_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForIndexOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// `while_statement: while^ /* Clipped */ expression loop^ /* Clipped */ while_statementList /* Vec */ end^ /* Clipped */ while^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn while_statement(
        &mut self,
        _while: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _loop: &ParseTreeType<'t>,
        _while_statement_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _while0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let while_statement_list =
            pop_and_reverse_item!(self, while_statement_list, WhileStatementList, context);
        self.pop(context);
        let expression = pop_item!(self, expression, Expression, context);
        self.pop(context);
        let while_statement_built = WhileStatement {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            while_statement_list,
        };
        // Calling user action here
        self.user_grammar.while_statement(&while_statement_built)?;
        self.push(ASTType::WhileStatement(while_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// `while_statementList /* Vec<T>::Push */: statement ';'^ /* Clipped */ while_statementList;`
    ///
    #[parol_runtime::function_name::named]
    fn while_statement_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _while_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut while_statement_list =
            pop_item!(self, while_statement_list, WhileStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let while_statement_list_0_built = WhileStatementList {
            statement: (&statement)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        while_statement_list.push(while_statement_list_0_built);
        self.push(ASTType::WhileStatementList(while_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 347:
    ///
    /// `while_statementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn while_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let while_statement_list_1_built = Vec::new();
        self.push(
            ASTType::WhileStatementList(while_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 348:
    ///
    /// `when_equation: when^ /* Clipped */ equation_block@when when_equationList /* Vec */ end^ /* Clipped */ when^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn when_equation(
        &mut self,
        _when: &ParseTreeType<'t>,
        _when0: &ParseTreeType<'t>,
        _when_equation_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _when1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let when_equation_list =
            pop_and_reverse_item!(self, when_equation_list, WhenEquationList, context);
        let when0 = pop_item!(self, when0, EquationBlock, context);
        self.pop(context);
        let when_equation_built = WhenEquation {
            when0: (&when0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            when_equation_list,
        };
        // Calling user action here
        self.user_grammar.when_equation(&when_equation_built)?;
        self.push(ASTType::WhenEquation(when_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 349:
    ///
    /// `when_equationList /* Vec<T>::Push */: elsewhen^ /* Clipped */ equation_block@elsewhen when_equationList;`
    ///
    #[parol_runtime::function_name::named]
    fn when_equation_list_0(
        &mut self,
        _elsewhen: &ParseTreeType<'t>,
        _elsewhen0: &ParseTreeType<'t>,
        _when_equation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut when_equation_list = pop_item!(self, when_equation_list, WhenEquationList, context);
        let elsewhen0 = pop_item!(self, elsewhen0, EquationBlock, context);
        self.pop(context);
        let when_equation_list_0_built = WhenEquationList {
            elsewhen0: (&elsewhen0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        when_equation_list.push(when_equation_list_0_built);
        self.push(ASTType::WhenEquationList(when_equation_list), context);
        Ok(())
    }

    /// Semantic action for production 350:
    ///
    /// `when_equationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn when_equation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let when_equation_list_1_built = Vec::new();
        self.push(
            ASTType::WhenEquationList(when_equation_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 351:
    ///
    /// `when_statement: when^ /* Clipped */ statement_block@when when_statementList /* Vec */ end^ /* Clipped */ when^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn when_statement(
        &mut self,
        _when: &ParseTreeType<'t>,
        _when0: &ParseTreeType<'t>,
        _when_statement_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
        _when1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let when_statement_list =
            pop_and_reverse_item!(self, when_statement_list, WhenStatementList, context);
        let when0 = pop_item!(self, when0, StatementBlock, context);
        self.pop(context);
        let when_statement_built = WhenStatement {
            when0: (&when0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            when_statement_list,
        };
        // Calling user action here
        self.user_grammar.when_statement(&when_statement_built)?;
        self.push(ASTType::WhenStatement(when_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 352:
    ///
    /// `when_statementList /* Vec<T>::Push */: elsewhen^ /* Clipped */ statement_block@elsewhen when_statementList;`
    ///
    #[parol_runtime::function_name::named]
    fn when_statement_list_0(
        &mut self,
        _elsewhen: &ParseTreeType<'t>,
        _elsewhen0: &ParseTreeType<'t>,
        _when_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut when_statement_list =
            pop_item!(self, when_statement_list, WhenStatementList, context);
        let elsewhen0 = pop_item!(self, elsewhen0, StatementBlock, context);
        self.pop(context);
        let when_statement_list_0_built = WhenStatementList {
            elsewhen0: (&elsewhen0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        when_statement_list.push(when_statement_list_0_built);
        self.push(ASTType::WhenStatementList(when_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 353:
    ///
    /// `when_statementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn when_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let when_statement_list_1_built = Vec::new();
        self.push(
            ASTType::WhenStatementList(when_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 354:
    ///
    /// `connect_equation: connect^ /* Clipped */ '('^ /* Clipped */ component_reference ','^ /* Clipped */ component_reference ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn connect_equation(
        &mut self,
        _connect: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _component_reference: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _component_reference0: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference0 =
            pop_item!(self, component_reference0, ComponentReference, context);
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        self.pop(context);
        let connect_equation_built = ConnectEquation {
            component_reference: (&component_reference)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_reference0: (&component_reference0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .connect_equation(&connect_equation_built)?;
        self.push(ASTType::ConnectEquation(connect_equation_built), context);
        Ok(())
    }

    /// Semantic action for production 355:
    ///
    /// `expression: simple_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_0(&mut self, _simple_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression = pop_item!(self, simple_expression, SimpleExpression, context);
        let expression_0_built = ExpressionSimpleExpression {
            simple_expression: Box::new(
                (&simple_expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
        };
        let expression_0_built = Expression::SimpleExpression(Box::new(expression_0_built));
        // Calling user action here
        self.user_grammar.expression(&expression_0_built)?;
        self.push(ASTType::Expression(expression_0_built), context);
        Ok(())
    }

    /// Semantic action for production 356:
    ///
    /// `expression: if_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_1(&mut self, _if_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression = pop_item!(self, if_expression, IfExpression, context);
        let expression_1_built = ExpressionIfExpression {
            if_expression: Box::new(if_expression),
        };
        let expression_1_built = Expression::IfExpression(Box::new(expression_1_built));
        // Calling user action here
        self.user_grammar.expression(&expression_1_built)?;
        self.push(ASTType::Expression(expression_1_built), context);
        Ok(())
    }

    /// Semantic action for production 357:
    ///
    /// `if_expression: if^ /* Clipped */ expression then^ /* Clipped */ expression if_expressionList /* Vec */ else^ /* Clipped */ expression;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _then: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _if_expression_list: &ParseTreeType<'t>,
        _else: &ParseTreeType<'t>,
        _expression1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression1 = pop_item!(self, expression1, Expression, context);
        self.pop(context);
        let if_expression_list =
            pop_and_reverse_item!(self, if_expression_list, IfExpressionList, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        self.pop(context);
        let expression = pop_item!(self, expression, Expression, context);
        self.pop(context);
        let if_expression_built = IfExpression {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            expression0: (&expression0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            if_expression_list,
            expression1: (&expression1)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.if_expression(&if_expression_built)?;
        self.push(ASTType::IfExpression(if_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 358:
    ///
    /// `if_expressionList /* Vec<T>::Push */: elseif^ /* Clipped */ expression then^ /* Clipped */ expression if_expressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_0(
        &mut self,
        _elseif: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _then: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _if_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_expression_list = pop_item!(self, if_expression_list, IfExpressionList, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        self.pop(context);
        let expression = pop_item!(self, expression, Expression, context);
        self.pop(context);
        let if_expression_list_0_built = IfExpressionList {
            expression0: (&expression0)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        if_expression_list.push(if_expression_list_0_built);
        self.push(ASTType::IfExpressionList(if_expression_list), context);
        Ok(())
    }

    /// Semantic action for production 359:
    ///
    /// `if_expressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression_list_1_built = Vec::new();
        self.push(
            ASTType::IfExpressionList(if_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 360:
    ///
    /// `simple_expression: logical_expression simple_expressionOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression(
        &mut self,
        _logical_expression: &ParseTreeType<'t>,
        _simple_expression_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression_opt =
            pop_item!(self, simple_expression_opt, SimpleExpressionOpt, context);
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_built = SimpleExpression {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            simple_expression_opt,
        };
        // Calling user action here
        self.user_grammar
            .simple_expression(&simple_expression_built)?;
        self.push(ASTType::SimpleExpression(simple_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 361:
    ///
    /// `simple_expressionOpt /* Option<T>::Some */: ':'^ /* Clipped */ logical_expression simple_expressionOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _logical_expression: &ParseTreeType<'t>,
        _simple_expression_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expression_opt0 =
            pop_item!(self, simple_expression_opt0, SimpleExpressionOpt0, context);
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_opt_0_built = SimpleExpressionOpt {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            simple_expression_opt0,
        };
        self.push(
            ASTType::SimpleExpressionOpt(Some(simple_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 362:
    ///
    /// `simple_expressionOpt0 /* Option<T>::Some */: ':'^ /* Clipped */ logical_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt0_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _logical_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression = pop_item!(self, logical_expression, LogicalExpression, context);
        let simple_expression_opt0_0_built = SimpleExpressionOpt0 {
            logical_expression: (&logical_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::SimpleExpressionOpt0(Some(simple_expression_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 363:
    ///
    /// `simple_expressionOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExpressionOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 364:
    ///
    /// `simple_expressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 365:
    ///
    /// `logical_expression: logical_term logical_expressionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression(
        &mut self,
        _logical_term: &ParseTreeType<'t>,
        _logical_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression_list = pop_and_reverse_item!(
            self,
            logical_expression_list,
            LogicalExpressionList,
            context
        );
        let logical_term = pop_item!(self, logical_term, LogicalTerm, context);
        let logical_expression_built = LogicalExpression {
            logical_term: Box::new(
                (&logical_term)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            logical_expression_list,
        };
        // Calling user action here
        self.user_grammar
            .logical_expression(&logical_expression_built)?;
        self.push(
            ASTType::LogicalExpression(logical_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 366:
    ///
    /// `logical_expressionList /* Vec<T>::Push */: or^ /* Clipped */ logical_term logical_expressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression_list_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _logical_term: &ParseTreeType<'t>,
        _logical_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_expression_list = pop_item!(
            self,
            logical_expression_list,
            LogicalExpressionList,
            context
        );
        let logical_term = pop_item!(self, logical_term, LogicalTerm, context);
        self.pop(context);
        let logical_expression_list_0_built = LogicalExpressionList {
            logical_term: (&logical_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        logical_expression_list.push(logical_expression_list_0_built);
        self.push(
            ASTType::LogicalExpressionList(logical_expression_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 367:
    ///
    /// `logical_expressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_expression_list_1_built = Vec::new();
        self.push(
            ASTType::LogicalExpressionList(logical_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 368:
    ///
    /// `logical_term: logical_factor logical_termList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term(
        &mut self,
        _logical_factor: &ParseTreeType<'t>,
        _logical_term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_term_list =
            pop_and_reverse_item!(self, logical_term_list, LogicalTermList, context);
        let logical_factor = pop_item!(self, logical_factor, LogicalFactor, context);
        let logical_term_built = LogicalTerm {
            logical_factor: Box::new(
                (&logical_factor)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            logical_term_list,
        };
        // Calling user action here
        self.user_grammar.logical_term(&logical_term_built)?;
        self.push(ASTType::LogicalTerm(logical_term_built), context);
        Ok(())
    }

    /// Semantic action for production 369:
    ///
    /// `logical_termList /* Vec<T>::Push */: and^ /* Clipped */ logical_factor logical_termList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term_list_0(
        &mut self,
        _and: &ParseTreeType<'t>,
        _logical_factor: &ParseTreeType<'t>,
        _logical_term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_term_list = pop_item!(self, logical_term_list, LogicalTermList, context);
        let logical_factor = pop_item!(self, logical_factor, LogicalFactor, context);
        self.pop(context);
        let logical_term_list_0_built = LogicalTermList {
            logical_factor: (&logical_factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        logical_term_list.push(logical_term_list_0_built);
        self.push(ASTType::LogicalTermList(logical_term_list), context);
        Ok(())
    }

    /// Semantic action for production 370:
    ///
    /// `logical_termList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_term_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_term_list_1_built = Vec::new();
        self.push(ASTType::LogicalTermList(logical_term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 371:
    ///
    /// `logical_factor: logical_factorOpt /* Option */ relation;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor(
        &mut self,
        _logical_factor_opt: &ParseTreeType<'t>,
        _relation: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation = pop_item!(self, relation, Relation, context);
        let logical_factor_opt = pop_item!(self, logical_factor_opt, LogicalFactorOpt, context);
        let logical_factor_built = LogicalFactor {
            logical_factor_opt,
            relation: Box::new(
                (&relation)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
        };
        // Calling user action here
        self.user_grammar.logical_factor(&logical_factor_built)?;
        self.push(ASTType::LogicalFactor(logical_factor_built), context);
        Ok(())
    }

    /// Semantic action for production 372:
    ///
    /// `logical_factorOpt /* Option<T>::Some */: not;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor_opt_0(&mut self, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let logical_factor_opt_0_built = LogicalFactorOpt { not };
        self.push(
            ASTType::LogicalFactorOpt(Some(logical_factor_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 373:
    ///
    /// `logical_factorOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_factor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LogicalFactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 374:
    ///
    /// `relation: arithmetic_expression relationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn relation(
        &mut self,
        _arithmetic_expression: &ParseTreeType<'t>,
        _relation_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation_opt = pop_item!(self, relation_opt, RelationOpt, context);
        let arithmetic_expression =
            pop_item!(self, arithmetic_expression, ArithmeticExpression, context);
        let relation_built = Relation {
            arithmetic_expression: Box::new(
                (&arithmetic_expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            relation_opt,
        };
        // Calling user action here
        self.user_grammar.relation(&relation_built)?;
        self.push(ASTType::Relation(relation_built), context);
        Ok(())
    }

    /// Semantic action for production 375:
    ///
    /// `relationOpt /* Option<T>::Some */: relational_operator arithmetic_expression;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_0(
        &mut self,
        _relational_operator: &ParseTreeType<'t>,
        _arithmetic_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression =
            pop_item!(self, arithmetic_expression, ArithmeticExpression, context);
        let relational_operator = pop_item!(self, relational_operator, RelationalOperator, context);
        let relation_opt_0_built = RelationOpt {
            relational_operator,
            arithmetic_expression: (&arithmetic_expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(ASTType::RelationOpt(Some(relation_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 376:
    ///
    /// `relationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RelationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 377:
    ///
    /// `relational_operator: '<';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_0(&mut self, l_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_0_built = RelationalOperatorLT { l_t };
        let relational_operator_0_built = RelationalOperator::LT(relational_operator_0_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_0_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 378:
    ///
    /// `relational_operator: '<=';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_1(&mut self, l_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = l_t_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_1_built = RelationalOperatorLTEqu { l_t_equ };
        let relational_operator_1_built = RelationalOperator::LTEqu(relational_operator_1_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_1_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 379:
    ///
    /// `relational_operator: '>';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_2(&mut self, g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_2_built = RelationalOperatorGT { g_t };
        let relational_operator_2_built = RelationalOperator::GT(relational_operator_2_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_2_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 380:
    ///
    /// `relational_operator: '>=';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_3(&mut self, g_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = g_t_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_3_built = RelationalOperatorGTEqu { g_t_equ };
        let relational_operator_3_built = RelationalOperator::GTEqu(relational_operator_3_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_3_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 381:
    ///
    /// `relational_operator: '==';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_4(&mut self, equ_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ = equ_equ
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_4_built = RelationalOperatorEquEqu { equ_equ };
        let relational_operator_4_built = RelationalOperator::EquEqu(relational_operator_4_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_4_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 382:
    ///
    /// `relational_operator: '<>';`
    ///
    #[parol_runtime::function_name::named]
    fn relational_operator_5(&mut self, l_t_g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_g_t = l_t_g_t
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let relational_operator_5_built = RelationalOperatorLTGT { l_t_g_t };
        let relational_operator_5_built = RelationalOperator::LTGT(relational_operator_5_built);
        // Calling user action here
        self.user_grammar
            .relational_operator(&relational_operator_5_built)?;
        self.push(
            ASTType::RelationalOperator(relational_operator_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 383:
    ///
    /// `arithmetic_expression: arithmetic_expressionOpt /* Option */ term arithmetic_expressionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression(
        &mut self,
        _arithmetic_expression_opt: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _arithmetic_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression_list = pop_and_reverse_item!(
            self,
            arithmetic_expression_list,
            ArithmeticExpressionList,
            context
        );
        let term = pop_item!(self, term, Term, context);
        let arithmetic_expression_opt = pop_item!(
            self,
            arithmetic_expression_opt,
            ArithmeticExpressionOpt,
            context
        );
        let arithmetic_expression_built = ArithmeticExpression {
            arithmetic_expression_opt,
            term: Box::new(
                (&term)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            arithmetic_expression_list,
        };
        // Calling user action here
        self.user_grammar
            .arithmetic_expression(&arithmetic_expression_built)?;
        self.push(
            ASTType::ArithmeticExpression(arithmetic_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 384:
    ///
    /// `arithmetic_expressionList /* Vec<T>::Push */: add_operator term arithmetic_expressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_list_0(
        &mut self,
        _add_operator: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _arithmetic_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut arithmetic_expression_list = pop_item!(
            self,
            arithmetic_expression_list,
            ArithmeticExpressionList,
            context
        );
        let term = pop_item!(self, term, Term, context);
        let add_operator = pop_item!(self, add_operator, AddOperator, context);
        let arithmetic_expression_list_0_built = ArithmeticExpressionList {
            term: (&term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            add_operator,
        };
        // Add an element to the vector
        arithmetic_expression_list.push(arithmetic_expression_list_0_built);
        self.push(
            ASTType::ArithmeticExpressionList(arithmetic_expression_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 385:
    ///
    /// `arithmetic_expressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arithmetic_expression_list_1_built = Vec::new();
        self.push(
            ASTType::ArithmeticExpressionList(arithmetic_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 386:
    ///
    /// `arithmetic_expressionOpt /* Option<T>::Some */: add_operator;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_opt_0(&mut self, _add_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let add_operator = pop_item!(self, add_operator, AddOperator, context);
        let arithmetic_expression_opt_0_built = ArithmeticExpressionOpt { add_operator };
        self.push(
            ASTType::ArithmeticExpressionOpt(Some(arithmetic_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 387:
    ///
    /// `arithmetic_expressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn arithmetic_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArithmeticExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 388:
    ///
    /// `add_operator: '+';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_0(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_0_built = AddOperatorPlus { plus };
        let add_operator_0_built = AddOperator::Plus(add_operator_0_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_0_built)?;
        self.push(ASTType::AddOperator(add_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 389:
    ///
    /// `add_operator: '-';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_1(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_1_built = AddOperatorMinus { minus };
        let add_operator_1_built = AddOperator::Minus(add_operator_1_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_1_built)?;
        self.push(ASTType::AddOperator(add_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 390:
    ///
    /// `add_operator: '.+';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_2(&mut self, dot_plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_plus = dot_plus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_2_built = AddOperatorDotPlus { dot_plus };
        let add_operator_2_built = AddOperator::DotPlus(add_operator_2_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_2_built)?;
        self.push(ASTType::AddOperator(add_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 391:
    ///
    /// `add_operator: '.-';`
    ///
    #[parol_runtime::function_name::named]
    fn add_operator_3(&mut self, dot_minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_minus = dot_minus
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let add_operator_3_built = AddOperatorDotMinus { dot_minus };
        let add_operator_3_built = AddOperator::DotMinus(add_operator_3_built);
        // Calling user action here
        self.user_grammar.add_operator(&add_operator_3_built)?;
        self.push(ASTType::AddOperator(add_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 392:
    ///
    /// `term: factor termList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn term(&mut self, _factor: &ParseTreeType<'t>, _term_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list = pop_and_reverse_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let term_built = Term {
            factor: (&factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            term_list,
        };
        // Calling user action here
        self.user_grammar.term(&term_built)?;
        self.push(ASTType::Term(term_built), context);
        Ok(())
    }

    /// Semantic action for production 393:
    ///
    /// `termList /* Vec<T>::Push */: mul_operator factor termList;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_0(
        &mut self,
        _mul_operator: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut term_list = pop_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_operator = pop_item!(self, mul_operator, MulOperator, context);
        let term_list_0_built = TermList {
            factor: (&factor)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            mul_operator,
        };
        // Add an element to the vector
        term_list.push(term_list_0_built);
        self.push(ASTType::TermList(term_list), context);
        Ok(())
    }

    /// Semantic action for production 394:
    ///
    /// `termList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list_1_built = Vec::new();
        self.push(ASTType::TermList(term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 395:
    ///
    /// `mul_operator: '*';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_0_built = MulOperatorStar { star };
        let mul_operator_0_built = MulOperator::Star(mul_operator_0_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_0_built)?;
        self.push(ASTType::MulOperator(mul_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 396:
    ///
    /// `mul_operator: '/';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_1(&mut self, slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_1_built = MulOperatorSlash { slash };
        let mul_operator_1_built = MulOperator::Slash(mul_operator_1_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_1_built)?;
        self.push(ASTType::MulOperator(mul_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 397:
    ///
    /// `mul_operator: '.*';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_2(&mut self, dot_star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_star = dot_star
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_2_built = MulOperatorDotStar { dot_star };
        let mul_operator_2_built = MulOperator::DotStar(mul_operator_2_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_2_built)?;
        self.push(ASTType::MulOperator(mul_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 398:
    ///
    /// `mul_operator: './';`
    ///
    #[parol_runtime::function_name::named]
    fn mul_operator_3(&mut self, dot_slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_slash = dot_slash
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let mul_operator_3_built = MulOperatorDotSlash { dot_slash };
        let mul_operator_3_built = MulOperator::DotSlash(mul_operator_3_built);
        // Calling user action here
        self.user_grammar.mul_operator(&mul_operator_3_built)?;
        self.push(ASTType::MulOperator(mul_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 399:
    ///
    /// `factor: primary factorList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor(
        &mut self,
        _primary: &ParseTreeType<'t>,
        _factor_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list = pop_and_reverse_item!(self, factor_list, FactorList, context);
        let primary = pop_item!(self, primary, Primary, context);
        let factor_built = Factor {
            primary: Box::new(
                (&primary)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            factor_list,
        };
        // Calling user action here
        self.user_grammar.factor(&factor_built)?;
        self.push(ASTType::Factor(factor_built), context);
        Ok(())
    }

    /// Semantic action for production 400:
    ///
    /// `factorList /* Vec<T>::Push */: factorListGroup primary factorList;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_0(
        &mut self,
        _factor_list_group: &ParseTreeType<'t>,
        _primary: &ParseTreeType<'t>,
        _factor_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut factor_list = pop_item!(self, factor_list, FactorList, context);
        let primary = pop_item!(self, primary, Primary, context);
        let factor_list_group = pop_item!(self, factor_list_group, FactorListGroup, context);
        let factor_list_0_built = FactorList {
            primary: (&primary)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            factor_list_group,
        };
        // Add an element to the vector
        factor_list.push(factor_list_0_built);
        self.push(ASTType::FactorList(factor_list), context);
        Ok(())
    }

    /// Semantic action for production 401:
    ///
    /// `factorListGroup: '^';`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_group_0(&mut self, circumflex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = circumflex
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let factor_list_group_0_built = FactorListGroupCircumflex { circumflex };
        let factor_list_group_0_built = FactorListGroup::Circumflex(factor_list_group_0_built);
        self.push(ASTType::FactorListGroup(factor_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 402:
    ///
    /// `factorListGroup: '.^';`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_group_1(&mut self, dot_circumflex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_circumflex = dot_circumflex
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let factor_list_group_1_built = FactorListGroupDotCircumflex { dot_circumflex };
        let factor_list_group_1_built = FactorListGroup::DotCircumflex(factor_list_group_1_built);
        self.push(ASTType::FactorListGroup(factor_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 403:
    ///
    /// `factorList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list_1_built = Vec::new();
        self.push(ASTType::FactorList(factor_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 404:
    ///
    /// `primary: unsigned_number;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_0(&mut self, _unsigned_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_number = pop_item!(self, unsigned_number, UnsignedNumber, context);
        let primary_0_built = PrimaryUnsignedNumber { unsigned_number };
        let primary_0_built = Primary::UnsignedNumber(primary_0_built);
        // Calling user action here
        self.user_grammar.primary(&primary_0_built)?;
        self.push(ASTType::Primary(primary_0_built), context);
        Ok(())
    }

    /// Semantic action for production 405:
    ///
    /// `primary: string;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let primary_1_built = PrimaryString {
            string: (&string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let primary_1_built = Primary::String(primary_1_built);
        // Calling user action here
        self.user_grammar.primary(&primary_1_built)?;
        self.push(ASTType::Primary(primary_1_built), context);
        Ok(())
    }

    /// Semantic action for production 406:
    ///
    /// `primary: false;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_2(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let primary_2_built = PrimaryFalse { r#false };
        let primary_2_built = Primary::False(primary_2_built);
        // Calling user action here
        self.user_grammar.primary(&primary_2_built)?;
        self.push(ASTType::Primary(primary_2_built), context);
        Ok(())
    }

    /// Semantic action for production 407:
    ///
    /// `primary: true;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_3(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let primary_3_built = PrimaryTrue { r#true };
        let primary_3_built = Primary::True(primary_3_built);
        // Calling user action here
        self.user_grammar.primary(&primary_3_built)?;
        self.push(ASTType::Primary(primary_3_built), context);
        Ok(())
    }

    /// Semantic action for production 408:
    ///
    /// `primary: global_function_call;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_4(&mut self, _global_function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let global_function_call =
            pop_item!(self, global_function_call, GlobalFunctionCall, context);
        let primary_4_built = PrimaryGlobalFunctionCall {
            global_function_call: Box::new(global_function_call),
        };
        let primary_4_built = Primary::GlobalFunctionCall(primary_4_built);
        // Calling user action here
        self.user_grammar.primary(&primary_4_built)?;
        self.push(ASTType::Primary(primary_4_built), context);
        Ok(())
    }

    /// Semantic action for production 409:
    ///
    /// `primary: component_primary;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_5(&mut self, _component_primary: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_primary = pop_item!(self, component_primary, ComponentPrimary, context);
        let primary_5_built = PrimaryComponentPrimary {
            component_primary: Box::new(component_primary),
        };
        let primary_5_built = Primary::ComponentPrimary(primary_5_built);
        // Calling user action here
        self.user_grammar.primary(&primary_5_built)?;
        self.push(ASTType::Primary(primary_5_built), context);
        Ok(())
    }

    /// Semantic action for production 410:
    ///
    /// `primary: output_primary;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_6(&mut self, _output_primary: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_primary = pop_item!(self, output_primary, OutputPrimary, context);
        let primary_6_built = PrimaryOutputPrimary {
            output_primary: Box::new(output_primary),
        };
        let primary_6_built = Primary::OutputPrimary(primary_6_built);
        // Calling user action here
        self.user_grammar.primary(&primary_6_built)?;
        self.push(ASTType::Primary(primary_6_built), context);
        Ok(())
    }

    /// Semantic action for production 411:
    ///
    /// `primary: range_primary;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_7(&mut self, _range_primary: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_primary = pop_item!(self, range_primary, RangePrimary, context);
        let primary_7_built = PrimaryRangePrimary {
            range_primary: Box::new(range_primary),
        };
        let primary_7_built = Primary::RangePrimary(Box::new(primary_7_built));
        // Calling user action here
        self.user_grammar.primary(&primary_7_built)?;
        self.push(ASTType::Primary(primary_7_built), context);
        Ok(())
    }

    /// Semantic action for production 412:
    ///
    /// `primary: array_primary;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_8(&mut self, _array_primary: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_primary = pop_item!(self, array_primary, ArrayPrimary, context);
        let primary_8_built = PrimaryArrayPrimary {
            array_primary: Box::new(array_primary),
        };
        let primary_8_built = Primary::ArrayPrimary(primary_8_built);
        // Calling user action here
        self.user_grammar.primary(&primary_8_built)?;
        self.push(ASTType::Primary(primary_8_built), context);
        Ok(())
    }

    /// Semantic action for production 413:
    ///
    /// `primary: end;`
    ///
    #[parol_runtime::function_name::named]
    fn primary_9(&mut self, _end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let primary_9_built = PrimaryEnd { end };
        let primary_9_built = Primary::End(primary_9_built);
        // Calling user action here
        self.user_grammar.primary(&primary_9_built)?;
        self.push(ASTType::Primary(primary_9_built), context);
        Ok(())
    }

    /// Semantic action for production 414:
    ///
    /// `component_primary: component_reference component_primaryOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_primary(
        &mut self,
        _component_reference: &ParseTreeType<'t>,
        _component_primary_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_primary_opt =
            pop_item!(self, component_primary_opt, ComponentPrimaryOpt, context);
        let component_reference = pop_item!(self, component_reference, ComponentReference, context);
        let component_primary_built = ComponentPrimary {
            component_reference: Box::new(
                (&component_reference)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            component_primary_opt: component_primary_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .component_primary(&component_primary_built)?;
        self.push(ASTType::ComponentPrimary(component_primary_built), context);
        Ok(())
    }

    /// Semantic action for production 415:
    ///
    /// `component_primaryOpt /* Option<T>::Some */: function_call_args;`
    ///
    #[parol_runtime::function_name::named]
    fn component_primary_opt_0(&mut self, _function_call_args: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_args = pop_item!(self, function_call_args, FunctionCallArgs, context);
        let component_primary_opt_0_built = ComponentPrimaryOpt {
            function_call_args: (&function_call_args)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ComponentPrimaryOpt(Some(component_primary_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 416:
    ///
    /// `component_primaryOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_primary_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentPrimaryOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 417:
    ///
    /// `output_primary: '('^ /* Clipped */ output_expression_list ')'^ /* Clipped */ output_primaryOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn output_primary(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _output_expression_list: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _output_primary_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_primary_opt = pop_item!(self, output_primary_opt, OutputPrimaryOpt, context);
        let output_expression_list =
            pop_item!(self, output_expression_list, OutputExpressionList, context);
        let output_primary_built = OutputPrimary {
            output_expression_list: (&output_expression_list)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            output_primary_opt: output_primary_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.output_primary(&output_primary_built)?;
        self.push(ASTType::OutputPrimary(output_primary_built), context);
        Ok(())
    }

    /// Semantic action for production 418:
    ///
    /// `output_primaryOpt /* Option<T>::Some */: output_primaryOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn output_primary_opt_0(
        &mut self,
        _output_primary_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_primary_opt_group = pop_item!(
            self,
            output_primary_opt_group,
            OutputPrimaryOptGroup,
            context
        );
        let output_primary_opt_0_built = OutputPrimaryOpt {
            output_primary_opt_group,
        };
        self.push(
            ASTType::OutputPrimaryOpt(Some(output_primary_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 419:
    ///
    /// `output_primaryOptGroup: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn output_primary_opt_group_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let output_primary_opt_group_0_built = OutputPrimaryOptGroupArraySubscripts {
            array_subscripts: Box::new(
                (&array_subscripts)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
        };
        let output_primary_opt_group_0_built =
            OutputPrimaryOptGroup::ArraySubscripts(output_primary_opt_group_0_built);
        self.push(
            ASTType::OutputPrimaryOptGroup(output_primary_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 420:
    ///
    /// `output_primaryOptGroup: '.'^ /* Clipped */ ident;`
    ///
    #[parol_runtime::function_name::named]
    fn output_primary_opt_group_1(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let output_primary_opt_group_1_built = OutputPrimaryOptGroupDotIdent {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let output_primary_opt_group_1_built =
            OutputPrimaryOptGroup::DotIdent(output_primary_opt_group_1_built);
        self.push(
            ASTType::OutputPrimaryOptGroup(output_primary_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 421:
    ///
    /// `output_primaryOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn output_primary_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OutputPrimaryOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 422:
    ///
    /// `range_primary: '['^ /* Clipped */ expression_list range_primaryList /* Vec */ ']'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn range_primary(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expression_list: &ParseTreeType<'t>,
        _range_primary_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_primary_list =
            pop_and_reverse_item!(self, range_primary_list, RangePrimaryList, context);
        let expression_list = pop_item!(self, expression_list, ExpressionList, context);
        let range_primary_built = RangePrimary {
            expression_list: Box::new(expression_list),
            range_primary_list,
        };
        // Calling user action here
        self.user_grammar.range_primary(&range_primary_built)?;
        self.push(ASTType::RangePrimary(range_primary_built), context);
        Ok(())
    }

    /// Semantic action for production 423:
    ///
    /// `range_primaryList /* Vec<T>::Push */: ';'^ /* Clipped */ expression_list range_primaryList;`
    ///
    #[parol_runtime::function_name::named]
    fn range_primary_list_0(
        &mut self,
        _semicolon: &ParseTreeType<'t>,
        _expression_list: &ParseTreeType<'t>,
        _range_primary_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut range_primary_list = pop_item!(self, range_primary_list, RangePrimaryList, context);
        let expression_list = pop_item!(self, expression_list, ExpressionList, context);
        let range_primary_list_0_built = RangePrimaryList { expression_list };
        // Add an element to the vector
        range_primary_list.push(range_primary_list_0_built);
        self.push(ASTType::RangePrimaryList(range_primary_list), context);
        Ok(())
    }

    /// Semantic action for production 424:
    ///
    /// `range_primaryList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn range_primary_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_primary_list_1_built = Vec::new();
        self.push(
            ASTType::RangePrimaryList(range_primary_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 425:
    ///
    /// `array_primary: '{'^ /* Clipped */ array_arguments '}'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_primary(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _array_arguments: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments = pop_item!(self, array_arguments, ArrayArguments, context);
        let array_primary_built = ArrayPrimary {
            array_arguments: Box::new(array_arguments),
        };
        // Calling user action here
        self.user_grammar.array_primary(&array_primary_built)?;
        self.push(ASTType::ArrayPrimary(array_primary_built), context);
        Ok(())
    }

    /// Semantic action for production 426:
    ///
    /// `global_function_call: global_function_callGroup function_call_args;`
    ///
    #[parol_runtime::function_name::named]
    fn global_function_call(
        &mut self,
        _global_function_call_group: &ParseTreeType<'t>,
        _function_call_args: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_args = pop_item!(self, function_call_args, FunctionCallArgs, context);
        let global_function_call_group = pop_item!(
            self,
            global_function_call_group,
            GlobalFunctionCallGroup,
            context
        );
        let global_function_call_built = GlobalFunctionCall {
            global_function_call_group,
            function_call_args: (&function_call_args)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .global_function_call(&global_function_call_built)?;
        self.push(
            ASTType::GlobalFunctionCall(global_function_call_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 427:
    ///
    /// `global_function_callGroup: der;`
    ///
    #[parol_runtime::function_name::named]
    fn global_function_call_group_0(&mut self, _der: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let der = pop_item!(self, der, Der, context);
        let global_function_call_group_0_built = GlobalFunctionCallGroupDer { der };
        let global_function_call_group_0_built =
            GlobalFunctionCallGroup::Der(global_function_call_group_0_built);
        self.push(
            ASTType::GlobalFunctionCallGroup(global_function_call_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 428:
    ///
    /// `global_function_callGroup: initial;`
    ///
    #[parol_runtime::function_name::named]
    fn global_function_call_group_1(&mut self, _initial: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial = pop_item!(self, initial, Initial, context);
        let global_function_call_group_1_built = GlobalFunctionCallGroupInitial { initial };
        let global_function_call_group_1_built =
            GlobalFunctionCallGroup::Initial(global_function_call_group_1_built);
        self.push(
            ASTType::GlobalFunctionCallGroup(global_function_call_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 429:
    ///
    /// `global_function_callGroup: pure;`
    ///
    #[parol_runtime::function_name::named]
    fn global_function_call_group_2(&mut self, _pure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pure = pop_item!(self, pure, Pure, context);
        let global_function_call_group_2_built = GlobalFunctionCallGroupPure { pure };
        let global_function_call_group_2_built =
            GlobalFunctionCallGroup::Pure(global_function_call_group_2_built);
        self.push(
            ASTType::GlobalFunctionCallGroup(global_function_call_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 430:
    ///
    /// `unsigned_number: unsigned_integer;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_number_0(&mut self, _unsigned_integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_integer = pop_item!(self, unsigned_integer, UnsignedInteger, context);
        let unsigned_number_0_built = UnsignedNumberUnsignedInteger {
            unsigned_integer: (&unsigned_integer)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let unsigned_number_0_built = UnsignedNumber::UnsignedInteger(unsigned_number_0_built);
        // Calling user action here
        self.user_grammar
            .unsigned_number(&unsigned_number_0_built)?;
        self.push(ASTType::UnsignedNumber(unsigned_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 431:
    ///
    /// `unsigned_number: unsigned_real;`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_number_1(&mut self, _unsigned_real: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_real = pop_item!(self, unsigned_real, UnsignedReal, context);
        let unsigned_number_1_built = UnsignedNumberUnsignedReal {
            unsigned_real: (&unsigned_real)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let unsigned_number_1_built = UnsignedNumber::UnsignedReal(unsigned_number_1_built);
        // Calling user action here
        self.user_grammar
            .unsigned_number(&unsigned_number_1_built)?;
        self.push(ASTType::UnsignedNumber(unsigned_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 432:
    ///
    /// `type_specifier: type_specifierOpt /* Option */ name;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier(
        &mut self,
        _type_specifier_opt: &ParseTreeType<'t>,
        _name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name = pop_item!(self, name, Name, context);
        let type_specifier_opt = pop_item!(self, type_specifier_opt, TypeSpecifierOpt, context);
        let type_specifier_built = TypeSpecifier {
            type_specifier_opt,
            name: (&name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.type_specifier(&type_specifier_built)?;
        self.push(ASTType::TypeSpecifier(type_specifier_built), context);
        Ok(())
    }

    /// Semantic action for production 433:
    ///
    /// `type_specifierOpt /* Option<T>::Some */: '.'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier_opt_0(&mut self, _dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_specifier_opt_0_built = TypeSpecifierOpt {};
        self.push(
            ASTType::TypeSpecifierOpt(Some(type_specifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 434:
    ///
    /// `type_specifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_specifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeSpecifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 435:
    ///
    /// `name: ident nameList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn name(&mut self, _ident: &ParseTreeType<'t>, _name_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name_list = pop_and_reverse_item!(self, name_list, NameList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let name_built = Name {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            name_list,
        };
        // Calling user action here
        self.user_grammar.name(&name_built)?;
        self.push(ASTType::Name(name_built), context);
        Ok(())
    }

    /// Semantic action for production 436:
    ///
    /// `nameList /* Vec<T>::Push */: '.'^ /* Clipped */ ident nameList;`
    ///
    #[parol_runtime::function_name::named]
    fn name_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _name_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut name_list = pop_item!(self, name_list, NameList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let name_list_0_built = NameList {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        name_list.push(name_list_0_built);
        self.push(ASTType::NameList(name_list), context);
        Ok(())
    }

    /// Semantic action for production 437:
    ///
    /// `nameList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn name_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let name_list_1_built = Vec::new();
        self.push(ASTType::NameList(name_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 438:
    ///
    /// `component_reference: component_referenceOpt /* Option */ ident component_referenceOpt0 /* Option */ component_referenceList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference(
        &mut self,
        _component_reference_opt: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _component_reference_opt0: &ParseTreeType<'t>,
        _component_reference_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_list = pop_and_reverse_item!(
            self,
            component_reference_list,
            ComponentReferenceList,
            context
        );
        let component_reference_opt0 = pop_item!(
            self,
            component_reference_opt0,
            ComponentReferenceOpt0,
            context
        );
        let ident = pop_item!(self, ident, Ident, context);
        let component_reference_opt = pop_item!(
            self,
            component_reference_opt,
            ComponentReferenceOpt,
            context
        );
        let component_reference_built = ComponentReference {
            component_reference_opt,
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_reference_opt0: component_reference_opt0.map(Box::new),
            component_reference_list,
        };
        // Calling user action here
        self.user_grammar
            .component_reference(&component_reference_built)?;
        self.push(
            ASTType::ComponentReference(component_reference_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 439:
    ///
    /// `component_referenceList /* Vec<T>::Push */: component_ref_part component_referenceList;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_list_0(
        &mut self,
        _component_ref_part: &ParseTreeType<'t>,
        _component_reference_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut component_reference_list = pop_item!(
            self,
            component_reference_list,
            ComponentReferenceList,
            context
        );
        let component_ref_part = pop_item!(self, component_ref_part, ComponentRefPart, context);
        let component_reference_list_0_built = ComponentReferenceList {
            component_ref_part: (&component_ref_part)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        component_reference_list.push(component_reference_list_0_built);
        self.push(
            ASTType::ComponentReferenceList(component_reference_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 440:
    ///
    /// `component_referenceList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_list_1_built = Vec::new();
        self.push(
            ASTType::ComponentReferenceList(component_reference_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 441:
    ///
    /// `component_referenceOpt0 /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt0_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let component_reference_opt0_0_built = ComponentReferenceOpt0 {
            array_subscripts: (&array_subscripts)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ComponentReferenceOpt0(Some(component_reference_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 442:
    ///
    /// `component_referenceOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentReferenceOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 443:
    ///
    /// `component_referenceOpt /* Option<T>::Some */: '.'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt_0(&mut self, _dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_reference_opt_0_built = ComponentReferenceOpt {};
        self.push(
            ASTType::ComponentReferenceOpt(Some(component_reference_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 444:
    ///
    /// `component_referenceOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_reference_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentReferenceOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 445:
    ///
    /// `component_ref_part: '.'^ /* Clipped */ ident component_ref_partOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_ref_part(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _component_ref_part_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_ref_part_opt =
            pop_item!(self, component_ref_part_opt, ComponentRefPartOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let component_ref_part_built = ComponentRefPart {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            component_ref_part_opt,
        };
        // Calling user action here
        self.user_grammar
            .component_ref_part(&component_ref_part_built)?;
        self.push(ASTType::ComponentRefPart(component_ref_part_built), context);
        Ok(())
    }

    /// Semantic action for production 446:
    ///
    /// `component_ref_partOpt /* Option<T>::Some */: array_subscripts;`
    ///
    #[parol_runtime::function_name::named]
    fn component_ref_part_opt_0(&mut self, _array_subscripts: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts = pop_item!(self, array_subscripts, ArraySubscripts, context);
        let component_ref_part_opt_0_built = ComponentRefPartOpt {
            array_subscripts: (&array_subscripts)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::ComponentRefPartOpt(Some(component_ref_part_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 447:
    ///
    /// `component_ref_partOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_ref_part_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentRefPartOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 448:
    ///
    /// `function_call_args: '('^ /* Clipped */ function_call_argsOpt /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_args(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _function_call_args_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_args_opt =
            pop_item!(self, function_call_args_opt, FunctionCallArgsOpt, context);
        let function_call_args_built = FunctionCallArgs {
            function_call_args_opt: function_call_args_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .function_call_args(&function_call_args_built)?;
        self.push(ASTType::FunctionCallArgs(function_call_args_built), context);
        Ok(())
    }

    /// Semantic action for production 449:
    ///
    /// `function_call_argsOpt /* Option<T>::Some */: function_arguments;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_args_opt_0(&mut self, _function_arguments: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments = pop_item!(self, function_arguments, FunctionArguments, context);
        let function_call_args_opt_0_built = FunctionCallArgsOpt {
            function_arguments: (&function_arguments)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::FunctionCallArgsOpt(Some(function_call_args_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 450:
    ///
    /// `function_call_argsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_args_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionCallArgsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 451:
    ///
    /// `function_arguments: expression function_argumentsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_0(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _function_arguments_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_opt =
            pop_item!(self, function_arguments_opt, FunctionArgumentsOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let function_arguments_0_built = FunctionArgumentsExpressionFunctionArgumentsOpt {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            function_arguments_opt: function_arguments_opt.map(Box::new),
        };
        let function_arguments_0_built =
            FunctionArguments::ExpressionFunctionArgumentsOpt(Box::new(function_arguments_0_built));
        // Calling user action here
        self.user_grammar
            .function_arguments(&function_arguments_0_built)?;
        self.push(
            ASTType::FunctionArguments(function_arguments_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 452:
    ///
    /// `function_arguments: function_partial_application function_argumentsOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_1(
        &mut self,
        _function_partial_application: &ParseTreeType<'t>,
        _function_arguments_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_opt0 = pop_item!(
            self,
            function_arguments_opt0,
            FunctionArgumentsOpt0,
            context
        );
        let function_partial_application = pop_item!(
            self,
            function_partial_application,
            FunctionPartialApplication,
            context
        );
        let function_arguments_1_built =
            FunctionArgumentsFunctionPartialApplicationFunctionArgumentsOpt0 {
                function_partial_application: Box::new(function_partial_application),
                function_arguments_opt0: function_arguments_opt0.map(Box::new),
            };
        let function_arguments_1_built =
            FunctionArguments::FunctionPartialApplicationFunctionArgumentsOpt0(Box::new(
                function_arguments_1_built,
            ));
        // Calling user action here
        self.user_grammar
            .function_arguments(&function_arguments_1_built)?;
        self.push(
            ASTType::FunctionArguments(function_arguments_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 453:
    ///
    /// `function_arguments: named_arguments;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_2(&mut self, _named_arguments: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_arguments = pop_item!(self, named_arguments, NamedArguments, context);
        let function_arguments_2_built = FunctionArgumentsNamedArguments {
            named_arguments: Box::new(named_arguments),
        };
        let function_arguments_2_built =
            FunctionArguments::NamedArguments(Box::new(function_arguments_2_built));
        // Calling user action here
        self.user_grammar
            .function_arguments(&function_arguments_2_built)?;
        self.push(
            ASTType::FunctionArguments(function_arguments_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 454:
    ///
    /// `function_argumentsOpt0 /* Option<T>::Some */: ','^ /* Clipped */ function_arguments_non_first;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt0_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _function_arguments_non_first: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_non_first = pop_item!(
            self,
            function_arguments_non_first,
            FunctionArgumentsNonFirst,
            context
        );
        let function_arguments_opt0_0_built = FunctionArgumentsOpt0 {
            function_arguments_non_first: (&function_arguments_non_first)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::FunctionArgumentsOpt0(Some(function_arguments_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 455:
    ///
    /// `function_argumentsOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionArgumentsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 456:
    ///
    /// `function_argumentsOpt /* Option<T>::Some */: function_argumentsOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt_0(
        &mut self,
        _function_arguments_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_opt_group = pop_item!(
            self,
            function_arguments_opt_group,
            FunctionArgumentsOptGroup,
            context
        );
        let function_arguments_opt_0_built = FunctionArgumentsOpt {
            function_arguments_opt_group,
        };
        self.push(
            ASTType::FunctionArgumentsOpt(Some(function_arguments_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 457:
    ///
    /// `function_argumentsOptGroup: ','^ /* Clipped */ function_arguments_non_first;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt_group_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _function_arguments_non_first: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_non_first = pop_item!(
            self,
            function_arguments_non_first,
            FunctionArgumentsNonFirst,
            context
        );
        let function_arguments_opt_group_0_built =
            FunctionArgumentsOptGroupCommaFunctionArgumentsNonFirst {
                function_arguments_non_first: (&function_arguments_non_first)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            };
        let function_arguments_opt_group_0_built =
            FunctionArgumentsOptGroup::CommaFunctionArgumentsNonFirst(
                function_arguments_opt_group_0_built,
            );
        self.push(
            ASTType::FunctionArgumentsOptGroup(function_arguments_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 458:
    ///
    /// `function_argumentsOptGroup: for for_indices;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt_group_1(
        &mut self,
        _for: &ParseTreeType<'t>,
        _for_indices: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_indices = pop_item!(self, for_indices, ForIndices, context);
        let r#for = pop_item!(self, r#for, For, context);
        let function_arguments_opt_group_1_built =
            FunctionArgumentsOptGroupForForIndices { r#for, for_indices };
        let function_arguments_opt_group_1_built =
            FunctionArgumentsOptGroup::ForForIndices(function_arguments_opt_group_1_built);
        self.push(
            ASTType::FunctionArgumentsOptGroup(function_arguments_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 459:
    ///
    /// `function_argumentsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionArgumentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 460:
    ///
    /// `function_arguments_non_first: function_argument function_arguments_non_firstOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_non_first_0(
        &mut self,
        _function_argument: &ParseTreeType<'t>,
        _function_arguments_non_first_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_non_first_opt = pop_item!(
            self,
            function_arguments_non_first_opt,
            FunctionArgumentsNonFirstOpt,
            context
        );
        let function_argument = pop_item!(self, function_argument, FunctionArgument, context);
        let function_arguments_non_first_0_built =
            FunctionArgumentsNonFirstFunctionArgumentFunctionArgumentsNonFirstOpt {
                function_argument: (&function_argument)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
                function_arguments_non_first_opt: function_arguments_non_first_opt.map(Box::new),
            };
        let function_arguments_non_first_0_built =
            FunctionArgumentsNonFirst::FunctionArgumentFunctionArgumentsNonFirstOpt(
                function_arguments_non_first_0_built,
            );
        // Calling user action here
        self.user_grammar
            .function_arguments_non_first(&function_arguments_non_first_0_built)?;
        self.push(
            ASTType::FunctionArgumentsNonFirst(function_arguments_non_first_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 461:
    ///
    /// `function_arguments_non_first: named_arguments;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_non_first_1(
        &mut self,
        _named_arguments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_arguments = pop_item!(self, named_arguments, NamedArguments, context);
        let function_arguments_non_first_1_built =
            FunctionArgumentsNonFirstNamedArguments { named_arguments };
        let function_arguments_non_first_1_built =
            FunctionArgumentsNonFirst::NamedArguments(function_arguments_non_first_1_built);
        // Calling user action here
        self.user_grammar
            .function_arguments_non_first(&function_arguments_non_first_1_built)?;
        self.push(
            ASTType::FunctionArgumentsNonFirst(function_arguments_non_first_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 462:
    ///
    /// `function_arguments_non_firstOpt /* Option<T>::Some */: ','^ /* Clipped */ function_arguments_non_first;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_non_first_opt_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _function_arguments_non_first: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_arguments_non_first = pop_item!(
            self,
            function_arguments_non_first,
            FunctionArgumentsNonFirst,
            context
        );
        let function_arguments_non_first_opt_0_built = FunctionArgumentsNonFirstOpt {
            function_arguments_non_first: (&function_arguments_non_first)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::FunctionArgumentsNonFirstOpt(Some(function_arguments_non_first_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 463:
    ///
    /// `function_arguments_non_firstOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_arguments_non_first_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionArgumentsNonFirstOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 464:
    ///
    /// `array_arguments: expression array_argumentsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _array_arguments_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments_opt = pop_item!(self, array_arguments_opt, ArrayArgumentsOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let array_arguments_built = ArrayArguments {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            array_arguments_opt: array_arguments_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.array_arguments(&array_arguments_built)?;
        self.push(ASTType::ArrayArguments(array_arguments_built), context);
        Ok(())
    }

    /// Semantic action for production 465:
    ///
    /// `array_argumentsOpt /* Option<T>::Some */: array_argumentsOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_opt_0(
        &mut self,
        _array_arguments_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments_opt_group = pop_item!(
            self,
            array_arguments_opt_group,
            ArrayArgumentsOptGroup,
            context
        );
        let array_arguments_opt_0_built = ArrayArgumentsOpt {
            array_arguments_opt_group,
        };
        self.push(
            ASTType::ArrayArgumentsOpt(Some(array_arguments_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 466:
    ///
    /// `array_argumentsOptGroup: ','^ /* Clipped */ array_arguments_non_first;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_opt_group_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _array_arguments_non_first: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments_non_first = pop_item!(
            self,
            array_arguments_non_first,
            ArrayArgumentsNonFirst,
            context
        );
        let array_arguments_opt_group_0_built = ArrayArgumentsOptGroupCommaArrayArgumentsNonFirst {
            array_arguments_non_first: Box::new(array_arguments_non_first),
        };
        let array_arguments_opt_group_0_built =
            ArrayArgumentsOptGroup::CommaArrayArgumentsNonFirst(array_arguments_opt_group_0_built);
        self.push(
            ASTType::ArrayArgumentsOptGroup(array_arguments_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 467:
    ///
    /// `array_argumentsOptGroup: for for_indices;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_opt_group_1(
        &mut self,
        _for: &ParseTreeType<'t>,
        _for_indices: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_indices = pop_item!(self, for_indices, ForIndices, context);
        let r#for = pop_item!(self, r#for, For, context);
        let array_arguments_opt_group_1_built = ArrayArgumentsOptGroupForForIndices {
            r#for,
            for_indices: Box::new(for_indices),
        };
        let array_arguments_opt_group_1_built =
            ArrayArgumentsOptGroup::ForForIndices(array_arguments_opt_group_1_built);
        self.push(
            ASTType::ArrayArgumentsOptGroup(array_arguments_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 468:
    ///
    /// `array_argumentsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayArgumentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 469:
    ///
    /// `array_arguments_non_first: expression array_arguments_non_firstOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_non_first(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _array_arguments_non_first_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments_non_first_opt = pop_item!(
            self,
            array_arguments_non_first_opt,
            ArrayArgumentsNonFirstOpt,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let array_arguments_non_first_built = ArrayArgumentsNonFirst {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            array_arguments_non_first_opt: array_arguments_non_first_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .array_arguments_non_first(&array_arguments_non_first_built)?;
        self.push(
            ASTType::ArrayArgumentsNonFirst(array_arguments_non_first_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 470:
    ///
    /// `array_arguments_non_firstOpt /* Option<T>::Some */: ','^ /* Clipped */ array_arguments_non_first;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_non_first_opt_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _array_arguments_non_first: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_arguments_non_first = pop_item!(
            self,
            array_arguments_non_first,
            ArrayArgumentsNonFirst,
            context
        );
        let array_arguments_non_first_opt_0_built = ArrayArgumentsNonFirstOpt {
            array_arguments_non_first,
        };
        self.push(
            ASTType::ArrayArgumentsNonFirstOpt(Some(array_arguments_non_first_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 471:
    ///
    /// `array_arguments_non_firstOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_arguments_non_first_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayArgumentsNonFirstOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 472:
    ///
    /// `named_arguments: named_argument named_argumentsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn named_arguments(
        &mut self,
        _named_argument: &ParseTreeType<'t>,
        _named_arguments_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_arguments_opt = pop_item!(self, named_arguments_opt, NamedArgumentsOpt, context);
        let named_argument = pop_item!(self, named_argument, NamedArgument, context);
        let named_arguments_built = NamedArguments {
            named_argument,
            named_arguments_opt: named_arguments_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.named_arguments(&named_arguments_built)?;
        self.push(ASTType::NamedArguments(named_arguments_built), context);
        Ok(())
    }

    /// Semantic action for production 473:
    ///
    /// `named_argumentsOpt /* Option<T>::Some */: ','^ /* Clipped */ named_arguments;`
    ///
    #[parol_runtime::function_name::named]
    fn named_arguments_opt_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _named_arguments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_arguments = pop_item!(self, named_arguments, NamedArguments, context);
        let named_arguments_opt_0_built = NamedArgumentsOpt { named_arguments };
        self.push(
            ASTType::NamedArgumentsOpt(Some(named_arguments_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 474:
    ///
    /// `named_argumentsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn named_arguments_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NamedArgumentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 475:
    ///
    /// `named_argument: ident '='^ /* Clipped */ function_argument;`
    ///
    #[parol_runtime::function_name::named]
    fn named_argument(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _function_argument: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_argument = pop_item!(self, function_argument, FunctionArgument, context);
        let ident = pop_item!(self, ident, Ident, context);
        let named_argument_built = NamedArgument {
            ident: (&ident)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            function_argument: (&function_argument)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.named_argument(&named_argument_built)?;
        self.push(ASTType::NamedArgument(named_argument_built), context);
        Ok(())
    }

    /// Semantic action for production 476:
    ///
    /// `function_argument: function_partial_application;`
    ///
    #[parol_runtime::function_name::named]
    fn function_argument_0(
        &mut self,
        _function_partial_application: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_partial_application = pop_item!(
            self,
            function_partial_application,
            FunctionPartialApplication,
            context
        );
        let function_argument_0_built = FunctionArgumentFunctionPartialApplication {
            function_partial_application: Box::new(function_partial_application),
        };
        let function_argument_0_built =
            FunctionArgument::FunctionPartialApplication(function_argument_0_built);
        // Calling user action here
        self.user_grammar
            .function_argument(&function_argument_0_built)?;
        self.push(
            ASTType::FunctionArgument(function_argument_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 477:
    ///
    /// `function_argument: expression;`
    ///
    #[parol_runtime::function_name::named]
    fn function_argument_1(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let function_argument_1_built = FunctionArgumentExpression {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
        };
        let function_argument_1_built =
            FunctionArgument::Expression(Box::new(function_argument_1_built));
        // Calling user action here
        self.user_grammar
            .function_argument(&function_argument_1_built)?;
        self.push(
            ASTType::FunctionArgument(function_argument_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 478:
    ///
    /// `function_partial_application: function type_specifier '('^ /* Clipped */ function_partial_applicationOpt /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn function_partial_application(
        &mut self,
        _function: &ParseTreeType<'t>,
        _type_specifier: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _function_partial_application_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_partial_application_opt = pop_item!(
            self,
            function_partial_application_opt,
            FunctionPartialApplicationOpt,
            context
        );
        let type_specifier = pop_item!(self, type_specifier, TypeSpecifier, context);
        let function = pop_item!(self, function, Function, context);
        let function_partial_application_built = FunctionPartialApplication {
            function,
            type_specifier,
            function_partial_application_opt,
        };
        // Calling user action here
        self.user_grammar
            .function_partial_application(&function_partial_application_built)?;
        self.push(
            ASTType::FunctionPartialApplication(function_partial_application_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 479:
    ///
    /// `function_partial_applicationOpt /* Option<T>::Some */: named_arguments;`
    ///
    #[parol_runtime::function_name::named]
    fn function_partial_application_opt_0(
        &mut self,
        _named_arguments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_arguments = pop_item!(self, named_arguments, NamedArguments, context);
        let function_partial_application_opt_0_built =
            FunctionPartialApplicationOpt { named_arguments };
        self.push(
            ASTType::FunctionPartialApplicationOpt(Some(function_partial_application_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 480:
    ///
    /// `function_partial_applicationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_partial_application_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionPartialApplicationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 481:
    ///
    /// `output_expression_list: output_expression_listOpt /* Option */ output_expression_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list(
        &mut self,
        _output_expression_list_opt: &ParseTreeType<'t>,
        _output_expression_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_expression_list_list = pop_and_reverse_item!(
            self,
            output_expression_list_list,
            OutputExpressionListList,
            context
        );
        let output_expression_list_opt = pop_item!(
            self,
            output_expression_list_opt,
            OutputExpressionListOpt,
            context
        );
        let output_expression_list_built = OutputExpressionList {
            output_expression_list_opt: output_expression_list_opt.map(Box::new),
            output_expression_list_list,
        };
        // Calling user action here
        self.user_grammar
            .output_expression_list(&output_expression_list_built)?;
        self.push(
            ASTType::OutputExpressionList(output_expression_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 482:
    ///
    /// `output_expression_listList /* Vec<T>::Push */: ','^ /* Clipped */ output_expression_listOpt0 /* Option */ output_expression_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _output_expression_list_opt0: &ParseTreeType<'t>,
        _output_expression_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut output_expression_list_list = pop_item!(
            self,
            output_expression_list_list,
            OutputExpressionListList,
            context
        );
        let output_expression_list_opt0 = pop_item!(
            self,
            output_expression_list_opt0,
            OutputExpressionListOpt0,
            context
        );
        let output_expression_list_list_0_built = OutputExpressionListList {
            output_expression_list_opt0,
        };
        // Add an element to the vector
        output_expression_list_list.push(output_expression_list_list_0_built);
        self.push(
            ASTType::OutputExpressionListList(output_expression_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 483:
    ///
    /// `output_expression_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_expression_list_list_1_built = Vec::new();
        self.push(
            ASTType::OutputExpressionListList(output_expression_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 484:
    ///
    /// `output_expression_listOpt0 /* Option<T>::Some */: expression;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_opt0_0(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let output_expression_list_opt0_0_built = OutputExpressionListOpt0 {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::OutputExpressionListOpt0(Some(output_expression_list_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 485:
    ///
    /// `output_expression_listOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OutputExpressionListOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 486:
    ///
    /// `output_expression_listOpt /* Option<T>::Some */: expression;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_opt_0(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let output_expression_list_opt_0_built = OutputExpressionListOpt {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        self.push(
            ASTType::OutputExpressionListOpt(Some(output_expression_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 487:
    ///
    /// `output_expression_listOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn output_expression_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OutputExpressionListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 488:
    ///
    /// `expression_list: expression expression_listList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_list(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _expression_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list_list =
            pop_and_reverse_item!(self, expression_list_list, ExpressionListList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let expression_list_built = ExpressionList {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            expression_list_list,
        };
        // Calling user action here
        self.user_grammar.expression_list(&expression_list_built)?;
        self.push(ASTType::ExpressionList(expression_list_built), context);
        Ok(())
    }

    /// Semantic action for production 489:
    ///
    /// `expression_listList /* Vec<T>::Push */: ','^ /* Clipped */ expression expression_listList;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _expression_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_list_list =
            pop_item!(self, expression_list_list, ExpressionListList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let expression_list_list_0_built = ExpressionListList {
            expression: (&expression)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        expression_list_list.push(expression_list_list_0_built);
        self.push(ASTType::ExpressionListList(expression_list_list), context);
        Ok(())
    }

    /// Semantic action for production 490:
    ///
    /// `expression_listList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list_list_1_built = Vec::new();
        self.push(
            ASTType::ExpressionListList(expression_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 491:
    ///
    /// `array_subscripts: '['^ /* Clipped */ subscript array_subscriptsList /* Vec */ ']'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _subscript: &ParseTreeType<'t>,
        _array_subscripts_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts_list =
            pop_and_reverse_item!(self, array_subscripts_list, ArraySubscriptsList, context);
        let subscript = pop_item!(self, subscript, Subscript, context);
        let array_subscripts_built = ArraySubscripts {
            subscript: Box::new(
                (&subscript)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
            array_subscripts_list,
        };
        // Calling user action here
        self.user_grammar
            .array_subscripts(&array_subscripts_built)?;
        self.push(ASTType::ArraySubscripts(array_subscripts_built), context);
        Ok(())
    }

    /// Semantic action for production 492:
    ///
    /// `array_subscriptsList /* Vec<T>::Push */: ','^ /* Clipped */ subscript array_subscriptsList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _subscript: &ParseTreeType<'t>,
        _array_subscripts_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_subscripts_list =
            pop_item!(self, array_subscripts_list, ArraySubscriptsList, context);
        let subscript = pop_item!(self, subscript, Subscript, context);
        let array_subscripts_list_0_built = ArraySubscriptsList {
            subscript: (&subscript)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        array_subscripts_list.push(array_subscripts_list_0_built);
        self.push(ASTType::ArraySubscriptsList(array_subscripts_list), context);
        Ok(())
    }

    /// Semantic action for production 493:
    ///
    /// `array_subscriptsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_subscripts_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_subscripts_list_1_built = Vec::new();
        self.push(
            ASTType::ArraySubscriptsList(array_subscripts_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 494:
    ///
    /// `subscript: ':';`
    ///
    #[parol_runtime::function_name::named]
    fn subscript_0(&mut self, colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let subscript_0_built = SubscriptColon { colon };
        let subscript_0_built = Subscript::Colon(subscript_0_built);
        // Calling user action here
        self.user_grammar.subscript(&subscript_0_built)?;
        self.push(ASTType::Subscript(subscript_0_built), context);
        Ok(())
    }

    /// Semantic action for production 495:
    ///
    /// `subscript: expression;`
    ///
    #[parol_runtime::function_name::named]
    fn subscript_1(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let subscript_1_built = SubscriptExpression {
            expression: Box::new(
                (&expression)
                    .try_into()
                    .map_err(parol_runtime::ParolError::UserError)?,
            ),
        };
        let subscript_1_built = Subscript::Expression(subscript_1_built);
        // Calling user action here
        self.user_grammar.subscript(&subscript_1_built)?;
        self.push(ASTType::Subscript(subscript_1_built), context);
        Ok(())
    }

    /// Semantic action for production 496:
    ///
    /// `description: description_string descriptionOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn description(
        &mut self,
        _description_string: &ParseTreeType<'t>,
        _description_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_opt = pop_item!(self, description_opt, DescriptionOpt, context);
        let description_string = pop_item!(self, description_string, DescriptionString, context);
        let description_built = Description {
            description_string: (&description_string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description_opt,
        };
        // Calling user action here
        self.user_grammar.description(&description_built)?;
        self.push(ASTType::Description(description_built), context);
        Ok(())
    }

    /// Semantic action for production 497:
    ///
    /// `descriptionOpt /* Option<T>::Some */: annotation_clause;`
    ///
    #[parol_runtime::function_name::named]
    fn description_opt_0(&mut self, _annotation_clause: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let annotation_clause = pop_item!(self, annotation_clause, AnnotationClause, context);
        let description_opt_0_built = DescriptionOpt { annotation_clause };
        self.push(
            ASTType::DescriptionOpt(Some(description_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 498:
    ///
    /// `descriptionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DescriptionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 499:
    ///
    /// `description_string: description_stringOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string(&mut self, _description_string_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt =
            pop_item!(self, description_string_opt, DescriptionStringOpt, context);
        let description_string_built = DescriptionString {
            description_string_opt,
        };
        // Calling user action here
        self.user_grammar
            .description_string(&description_string_built)?;
        self.push(
            ASTType::DescriptionString(description_string_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 500:
    ///
    /// `description_stringOpt /* Option<T>::Some */: string description_stringOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_0(
        &mut self,
        _string: &ParseTreeType<'t>,
        _description_string_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt_list = pop_and_reverse_item!(
            self,
            description_string_opt_list,
            DescriptionStringOptList,
            context
        );
        let string = pop_item!(self, string, String, context);
        let description_string_opt_0_built = DescriptionStringOpt {
            string: (&string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            description_string_opt_list,
        };
        self.push(
            ASTType::DescriptionStringOpt(Some(description_string_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 501:
    ///
    /// `description_stringOptList /* Vec<T>::Push */: '+'^ /* Clipped */ string description_stringOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_list_0(
        &mut self,
        _plus: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
        _description_string_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_string_opt_list = pop_item!(
            self,
            description_string_opt_list,
            DescriptionStringOptList,
            context
        );
        let string = pop_item!(self, string, String, context);
        let description_string_opt_list_0_built = DescriptionStringOptList {
            string: (&string)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        description_string_opt_list.push(description_string_opt_list_0_built);
        self.push(
            ASTType::DescriptionStringOptList(description_string_opt_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 502:
    ///
    /// `description_stringOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_string_opt_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionStringOptList(description_string_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 503:
    ///
    /// `description_stringOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_string_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DescriptionStringOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 504:
    ///
    /// `annotation_clause: annotation class_modification;`
    ///
    #[parol_runtime::function_name::named]
    fn annotation_clause(
        &mut self,
        _annotation: &ParseTreeType<'t>,
        _class_modification: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let class_modification = pop_item!(self, class_modification, ClassModification, context);
        let annotation = pop_item!(self, annotation, Annotation, context);
        let annotation_clause_built = AnnotationClause {
            annotation,
            class_modification: Box::new(class_modification),
        };
        // Calling user action here
        self.user_grammar
            .annotation_clause(&annotation_clause_built)?;
        self.push(ASTType::AnnotationClause(annotation_clause_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ModelicaGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ModelicaGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.algorithm(&children[0]),
            1 => self.and(&children[0]),
            2 => self.annotation(&children[0]),
            3 => self.block(&children[0]),
            4 => self.r#break(&children[0]),
            5 => self.class(&children[0]),
            6 => self.connect(&children[0]),
            7 => self.connector(&children[0]),
            8 => self.constant(&children[0]),
            9 => self.constrainedby(&children[0]),
            10 => self.der(&children[0]),
            11 => self.discrete(&children[0]),
            12 => self.each(&children[0]),
            13 => self.r#else(&children[0]),
            14 => self.elseif(&children[0]),
            15 => self.elsewhen(&children[0]),
            16 => self.encapsulated(&children[0]),
            17 => self.end(&children[0]),
            18 => self.enumeration(&children[0]),
            19 => self.equation(&children[0]),
            20 => self.expandable(&children[0]),
            21 => self.extends(&children[0]),
            22 => self.external(&children[0]),
            23 => self.r#false(&children[0]),
            24 => self.r#final(&children[0]),
            25 => self.flow(&children[0]),
            26 => self.r#for(&children[0]),
            27 => self.function(&children[0]),
            28 => self.r#if(&children[0]),
            29 => self.import(&children[0]),
            30 => self.impure(&children[0]),
            31 => self.r#in(&children[0]),
            32 => self.initial(&children[0]),
            33 => self.inner(&children[0]),
            34 => self.input(&children[0]),
            35 => self.r#loop(&children[0]),
            36 => self.model(&children[0]),
            37 => self.not(&children[0]),
            38 => self.operator(&children[0]),
            39 => self.or(&children[0]),
            40 => self.outer(&children[0]),
            41 => self.output(&children[0]),
            42 => self.package(&children[0]),
            43 => self.parameter(&children[0]),
            44 => self.partial(&children[0]),
            45 => self.protected(&children[0]),
            46 => self.public(&children[0]),
            47 => self.pure(&children[0]),
            48 => self.record(&children[0]),
            49 => self.redeclare(&children[0]),
            50 => self.replaceable(&children[0]),
            51 => self.r#return(&children[0]),
            52 => self.stream(&children[0]),
            53 => self.then(&children[0]),
            54 => self.r#true(&children[0]),
            55 => self.r#type(&children[0]),
            56 => self.when(&children[0]),
            57 => self.r#while(&children[0]),
            58 => self.within(&children[0]),
            59 => self.ident_0(&children[0]),
            60 => self.ident_1(&children[0]),
            61 => self.string(&children[0]),
            62 => self.unsigned_integer(&children[0]),
            63 => self.unsigned_real_0(&children[0]),
            64 => self.unsigned_real_1(&children[0]),
            65 => self.unsigned_real_2(&children[0]),
            66 => self.stored_definition(&children[0], &children[1]),
            67 => self.stored_definition_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            68 => self.stored_definition_list_1(),
            69 => self.stored_definition_opt0_0(&children[0]),
            70 => self.stored_definition_opt0_1(),
            71 => self.stored_definition_opt_0(&children[0], &children[1], &children[2]),
            72 => self.stored_definition_opt1_0(&children[0]),
            73 => self.stored_definition_opt1_1(),
            74 => self.stored_definition_opt_1(),
            75 => self.class_definition(&children[0], &children[1], &children[2]),
            76 => self.class_definition_opt_0(&children[0]),
            77 => self.class_definition_opt_1(),
            78 => self.class_type_0(&children[0]),
            79 => self.class_type_1(&children[0]),
            80 => self.class_type_2(&children[0], &children[1]),
            81 => self.class_type_3(&children[0]),
            82 => self.class_type_4(&children[0], &children[1]),
            83 => self.class_type_5(&children[0]),
            84 => self.class_type_6(&children[0]),
            85 => self.class_type_7(&children[0], &children[1], &children[2]),
            86 => self.class_type_8(&children[0]),
            87 => self.class_type_opt2_0(&children[0]),
            88 => self.class_type_opt2_1(),
            89 => self.class_type_opt1_0(&children[0]),
            90 => self.class_type_opt1_group_0(&children[0]),
            91 => self.class_type_opt1_group_1(&children[0]),
            92 => self.class_type_opt1_1(),
            93 => self.class_type_opt0_0(&children[0]),
            94 => self.class_type_opt0_1(),
            95 => self.class_type_opt_0(&children[0]),
            96 => self.class_type_opt_1(),
            97 => self.class_prefixes(&children[0], &children[1]),
            98 => self.class_prefixes_opt_0(&children[0]),
            99 => self.class_prefixes_opt_1(),
            100 => self.class_specifier_0(&children[0]),
            101 => self.class_specifier_1(&children[0]),
            102 => self.class_specifier_2(&children[0]),
            103 => self.long_class_specifier_0(&children[0]),
            104 => self.long_class_specifier_1(&children[0]),
            105 => self.standard_class_specifier(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            106 => self.extends_class_specifier(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            107 => self.extends_class_specifier_opt_0(&children[0]),
            108 => self.extends_class_specifier_opt_1(),
            109 => self.short_class_specifier_0(&children[0]),
            110 => self.short_class_specifier_1(&children[0]),
            111 => self.type_class_specifier(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            112 => self.type_class_specifier_opt0_0(&children[0]),
            113 => self.type_class_specifier_opt0_1(),
            114 => self.type_class_specifier_opt_0(&children[0]),
            115 => self.type_class_specifier_opt_1(),
            116 => self.enum_class_specifier(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            117 => self.enum_class_specifier_group_0(&children[0]),
            118 => self.enum_class_specifier_group_1(&children[0]),
            119 => self.enum_class_specifier_opt_0(&children[0]),
            120 => self.enum_class_specifier_opt_1(),
            121 => self.der_class_specifier(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
            ),
            122 => self.der_class_specifier_list_0(&children[0], &children[1], &children[2]),
            123 => self.der_class_specifier_list_1(),
            124 => self.base_prefix(&children[0]),
            125 => self.base_prefix_opt_0(&children[0]),
            126 => self.base_prefix_opt_group_0(&children[0]),
            127 => self.base_prefix_opt_group_1(&children[0]),
            128 => self.base_prefix_opt_1(),
            129 => self.enum_list(&children[0], &children[1]),
            130 => self.enum_list_list_0(&children[0], &children[1], &children[2]),
            131 => self.enum_list_list_1(),
            132 => self.enumeration_literal(&children[0], &children[1]),
            133 => self.composition(&children[0], &children[1], &children[2], &children[3]),
            134 => self.composition_list_0(&children[0], &children[1]),
            135 => self.composition_list_group_0(&children[0], &children[1]),
            136 => self.composition_list_group_1(&children[0], &children[1]),
            137 => self.composition_list_group_2(&children[0]),
            138 => self.composition_list_group_3(&children[0]),
            139 => self.composition_list_1(),
            140 => self.composition_opt0_0(&children[0], &children[1]),
            141 => self.composition_opt0_1(),
            142 => self.composition_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            143 => self.composition_opt3_0(&children[0]),
            144 => self.composition_opt3_1(),
            145 => self.composition_opt2_0(&children[0]),
            146 => self.composition_opt2_1(),
            147 => self.composition_opt1_0(&children[0]),
            148 => self.composition_opt1_1(),
            149 => self.composition_opt_1(),
            150 => self.language_specification(&children[0]),
            151 => self.external_function_call(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            152 => self.external_function_call_opt0_0(&children[0]),
            153 => self.external_function_call_opt0_1(),
            154 => self.external_function_call_opt_0(&children[0], &children[1]),
            155 => self.external_function_call_opt_1(),
            156 => self.element_list(&children[0]),
            157 => self.element_list_list_0(&children[0], &children[1], &children[2]),
            158 => self.element_list_list_1(),
            159 => self.element_0(&children[0]),
            160 => self.element_1(&children[0]),
            161 => self.element_2(&children[0]),
            162 => self.element_3(&children[0]),
            163 => self.element_definition(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            164 => self.element_definition_group_0(&children[0]),
            165 => self.element_definition_group_1(&children[0]),
            166 => self.element_definition_opt2_0(&children[0]),
            167 => self.element_definition_opt2_1(),
            168 => self.element_definition_opt1_0(&children[0]),
            169 => self.element_definition_opt1_1(),
            170 => self.element_definition_opt0_0(&children[0]),
            171 => self.element_definition_opt0_1(),
            172 => self.element_definition_opt_0(&children[0]),
            173 => self.element_definition_opt_1(),
            174 => self.element_replaceable_definition(&children[0], &children[1], &children[2]),
            175 => self.element_replaceable_definition_group_0(&children[0]),
            176 => self.element_replaceable_definition_group_1(&children[0]),
            177 => self.element_replaceable_definition_opt_0(&children[0], &children[1]),
            178 => self.element_replaceable_definition_opt_1(),
            179 => self.import_clause(&children[0], &children[1], &children[2]),
            180 => self.import_clause_group_0(&children[0], &children[1], &children[2]),
            181 => self.import_clause_group_1(&children[0], &children[1]),
            182 => self.import_clause_opt_0(&children[0]),
            183 => self.import_clause_opt_group_0(&children[0]),
            184 => self.import_clause_opt_group_1(&children[0], &children[1]),
            185 => self.import_clause_opt_group_group_0(&children[0]),
            186 => self.import_clause_opt_group_group_1(&children[0], &children[1], &children[2]),
            187 => self.import_clause_opt_1(),
            188 => self.import_list(&children[0], &children[1]),
            189 => self.import_list_list_0(&children[0], &children[1], &children[2]),
            190 => self.import_list_list_1(),
            191 => self.extends_clause(&children[0], &children[1], &children[2], &children[3]),
            192 => self.extends_clause_opt0_0(&children[0]),
            193 => self.extends_clause_opt0_1(),
            194 => self.extends_clause_opt_0(&children[0]),
            195 => self.extends_clause_opt_1(),
            196 => self.constraining_clause(&children[0], &children[1], &children[2]),
            197 => self.constraining_clause_opt_0(&children[0]),
            198 => self.constraining_clause_opt_1(),
            199 => self.class_or_inheritance_modification(&children[0], &children[1], &children[2]),
            200 => self.class_or_inheritance_modification_opt_0(&children[0]),
            201 => self.class_or_inheritance_modification_opt_1(),
            202 => self.argument_or_inheritance_modification_list(&children[0], &children[1]),
            203 => self.argument_or_inheritance_modification_list_group_0(&children[0]),
            204 => self.argument_or_inheritance_modification_list_group_1(&children[0]),
            205 => self.argument_or_inheritance_modification_list_list_0(
                &children[0],
                &children[1],
                &children[2],
            ),
            206 => self.argument_or_inheritance_modification_list_list_group_0(&children[0]),
            207 => self.argument_or_inheritance_modification_list_list_group_1(&children[0]),
            208 => self.argument_or_inheritance_modification_list_list_1(),
            209 => self.inheritance_modification(&children[0], &children[1]),
            210 => self.inheritance_modification_group_0(&children[0]),
            211 => self.inheritance_modification_group_1(&children[0]),
            212 => self.component_clause(&children[0], &children[1], &children[2], &children[3]),
            213 => self.component_clause_opt_0(&children[0]),
            214 => self.component_clause_opt_1(),
            215 => self.type_prefix(&children[0], &children[1], &children[2]),
            216 => self.type_prefix_opt1_0(&children[0]),
            217 => self.type_prefix_opt1_group_0(&children[0]),
            218 => self.type_prefix_opt1_group_1(&children[0]),
            219 => self.type_prefix_opt1_1(),
            220 => self.type_prefix_opt0_0(&children[0]),
            221 => self.type_prefix_opt0_group_0(&children[0]),
            222 => self.type_prefix_opt0_group_1(&children[0]),
            223 => self.type_prefix_opt0_group_2(&children[0]),
            224 => self.type_prefix_opt0_1(),
            225 => self.type_prefix_opt_0(&children[0]),
            226 => self.type_prefix_opt_group_0(&children[0]),
            227 => self.type_prefix_opt_group_1(&children[0]),
            228 => self.type_prefix_opt_1(),
            229 => self.component_list(&children[0], &children[1]),
            230 => self.component_list_list_0(&children[0], &children[1], &children[2]),
            231 => self.component_list_list_1(),
            232 => self.component_declaration(&children[0], &children[1], &children[2]),
            233 => self.component_declaration_opt_0(&children[0]),
            234 => self.component_declaration_opt_1(),
            235 => self.condition_attribute(&children[0], &children[1]),
            236 => self.declaration(&children[0], &children[1], &children[2]),
            237 => self.declaration_opt0_0(&children[0]),
            238 => self.declaration_opt0_1(),
            239 => self.declaration_opt_0(&children[0]),
            240 => self.declaration_opt_1(),
            241 => self.modification_0(&children[0], &children[1]),
            242 => self.modification_1(&children[0], &children[1]),
            243 => self.modification_opt_0(&children[0], &children[1]),
            244 => self.modification_opt_1(),
            245 => self.modification_expression_0(&children[0]),
            246 => self.modification_expression_1(&children[0]),
            247 => self.class_modification(&children[0], &children[1], &children[2]),
            248 => self.class_modification_opt_0(&children[0]),
            249 => self.class_modification_opt_1(),
            250 => self.argument_list(&children[0], &children[1]),
            251 => self.argument_list_list_0(&children[0], &children[1], &children[2]),
            252 => self.argument_list_list_1(),
            253 => self.argument_0(&children[0]),
            254 => self.argument_1(&children[0]),
            255 => {
                self.element_modification_or_replaceable(&children[0], &children[1], &children[2])
            }
            256 => self.element_modification_or_replaceable_group_0(&children[0]),
            257 => self.element_modification_or_replaceable_group_1(&children[0]),
            258 => self.element_modification_or_replaceable_opt0_0(&children[0]),
            259 => self.element_modification_or_replaceable_opt0_1(),
            260 => self.element_modification_or_replaceable_opt_0(&children[0]),
            261 => self.element_modification_or_replaceable_opt_1(),
            262 => self.element_modification(&children[0], &children[1], &children[2]),
            263 => self.element_modification_opt_0(&children[0]),
            264 => self.element_modification_opt_1(),
            265 => {
                self.element_redeclaration(&children[0], &children[1], &children[2], &children[3])
            }
            266 => self.element_redeclaration_group_0(&children[0]),
            267 => self.element_redeclaration_group_1(&children[0]),
            268 => self.element_redeclaration_group_2(&children[0]),
            269 => self.element_redeclaration_opt0_0(&children[0]),
            270 => self.element_redeclaration_opt0_1(),
            271 => self.element_redeclaration_opt_0(&children[0]),
            272 => self.element_redeclaration_opt_1(),
            273 => self.element_replaceable(&children[0], &children[1], &children[2]),
            274 => self.element_replaceable_group_0(&children[0]),
            275 => self.element_replaceable_group_1(&children[0]),
            276 => self.element_replaceable_opt_0(&children[0]),
            277 => self.element_replaceable_opt_1(),
            278 => self.component_clause1(&children[0], &children[1], &children[2]),
            279 => self.component_declaration1(&children[0], &children[1]),
            280 => self.short_class_definition(&children[0], &children[1]),
            281 => self.equation_section(&children[0], &children[1], &children[2]),
            282 => self.equation_section_list_0(&children[0], &children[1], &children[2]),
            283 => self.equation_section_list_1(),
            284 => self.equation_section_opt_0(&children[0]),
            285 => self.equation_section_opt_1(),
            286 => self.algorithm_section(&children[0], &children[1], &children[2]),
            287 => self.algorithm_section_list_0(&children[0], &children[1], &children[2]),
            288 => self.algorithm_section_list_1(),
            289 => self.algorithm_section_opt_0(&children[0]),
            290 => self.algorithm_section_opt_1(),
            291 => self.some_equation_option_0(&children[0]),
            292 => self.some_equation_option_1(&children[0]),
            293 => self.some_equation_option_2(&children[0]),
            294 => self.some_equation_option_3(&children[0]),
            295 => self.some_equation_option_4(&children[0]),
            296 => self.simple_equation(&children[0], &children[1]),
            297 => self.simple_equation_opt_0(&children[0], &children[1]),
            298 => self.simple_equation_opt_1(),
            299 => self.some_equation(&children[0], &children[1]),
            300 => self.statement_option_0(&children[0]),
            301 => self.statement_option_1(&children[0]),
            302 => self.statement_option_2(&children[0]),
            303 => self.statement_option_3(&children[0]),
            304 => self.statement_option_4(&children[0]),
            305 => self.statement_option_5(&children[0]),
            306 => self.statement_option_6(&children[0]),
            307 => self.statement_option_7(&children[0]),
            308 => self.component_statement(&children[0], &children[1]),
            309 => self.component_statement_group_0(&children[0], &children[1]),
            310 => self.component_statement_group_1(&children[0]),
            311 => self.function_call_output_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            312 => self.statement(&children[0], &children[1]),
            313 => self.equation_block(&children[0], &children[1], &children[2]),
            314 => self.equation_block_list_0(&children[0], &children[1], &children[2]),
            315 => self.equation_block_list_1(),
            316 => self.if_equation(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            317 => self.if_equation_list_0(&children[0], &children[1], &children[2]),
            318 => self.if_equation_list_1(),
            319 => self.if_equation_opt_0(&children[0], &children[1]),
            320 => self.if_equation_opt_list_0(&children[0], &children[1], &children[2]),
            321 => self.if_equation_opt_list_1(),
            322 => self.if_equation_opt_1(),
            323 => self.statement_block(&children[0], &children[1], &children[2]),
            324 => self.statement_block_list_0(&children[0], &children[1], &children[2]),
            325 => self.statement_block_list_1(),
            326 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            327 => self.if_statement_list_0(&children[0], &children[1], &children[2]),
            328 => self.if_statement_list_1(),
            329 => self.if_statement_opt_0(&children[0], &children[1]),
            330 => self.if_statement_opt_list_0(&children[0], &children[1], &children[2]),
            331 => self.if_statement_opt_list_1(),
            332 => self.if_statement_opt_1(),
            333 => self.for_equation(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            334 => self.for_equation_list_0(&children[0], &children[1], &children[2]),
            335 => self.for_equation_list_1(),
            336 => self.for_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            337 => self.for_statement_list_0(&children[0], &children[1], &children[2]),
            338 => self.for_statement_list_1(),
            339 => self.for_indices(&children[0], &children[1]),
            340 => self.for_indices_list_0(&children[0], &children[1], &children[2]),
            341 => self.for_indices_list_1(),
            342 => self.for_index(&children[0], &children[1]),
            343 => self.for_index_opt_0(&children[0], &children[1]),
            344 => self.for_index_opt_1(),
            345 => self.while_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            346 => self.while_statement_list_0(&children[0], &children[1], &children[2]),
            347 => self.while_statement_list_1(),
            348 => self.when_equation(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            349 => self.when_equation_list_0(&children[0], &children[1], &children[2]),
            350 => self.when_equation_list_1(),
            351 => self.when_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            352 => self.when_statement_list_0(&children[0], &children[1], &children[2]),
            353 => self.when_statement_list_1(),
            354 => self.connect_equation(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            355 => self.expression_0(&children[0]),
            356 => self.expression_1(&children[0]),
            357 => self.if_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            358 => self.if_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            359 => self.if_expression_list_1(),
            360 => self.simple_expression(&children[0], &children[1]),
            361 => self.simple_expression_opt_0(&children[0], &children[1], &children[2]),
            362 => self.simple_expression_opt0_0(&children[0], &children[1]),
            363 => self.simple_expression_opt0_1(),
            364 => self.simple_expression_opt_1(),
            365 => self.logical_expression(&children[0], &children[1]),
            366 => self.logical_expression_list_0(&children[0], &children[1], &children[2]),
            367 => self.logical_expression_list_1(),
            368 => self.logical_term(&children[0], &children[1]),
            369 => self.logical_term_list_0(&children[0], &children[1], &children[2]),
            370 => self.logical_term_list_1(),
            371 => self.logical_factor(&children[0], &children[1]),
            372 => self.logical_factor_opt_0(&children[0]),
            373 => self.logical_factor_opt_1(),
            374 => self.relation(&children[0], &children[1]),
            375 => self.relation_opt_0(&children[0], &children[1]),
            376 => self.relation_opt_1(),
            377 => self.relational_operator_0(&children[0]),
            378 => self.relational_operator_1(&children[0]),
            379 => self.relational_operator_2(&children[0]),
            380 => self.relational_operator_3(&children[0]),
            381 => self.relational_operator_4(&children[0]),
            382 => self.relational_operator_5(&children[0]),
            383 => self.arithmetic_expression(&children[0], &children[1], &children[2]),
            384 => self.arithmetic_expression_list_0(&children[0], &children[1], &children[2]),
            385 => self.arithmetic_expression_list_1(),
            386 => self.arithmetic_expression_opt_0(&children[0]),
            387 => self.arithmetic_expression_opt_1(),
            388 => self.add_operator_0(&children[0]),
            389 => self.add_operator_1(&children[0]),
            390 => self.add_operator_2(&children[0]),
            391 => self.add_operator_3(&children[0]),
            392 => self.term(&children[0], &children[1]),
            393 => self.term_list_0(&children[0], &children[1], &children[2]),
            394 => self.term_list_1(),
            395 => self.mul_operator_0(&children[0]),
            396 => self.mul_operator_1(&children[0]),
            397 => self.mul_operator_2(&children[0]),
            398 => self.mul_operator_3(&children[0]),
            399 => self.factor(&children[0], &children[1]),
            400 => self.factor_list_0(&children[0], &children[1], &children[2]),
            401 => self.factor_list_group_0(&children[0]),
            402 => self.factor_list_group_1(&children[0]),
            403 => self.factor_list_1(),
            404 => self.primary_0(&children[0]),
            405 => self.primary_1(&children[0]),
            406 => self.primary_2(&children[0]),
            407 => self.primary_3(&children[0]),
            408 => self.primary_4(&children[0]),
            409 => self.primary_5(&children[0]),
            410 => self.primary_6(&children[0]),
            411 => self.primary_7(&children[0]),
            412 => self.primary_8(&children[0]),
            413 => self.primary_9(&children[0]),
            414 => self.component_primary(&children[0], &children[1]),
            415 => self.component_primary_opt_0(&children[0]),
            416 => self.component_primary_opt_1(),
            417 => self.output_primary(&children[0], &children[1], &children[2], &children[3]),
            418 => self.output_primary_opt_0(&children[0]),
            419 => self.output_primary_opt_group_0(&children[0]),
            420 => self.output_primary_opt_group_1(&children[0], &children[1]),
            421 => self.output_primary_opt_1(),
            422 => self.range_primary(&children[0], &children[1], &children[2], &children[3]),
            423 => self.range_primary_list_0(&children[0], &children[1], &children[2]),
            424 => self.range_primary_list_1(),
            425 => self.array_primary(&children[0], &children[1], &children[2]),
            426 => self.global_function_call(&children[0], &children[1]),
            427 => self.global_function_call_group_0(&children[0]),
            428 => self.global_function_call_group_1(&children[0]),
            429 => self.global_function_call_group_2(&children[0]),
            430 => self.unsigned_number_0(&children[0]),
            431 => self.unsigned_number_1(&children[0]),
            432 => self.type_specifier(&children[0], &children[1]),
            433 => self.type_specifier_opt_0(&children[0]),
            434 => self.type_specifier_opt_1(),
            435 => self.name(&children[0], &children[1]),
            436 => self.name_list_0(&children[0], &children[1], &children[2]),
            437 => self.name_list_1(),
            438 => self.component_reference(&children[0], &children[1], &children[2], &children[3]),
            439 => self.component_reference_list_0(&children[0], &children[1]),
            440 => self.component_reference_list_1(),
            441 => self.component_reference_opt0_0(&children[0]),
            442 => self.component_reference_opt0_1(),
            443 => self.component_reference_opt_0(&children[0]),
            444 => self.component_reference_opt_1(),
            445 => self.component_ref_part(&children[0], &children[1], &children[2]),
            446 => self.component_ref_part_opt_0(&children[0]),
            447 => self.component_ref_part_opt_1(),
            448 => self.function_call_args(&children[0], &children[1], &children[2]),
            449 => self.function_call_args_opt_0(&children[0]),
            450 => self.function_call_args_opt_1(),
            451 => self.function_arguments_0(&children[0], &children[1]),
            452 => self.function_arguments_1(&children[0], &children[1]),
            453 => self.function_arguments_2(&children[0]),
            454 => self.function_arguments_opt0_0(&children[0], &children[1]),
            455 => self.function_arguments_opt0_1(),
            456 => self.function_arguments_opt_0(&children[0]),
            457 => self.function_arguments_opt_group_0(&children[0], &children[1]),
            458 => self.function_arguments_opt_group_1(&children[0], &children[1]),
            459 => self.function_arguments_opt_1(),
            460 => self.function_arguments_non_first_0(&children[0], &children[1]),
            461 => self.function_arguments_non_first_1(&children[0]),
            462 => self.function_arguments_non_first_opt_0(&children[0], &children[1]),
            463 => self.function_arguments_non_first_opt_1(),
            464 => self.array_arguments(&children[0], &children[1]),
            465 => self.array_arguments_opt_0(&children[0]),
            466 => self.array_arguments_opt_group_0(&children[0], &children[1]),
            467 => self.array_arguments_opt_group_1(&children[0], &children[1]),
            468 => self.array_arguments_opt_1(),
            469 => self.array_arguments_non_first(&children[0], &children[1]),
            470 => self.array_arguments_non_first_opt_0(&children[0], &children[1]),
            471 => self.array_arguments_non_first_opt_1(),
            472 => self.named_arguments(&children[0], &children[1]),
            473 => self.named_arguments_opt_0(&children[0], &children[1]),
            474 => self.named_arguments_opt_1(),
            475 => self.named_argument(&children[0], &children[1], &children[2]),
            476 => self.function_argument_0(&children[0]),
            477 => self.function_argument_1(&children[0]),
            478 => self.function_partial_application(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            479 => self.function_partial_application_opt_0(&children[0]),
            480 => self.function_partial_application_opt_1(),
            481 => self.output_expression_list(&children[0], &children[1]),
            482 => self.output_expression_list_list_0(&children[0], &children[1], &children[2]),
            483 => self.output_expression_list_list_1(),
            484 => self.output_expression_list_opt0_0(&children[0]),
            485 => self.output_expression_list_opt0_1(),
            486 => self.output_expression_list_opt_0(&children[0]),
            487 => self.output_expression_list_opt_1(),
            488 => self.expression_list(&children[0], &children[1]),
            489 => self.expression_list_list_0(&children[0], &children[1], &children[2]),
            490 => self.expression_list_list_1(),
            491 => self.array_subscripts(&children[0], &children[1], &children[2], &children[3]),
            492 => self.array_subscripts_list_0(&children[0], &children[1], &children[2]),
            493 => self.array_subscripts_list_1(),
            494 => self.subscript_0(&children[0]),
            495 => self.subscript_1(&children[0]),
            496 => self.description(&children[0], &children[1]),
            497 => self.description_opt_0(&children[0]),
            498 => self.description_opt_1(),
            499 => self.description_string(&children[0]),
            500 => self.description_string_opt_0(&children[0], &children[1]),
            501 => self.description_string_opt_list_0(&children[0], &children[1], &children[2]),
            502 => self.description_string_opt_list_1(),
            503 => self.description_string_opt_1(),
            504 => self.annotation_clause(&children[0], &children[1]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
