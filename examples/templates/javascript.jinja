{%- macro render_dae_js(dae) -%}
{%- set vars_vects = ['u', 'p', 'c', 'cp', 'x', 'm', 'y', 'z'] -%}
{%- set vars_pre_vects = ['pre_x', 'pre_m', 'pre_z'] -%}

/*
Generated by Rumoca (JS target)
  rumoca pkg version : {{ dae.rumoca_version }} - {{ dae.git_version }}
  model hash : {{ dae.model_hash }}
  template hash : {{ dae.template_hash }}
*/

class Model {
  constructor() {
    // state/parameter metadata
    this.solved = false;

    // time is just a number in JS
    this.time = 0;

    // Declare vectors as ordered arrays + index maps
    {%- for var in vars_vects %}
    // {{ var }}
    this.{{ var }}Index = {
      {%- for name, comp in dae[var] | items %}
      {{ name }}: {{ loop.index0 }}{{ "," if not loop.last }}
      {%- endfor -%}
    };
    this.{{ var }}Names = [
      {%- for name, comp in dae[var] | items -%}
      "{{ name }}"{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ];
    this.{{ var }}0 = [
      {%- for name, comp in dae[var] | items -%}
      {{ render_expression_js(comp.start) }}{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ];
    {%- endfor %}

    {%- for var in vars_pre_vects %}
    // {{ var }}
    this.{{ var }}Index = {
      {%- for name, comp in dae[var] | items %}
      {{ name }}: {{ loop.index0 }}{{ "," if not loop.last }}
      {%- endfor -%}
    };
    this.{{ var }}Names = [
      {%- for name, comp in dae[var] | items -%}
      "{{ name }}"{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ];
    this.{{ var }}0 = [
      {%- for name, comp in dae[var] | items -%}
      0{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ];
    {%- endfor %}

    // x_dot names
    this.x_dotNames = [
      {%- for name, comp in dae.x_dot | items -%}
      "{{ name }}"{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ];

    // Build function handles for:
    // - f_x_dot: (t, x, m, u, p, c) -> xdot vector
    // - f_y:     (t, x, m, u, p, c) -> y vector
    // - f_c:     (t, x) -> c conditions
    // - events:  zero crossing functions zc_k(t, x)

    // Assume the template emits explicit expressions for xdot and y (no solver).
    this.f_x_dot = (t, x, m, u, p, c) => {
      // Provide named accessors
      const X = this._mkAccessor(x, this.xIndex);
      const M = this._mkAccessor(m, this.mIndex);
      const U = this._mkAccessor(u, this.uIndex);
      const P = this._mkAccessor(p, this.pIndex);
      const C = this._mkAccessor(c, this.cIndex);
      const CP = this._mkAccessor(this.cp0, this.cpIndex); // constant params (if needed)

      // Compute xdot components
      // The generator should emit an array literal with each component
      // matching x_dotNames ordering.
      return [
        {%- for eq in dae.explicit_x_dot %}
        {{ render_expression_js(eq) }}{{ "," if not loop.last }}
        {%- endfor %}
      ];
    };

    this.f_y = (t, x, m, u, p, c) => {
      const X = this._mkAccessor(x, this.xIndex);
      const M = this._mkAccessor(m, this.mIndex);
      const U = this._mkAccessor(u, this.uIndex);
      const P = this._mkAccessor(p, this.pIndex);
      const C = this._mkAccessor(c, this.cIndex);
      const CP = this._mkAccessor(this.cp0, this.cpIndex);
      return [
        {%- for eq in dae.explicit_y %}
        {{ render_expression_js(eq) }}{{ "," if not loop.last }}
        {%- endfor %}
      ];
    };

    // Conditions fc(t, x) -> tuple/array
    this.f_c = (t, x) => {
      const X = this._mkAccessor(x, this.xIndex);
      return [
        {%- for name, expr in dae.fc | items -%}
        {{ render_expression_js(expr) }}{{ "," if not loop.last }}
        {%- endfor -%}
      ];
    };

    // Zero-crossings
    this.events = [
      {%- for key, val in dae.fc | items %}
      (t, x) => {{ render_zero_crossing_js(val) }}{{ "," if not loop.last }}
      {%- endfor -%}
    ];

    // Event callbacks / resets: fr
    // Each fr_k returns new x after event.
    this.eventCallbacks = {
      {%- for key, val in dae.fr | items %}
      {{ loop.index0 }}: (t, x, p) => {
        // Provide "pre" and "current" X for assignment semantics
        const preX = x.slice();
        let _x = x.slice();
        {%- for name, comp in dae.x | items %}
        let {{ name }} = _x[this.xIndex.{{ name }}];
        let pre_{{ name }} = preX[this.xIndex.{{ name }}];
        {%- endfor %}
        {{ render_statement_js(val) }};
        // writeback updated state vars in name order
        {%- for name, comp in dae.x | items %}
        _x[this.xIndex.{{ name }}] = {{ name }};
        {%- endfor %}
        return _x;
      }{{ "," if not loop.last }}
      {%- endfor %}
    };

    // Prepare indices for vectors
    this._finalizeIndices();

    this.solved = true;
  }

  _finalizeIndices() {
    // Build reverse name->index maps for x/m/u/p/c/...
    this._mkIndex = (names) => {
      const map = {};
      names.forEach((n, i) => (map[n] = i));
      return map;
    };

    this.uIndex  = this._mkIndex(this.uNames);
    this.pIndex  = this._mkIndex(this.pNames);
    this.cIndex  = this._mkIndex(this.cNames);
    this.cpIndex = this._mkIndex(this.cpNames);
    this.xIndex  = this._mkIndex(this.xNames);
    this.mIndex  = this._mkIndex(this.mNames);
    this.yIndex  = this._mkIndex(this.yNames);
    this.zIndex  = this._mkIndex(this.zNames);
  }

  _mkAccessor(arr, indexMap) {
    // returns a function-like object: V('name') -> arr[idx], plus direct props
    // e.g., V.name
    const proxy = {};
    for (const k in indexMap) {
      const i = indexMap[k];
      proxy[k] = arr[i];
    }
    return proxy;
  }

  // Numerical helpers

  // RK4 integrator: f(t, x) -> dx/dt, fixed dt
  rk4Step(t, x, dt, f) {
    const k1 = f(t, x);
    const x2 = x.map((xi, i) => xi + 0.5 * dt * k1[i]);
    const k2 = f(t + 0.5 * dt, x2);
    const x3 = x.map((xi, i) => xi + 0.5 * dt * k2[i]);
    const k3 = f(t + 0.5 * dt, x3);
    const x4 = x.map((xi, i) => xi + dt * k3[i]);
    const k4 = f(t + dt, x4);
    return x.map((xi, i) => xi + (dt / 6) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]));
  }

  // Root-bracketing + bisection for event time between t and t+dt
  // zc is a function (t, x) -> scalar
  // fXdot is (t, x) -> xdot
  findEventTime(t0, x0, dt, zc, fXdot, maxIter = 30) {
    const z0 = zc(t0, x0);
    const x1 = this.rk4Step(t0, x0, dt, (t, x) => fXdot(t, x));
    const z1 = zc(t0 + dt, x1);
    if (z0 === 0) return t0; // already on event
    if (z0 * z1 > 0) return null; // no crossing

    // Bisection
    let aT = t0, aX = x0.slice(), aZ = z0;
    let bT = t0 + dt, bX = x1.slice(), bZ = z1;

    for (let i = 0; i < maxIter; i++) {
      const midT = 0.5 * (aT + bT);
      // integrate from t0 to midT
      const h = midT - t0;
      const midX = this.rk4Step(t0, x0, h, (t, x) => fXdot(t, x));
      const midZ = zc(midT, midX);

      if (Math.abs(midZ) < 1e-9) return midT;

      if (aZ * midZ <= 0) {
        bT = midT; bX = midX; bZ = midZ;
      } else {
        aT = midT; aX = midX; aZ = midZ;
      }
    }
    return 0.5 * (aT + bT);
  }

  // Simulation
  // f_u: function(t) -> array u
  simulate(t0, tf, dt, options = {}) {
    if (!this.solved) {
      // already set in constructor
      this.solved = true;
    }

    const f_u = options.f_u || ((t) => new Array(this.uNames.length).fill(0));
    let x = options.x0 || this.x0.slice();
    const p = this.p0.slice();
    const m = this.m0.slice();
    let t = t0;

    const data = {
      t: [],
      x: [],
      u: [],
      y: [],
      c: []
    };

    const maxEvents = options.maxEvents ?? 100;
    let eventCount = 0;

    while (t < tf - 1e-12) {
      const u = f_u(t);
      const c = this.f_c(t, x);

      // xdot function specialized for current u/p/m/c
      const fXdot = (ti, xi) => this.f_x_dot(ti, xi, m, u, p, c);

      // Event detection
      let eventTriggered = false;
      let eventIndex = -1;
      let eventTime = null;

      for (let i = 0; i < this.events.length; i++) {
        const zc = (ti, xi) => {
          // zero crossing uses internal definitions that may rely on x at ti
          const X = xi; // pass through
          return this.events[i](ti, xi);
        };
        const te = this.findEventTime(t, x, dt, zc, fXdot);
        if (te !== null) {
          eventTriggered = true;
          eventIndex = i;
          eventTime = te;
          break; // handle one event at a time
        }
      }

      if (eventTriggered) {
        if (eventCount > maxEvents) {
          throw new Error("Max events reached");
        }
        // Advance to event time
        const h = eventTime - t;
        x = this.rk4Step(t, x, h, (ti, xi) => fXdot(ti, xi));
        t = eventTime;

        // Apply reset if callback exists
        if (this.eventCallbacks[eventIndex]) {
          x = this.eventCallbacks[eventIndex](t, x, p);
          eventCount++;
        }

        // Store sample at event
        const y = this.f_y(t, x, m, u, p, c);
        data.t.push(t);
        data.x.push(x.slice());
        data.u.push(u.slice());
        data.y.push(y.slice());
        data.c.push(c.slice());
        // Continue loop without consuming full dt; next iteration will step again
        continue;
      }

      // Normal RK4 step
      const xNext = this.rk4Step(t, x, dt, (ti, xi) => fXdot(ti, xi));
      const y = this.f_y(t, x, m, u, p, c);

      data.t.push(t);
      data.x.push(x.slice());
      data.u.push(u.slice());
      data.y.push(y.slice());
      data.c.push(c.slice());

      x = xNext;
      t += dt;
    }

    return data;
  }

  // Convenience getters for initial vectors in array form
  get u0()  { return this._clone(this.u0_); } // placeholder if you want alias
  _clone(a) { return a.slice(); }
}

// ========== Rendering helpers ==========

// Expressions
{%- endmacro -%}

{%- macro render_expression_js(expr) -%}
    {%- if "Terminal" in expr -%}
        {{- render_terminal_js(expr.Terminal) -}}
    {%- elif "FunctionCall" in expr -%}
        {{- render_function_js(expr.FunctionCall) -}}
    {%- elif "ComponentReference" in expr -%}
        {{- render_component_reference_js(expr.ComponentReference) -}}
    {%- elif "Binary" in expr -%}
        {{- render_binary_js(expr.Binary) -}}
    {%- elif "Unary" in expr -%}
        {{- render_unary_js(expr.Unary) -}}
    {%- else -%}
        (function(){ throw new Error("UNHANDLED EXPRESSION: {{ expr | pprint | replace('\n',' ') }}"); })()
    {%- endif -%}
{%- endmacro -%}

{%- macro render_zero_crossing_js(expr) -%}
    {%- if "Binary" in expr -%}
        {%- if "Lt" in expr.Binary.op or "Gt" in expr.Binary.op -%}
            ({{ render_expression_js(expr.Binary.lhs) }}) - ({{ render_expression_js(expr.Binary.rhs) }})
        {%- else -%}
            (function(){ throw new Error("UNHANDLED ZERO CROSS OP: {{ expr.Binary.op | pprint }}"); })()
        {%- endif -%}
    {%- else -%}
        (function(){ throw new Error("UNHANDLED ZERO CROSS EXPR: {{ expr | pprint }}"); })()
    {%- endif -%}
{%- endmacro -%}

{%- macro render_statement_js(stmt) -%}
    {%- if "Assignment" in stmt -%}
        {{- render_component_reference_js(stmt.Assignment.comp) -}} = {{ render_expression_js(stmt.Assignment.value) }}
    {%- else -%}
        (function(){ throw new Error("UNHANDLED RESET STATEMENT: {{ stmt | pprint | replace('\n',' ') }}"); })()
    {%- endif -%}
{%- endmacro -%}

{%- macro render_terminal_js(term) -%}
    {%- if term.terminal_type == "UnsignedInteger" -%}
    {{ term.token.text | float }}
    {%- elif term.terminal_type == "UnsignedReal" -%}
    {{ term.token.text | float }}
    {%- elif term.terminal_type == "Bool" -%}
        {%- if term.token.text == "true" -%}
            true
        {%- elif term.token.text == "false" -%}
            false
        {%- else -%}
            (function(){ throw new Error("UNHANDLED BOOLEAN: {{ term | pprint }}"); })()
        {%- endif -%}
    {%- else -%}
        (function(){ throw new Error("UNHANDLED Terminal: {{ term | pprint }}"); })()
    {%- endif -%}
{%- endmacro -%}

{%- macro render_binary_js(expr) -%}
    ( {{ render_expression_js(expr.lhs) }} 
      {%- if "Add" in expr.op -%}+{% elif "Sub" in expr.op -%}-{% elif "Mul" in expr.op -%}*{% elif "Div" in expr.op -%}/{% elif "Lt" in expr.op -%}<{% elif "Gt" in expr.op -%}>{% else -%}
      {{ " /* UNHANDLED OP */ " }}
      {%- endif -%}
      {{ render_expression_js(expr.rhs) }} )
{%- endmacro -%}

{%- macro render_unary_js(expr) -%}
    {%- if "Minus" in expr.op -%}
        ( - ( {{ render_expression_js(expr.rhs) }} ) )
    {%- else -%}
        (function(){ throw new Error("UNHANDLED OP: {{ expr.op | pprint }}"); })()
    {%- endif -%}
{%- endmacro -%}

{%- macro render_component_reference_js(comp) -%}
    {# Map component references to JS access:
       - For state: X.name or x[idx]? We provide accessor earlier using _mkAccessor
       - In expressions we’ll refer using namespaces: X., U., P., C., M., CP., etc.
       - The generator must know which namespace to use; your IR likely encodes this.
       For simplicity, assume names are bare and you’ve already mapped in render_expression_js
       to X.name/U.name/etc. If your IR only has identifiers, you need a symbol table.
    #}
    {%- for part in comp.parts -%}
        {{ part.ident.text }}{% if not loop.last %}.{% endif %}
    {%- endfor -%}
{%- endmacro -%}

{%- macro render_function_js(func) -%}
    {# Map standard math functions #}
    {%- set fname = render_component_reference_js(func.comp) -%}
    {%- if fname in ["sin", "cos", "tan", "sqrt", "abs", "exp", "log", "pow"] -%}
        Math.{{ fname }}({% for arg in func.args %}{{ render_expression_js(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    {%- elif fname == "min" -%}
        Math.min({% for arg in func.args %}{{ render_expression_js(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    {%- elif fname == "max" -%}
        Math.max({% for arg in func.args %}{{ render_expression_js(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    {%- else -%}
        (function(){ throw new Error("UNHANDLED FUNCTION: {{ fname }}"); })()
    {%- endif -%}
{%- endmacro -%}

{{ render_dae_js(dae) }}
